System.registerDynamic("npm:codemirror@5.21.0.js", ["npm:codemirror@5.21.0/lib/codemirror.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:codemirror@5.21.0/lib/codemirror.js");
});
System.registerDynamic('npm:codemirror@5.21.0/lib/codemirror.js', ['github:jspm/nodelibs-process@0.1.2.js'], true, function ($__require, exports, module) {
  /* */
  "format cjs";

  var global = this || self,
      GLOBAL = global;
  (function (process) {
    (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof undefined === 'function' && define.amd ? define(factory) : global.CodeMirror = factory();
    })(this, function () {
      'use strict';

      var userAgent = navigator.userAgent;
      var platform = navigator.platform;
      var gecko = /gecko\/\d/i.test(userAgent);
      var ie_upto10 = /MSIE \d/.test(userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
      var ie = ie_upto10 || ie_11up;
      var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
      var webkit = /WebKit\//.test(userAgent);
      var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
      var chrome = /Chrome\//.test(userAgent);
      var presto = /Opera\//.test(userAgent);
      var safari = /Apple Computer/.test(navigator.vendor);
      var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
      var phantom = /PhantomJS/.test(userAgent);
      var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
      var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
      var mac = ios || /Mac/.test(platform);
      var chromeOS = /\bCrOS\b/.test(userAgent);
      var windows = /win/i.test(platform);
      var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
      if (presto_version) {
        presto_version = Number(presto_version[1]);
      }
      if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
      }
      var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
      var captureRightClick = gecko || ie && ie_version >= 9;
      function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
      }
      var rmClass = function (node, cls) {
        var current = node.className;
        var match = classTest(cls).exec(current);
        if (match) {
          var after = current.slice(match.index + match[0].length);
          node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
        }
      };
      function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count) {
          e.removeChild(e.firstChild);
        }
        return e;
      }
      function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
      }
      function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className) {
          e.className = className;
        }
        if (style) {
          e.style.cssText = style;
        }
        if (typeof content == "string") {
          e.appendChild(document.createTextNode(content));
        } else if (content) {
          for (var i = 0; i < content.length; ++i) {
            e.appendChild(content[i]);
          }
        }
        return e;
      }
      var range;
      if (document.createRange) {
        range = function (node, start, end, endNode) {
          var r = document.createRange();
          r.setEnd(endNode || node, end);
          r.setStart(node, start);
          return r;
        };
      } else {
        range = function (node, start, end) {
          var r = document.body.createTextRange();
          try {
            r.moveToElementText(node.parentNode);
          } catch (e) {
            return r;
          }
          r.collapse(true);
          r.moveEnd("character", end);
          r.moveStart("character", start);
          return r;
        };
      }
      function contains(parent, child) {
        if (child.nodeType == 3) {
          child = child.parentNode;
        }
        if (parent.contains) {
          return parent.contains(child);
        }
        do {
          if (child.nodeType == 11) {
            child = child.host;
          }
          if (child == parent) {
            return true;
          }
        } while (child = child.parentNode);
      }
      function activeElt() {
        var activeElement;
        try {
          activeElement = document.activeElement;
        } catch (e) {
          activeElement = document.body || null;
        }
        while (activeElement && activeElement.root && activeElement.root.activeElement) {
          activeElement = activeElement.root.activeElement;
        }
        return activeElement;
      }
      function addClass(node, cls) {
        var current = node.className;
        if (!classTest(cls).test(current)) {
          node.className += (current ? " " : "") + cls;
        }
      }
      function joinClasses(a, b) {
        var as = a.split(" ");
        for (var i = 0; i < as.length; i++) {
          if (as[i] && !classTest(as[i]).test(b)) {
            b += " " + as[i];
          }
        }
        return b;
      }
      var selectInput = function (node) {
        node.select();
      };
      if (ios) {
        selectInput = function (node) {
          node.selectionStart = 0;
          node.selectionEnd = node.value.length;
        };
      } else if (ie) {
        selectInput = function (node) {
          try {
            node.select();
          } catch (_e) {}
        };
      }
      function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
          return f.apply(null, args);
        };
      }
      function copyObj(obj, target, overwrite) {
        if (!target) {
          target = {};
        }
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {
            target[prop] = obj[prop];
          }
        }
        return target;
      }
      function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1) {
            end = string.length;
          }
        }
        for (var i = startIndex || 0, n = startValue || 0;;) {
          var nextTab = string.indexOf("\t", i);
          if (nextTab < 0 || nextTab >= end) {
            return n + (end - i);
          }
          n += nextTab - i;
          n += tabSize - n % tabSize;
          i = nextTab + 1;
        }
      }
      function Delayed() {
        this.id = null;
      }
      Delayed.prototype.set = function (ms, f) {
        clearTimeout(this.id);
        this.id = setTimeout(f, ms);
      };
      function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i) {
          if (array[i] == elt) {
            return i;
          }
        }
        return -1;
      }
      var scrollerGap = 30;
      var Pass = { toString: function () {
          return "CodeMirror.Pass";
        } };
      var sel_dontScroll = { scroll: false };
      var sel_mouse = { origin: "*mouse" };
      var sel_move = { origin: "+move" };
      function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0;;) {
          var nextTab = string.indexOf("\t", pos);
          if (nextTab == -1) {
            nextTab = string.length;
          }
          var skipped = nextTab - pos;
          if (nextTab == string.length || col + skipped >= goal) {
            return pos + Math.min(skipped, goal - col);
          }
          col += nextTab - pos;
          col += tabSize - col % tabSize;
          pos = nextTab + 1;
          if (col >= goal) {
            return pos;
          }
        }
      }
      var spaceStrs = [""];
      function spaceStr(n) {
        while (spaceStrs.length <= n) {
          spaceStrs.push(lst(spaceStrs) + " ");
        }
        return spaceStrs[n];
      }
      function lst(arr) {
        return arr[arr.length - 1];
      }
      function map(array, f) {
        var out = [];
        for (var i = 0; i < array.length; i++) {
          out[i] = f(array[i], i);
        }
        return out;
      }
      function insertSorted(array, value, score) {
        var pos = 0,
            priority = score(value);
        while (pos < array.length && score(array[pos]) <= priority) {
          pos++;
        }
        array.splice(pos, 0, value);
      }
      function nothing() {}
      function createObj(base, props) {
        var inst;
        if (Object.create) {
          inst = Object.create(base);
        } else {
          nothing.prototype = base;
          inst = new nothing();
        }
        if (props) {
          copyObj(props, inst);
        }
        return inst;
      }
      var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      function isWordCharBasic(ch) {
        return (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
        );
      }
      function isWordChar(ch, helper) {
        if (!helper) {
          return isWordCharBasic(ch);
        }
        if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
          return true;
        }
        return helper.test(ch);
      }
      function isEmpty(obj) {
        for (var n in obj) {
          if (obj.hasOwnProperty(n) && obj[n]) {
            return false;
          }
        }
        return true;
      }
      var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
      function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
      }
      function Display(place, doc, input) {
        var d = this;
        this.input = input;
        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d.scrollbarFiller.setAttribute("cm-not-content", "true");
        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        d.gutterFiller.setAttribute("cm-not-content", "true");
        d.lineDiv = elt("div", null, "CodeMirror-code");
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        d.cursorDiv = elt("div", null, "CodeMirror-cursors");
        d.measure = elt("div", null, "CodeMirror-measure");
        d.lineMeasure = elt("div", null, "CodeMirror-measure");
        d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
        d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
        d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
        d.sizerWidth = null;
        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
        d.gutters = elt("div", null, "CodeMirror-gutters");
        d.lineGutter = null;
        d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
        d.scroller.setAttribute("tabIndex", "-1");
        d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
        if (ie && ie_version < 8) {
          d.gutters.style.zIndex = -1;
          d.scroller.style.paddingRight = 0;
        }
        if (!webkit && !(gecko && mobile)) {
          d.scroller.draggable = true;
        }
        if (place) {
          if (place.appendChild) {
            place.appendChild(d.wrapper);
          } else {
            place(d.wrapper);
          }
        }
        d.viewFrom = d.viewTo = doc.first;
        d.reportedViewFrom = d.reportedViewTo = doc.first;
        d.view = [];
        d.renderedView = null;
        d.externalMeasured = null;
        d.viewOffset = 0;
        d.lastWrapHeight = d.lastWrapWidth = 0;
        d.updateLineNumbers = null;
        d.nativeBarWidth = d.barHeight = d.barWidth = 0;
        d.scrollbarsClipped = false;
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        d.alignWidgets = false;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
        d.shift = false;
        d.selForContextMenu = null;
        d.activeTouch = null;
        input.init(d);
      }
      function getLine(doc, n) {
        n -= doc.first;
        if (n < 0 || n >= doc.size) {
          throw new Error("There is no line " + (n + doc.first) + " in the document.");
        }
        var chunk = doc;
        while (!chunk.lines) {
          for (var i = 0;; ++i) {
            var child = chunk.children[i],
                sz = child.chunkSize();
            if (n < sz) {
              chunk = child;
              break;
            }
            n -= sz;
          }
        }
        return chunk.lines[n];
      }
      function getBetween(doc, start, end) {
        var out = [],
            n = start.line;
        doc.iter(start.line, end.line + 1, function (line) {
          var text = line.text;
          if (n == end.line) {
            text = text.slice(0, end.ch);
          }
          if (n == start.line) {
            text = text.slice(start.ch);
          }
          out.push(text);
          ++n;
        });
        return out;
      }
      function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function (line) {
          out.push(line.text);
        });
        return out;
      }
      function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff) {
          for (var n = line; n; n = n.parent) {
            n.height += diff;
          }
        }
      }
      function lineNo(line) {
        if (line.parent == null) {
          return null;
        }
        var cur = line.parent,
            no = indexOf(cur.lines, line);
        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
          for (var i = 0;; ++i) {
            if (chunk.children[i] == cur) {
              break;
            }
            no += chunk.children[i].chunkSize();
          }
        }
        return no + cur.first;
      }
      function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer: do {
          for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
            var child = chunk.children[i$1],
                ch = child.height;
            if (h < ch) {
              chunk = child;
              continue outer;
            }
            h -= ch;
            n += child.chunkSize();
          }
          return n;
        } while (!chunk.lines);
        var i = 0;
        for (; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i],
              lh = line.height;
          if (h < lh) {
            break;
          }
          h -= lh;
        }
        return n + i;
      }
      function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
      }
      function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
      }
      function Pos(line, ch) {
        if (!(this instanceof Pos)) {
          return new Pos(line, ch);
        }
        this.line = line;
        this.ch = ch;
      }
      function cmp(a, b) {
        return a.line - b.line || a.ch - b.ch;
      }
      function copyPos(x) {
        return Pos(x.line, x.ch);
      }
      function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
      }
      function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
      }
      function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
      }
      function clipPos(doc, pos) {
        if (pos.line < doc.first) {
          return Pos(doc.first, 0);
        }
        var last = doc.first + doc.size - 1;
        if (pos.line > last) {
          return Pos(last, getLine(doc, last).text.length);
        }
        return clipToLen(pos, getLine(doc, pos.line).text.length);
      }
      function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen) {
          return Pos(pos.line, linelen);
        } else if (ch < 0) {
          return Pos(pos.line, 0);
        } else {
          return pos;
        }
      }
      function clipPosArray(doc, array) {
        var out = [];
        for (var i = 0; i < array.length; i++) {
          out[i] = clipPos(doc, array[i]);
        }
        return out;
      }
      var sawReadOnlySpans = false;
      var sawCollapsedSpans = false;
      function seeReadOnlySpans() {
        sawReadOnlySpans = true;
      }
      function seeCollapsedSpans() {
        sawCollapsedSpans = true;
      }
      function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from;
        this.to = to;
      }
      function getMarkedSpanFor(spans, marker) {
        if (spans) {
          for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            if (span.marker == marker) {
              return span;
            }
          }
        }
      }
      function removeMarkedSpan(spans, span) {
        var r;
        for (var i = 0; i < spans.length; ++i) {
          if (spans[i] != span) {
            (r || (r = [])).push(spans[i]);
          }
        }
        return r;
      }
      function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        span.marker.attachLine(line);
      }
      function markedSpansBefore(old, startCh, isInsert) {
        var nw;
        if (old) {
          for (var i = 0; i < old.length; ++i) {
            var span = old[i],
                marker = span.marker;
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
            if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
              ;
              (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
            }
          }
        }
        return nw;
      }
      function markedSpansAfter(old, endCh, isInsert) {
        var nw;
        if (old) {
          for (var i = 0; i < old.length; ++i) {
            var span = old[i],
                marker = span.marker;
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
            if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
              ;
              (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
            }
          }
        }
        return nw;
      }
      function stretchSpansOverChange(doc, change) {
        if (change.full) {
          return null;
        }
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast) {
          return null;
        }
        var startCh = change.from.ch,
            endCh = change.to.ch,
            isInsert = cmp(change.from, change.to) == 0;
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);
        var sameLine = change.text.length == 1,
            offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
          for (var i = 0; i < first.length; ++i) {
            var span = first[i];
            if (span.to == null) {
              var found = getMarkedSpanFor(last, span.marker);
              if (!found) {
                span.to = startCh;
              } else if (sameLine) {
                span.to = found.to == null ? null : found.to + offset;
              }
            }
          }
        }
        if (last) {
          for (var i$1 = 0; i$1 < last.length; ++i$1) {
            var span$1 = last[i$1];
            if (span$1.to != null) {
              span$1.to += offset;
            }
            if (span$1.from == null) {
              var found$1 = getMarkedSpanFor(first, span$1.marker);
              if (!found$1) {
                span$1.from = offset;
                if (sameLine) {
                  (first || (first = [])).push(span$1);
                }
              }
            } else {
              span$1.from += offset;
              if (sameLine) {
                (first || (first = [])).push(span$1);
              }
            }
          }
        }
        if (first) {
          first = clearEmptySpans(first);
        }
        if (last && last != first) {
          last = clearEmptySpans(last);
        }
        var newMarkers = [first];
        if (!sameLine) {
          var gap = change.text.length - 2,
              gapMarkers;
          if (gap > 0 && first) {
            for (var i$2 = 0; i$2 < first.length; ++i$2) {
              if (first[i$2].to == null) {
                (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
              }
            }
          }
          for (var i$3 = 0; i$3 < gap; ++i$3) {
            newMarkers.push(gapMarkers);
          }
          newMarkers.push(last);
        }
        return newMarkers;
      }
      function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
            spans.splice(i--, 1);
          }
        }
        if (!spans.length) {
          return null;
        }
        return spans;
      }
      function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function (line) {
          if (line.markedSpans) {
            for (var i = 0; i < line.markedSpans.length; ++i) {
              var mark = line.markedSpans[i].marker;
              if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
                (markers || (markers = [])).push(mark);
              }
            }
          }
        });
        if (!markers) {
          return null;
        }
        var parts = [{
          from: from,
          to: to
        }];
        for (var i = 0; i < markers.length; ++i) {
          var mk = markers[i],
              m = mk.find(0);
          for (var j = 0; j < parts.length; ++j) {
            var p = parts[j];
            if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
              continue;
            }
            var newParts = [j, 1],
                dfrom = cmp(p.from, m.from),
                dto = cmp(p.to, m.to);
            if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
              newParts.push({
                from: p.from,
                to: m.from
              });
            }
            if (dto > 0 || !mk.inclusiveRight && !dto) {
              newParts.push({
                from: m.to,
                to: p.to
              });
            }
            parts.splice.apply(parts, newParts);
            j += newParts.length - 1;
          }
        }
        return parts;
      }
      function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans) {
          return;
        }
        for (var i = 0; i < spans.length; ++i) {
          spans[i].marker.detachLine(line);
        }
        line.markedSpans = null;
      }
      function attachMarkedSpans(line, spans) {
        if (!spans) {
          return;
        }
        for (var i = 0; i < spans.length; ++i) {
          spans[i].marker.attachLine(line);
        }
        line.markedSpans = spans;
      }
      function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
      }
      function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
      }
      function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (lenDiff != 0) {
          return lenDiff;
        }
        var aPos = a.find(),
            bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp) {
          return -fromCmp;
        }
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        if (toCmp) {
          return toCmp;
        }
        return b.id - a.id;
      }
      function collapsedSpanAtSide(line, start) {
        var sps = sawCollapsedSpans && line.markedSpans,
            found;
        if (sps) {
          for (var sp = void 0, i = 0; i < sps.length; ++i) {
            sp = sps[i];
            if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
              found = sp.marker;
            }
          }
        }
        return found;
      }
      function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
      }
      function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
      }
      function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        var line = getLine(doc, lineNo);
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) {
          for (var i = 0; i < sps.length; ++i) {
            var sp = sps[i];
            if (!sp.marker.collapsed) {
              continue;
            }
            var found = sp.marker.find(0);
            var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
            var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
            if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
              continue;
            }
            if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
              return true;
            }
          }
        }
      }
      function visualLine(line) {
        var merged;
        while (merged = collapsedSpanAtStart(line)) {
          line = merged.find(-1, true).line;
        }
        return line;
      }
      function visualLineContinued(line) {
        var merged, lines;
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
          ;
          (lines || (lines = [])).push(line);
        }
        return lines;
      }
      function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN),
            vis = visualLine(line);
        if (line == vis) {
          return lineN;
        }
        return lineNo(vis);
      }
      function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine()) {
          return lineN;
        }
        var line = getLine(doc, lineN),
            merged;
        if (!lineIsHidden(doc, line)) {
          return lineN;
        }
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
        }
        return lineNo(line) + 1;
      }
      function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) {
          for (var sp = void 0, i = 0; i < sps.length; ++i) {
            sp = sps[i];
            if (!sp.marker.collapsed) {
              continue;
            }
            if (sp.from == null) {
              return true;
            }
            if (sp.marker.widgetNode) {
              continue;
            }
            if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
              return true;
            }
          }
        }
      }
      function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
          var end = span.marker.find(1, true);
          return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length) {
          return true;
        }
        for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {
          sp = line.markedSpans[i];
          if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
            return true;
          }
        }
      }
      function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        var h = 0,
            chunk = lineObj.parent;
        for (var i = 0; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i];
          if (line == lineObj) {
            break;
          } else {
            h += line.height;
          }
        }
        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
          for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
            var cur = p.children[i$1];
            if (cur == chunk) {
              break;
            } else {
              h += cur.height;
            }
          }
        }
        return h;
      }
      function lineLength(line) {
        if (line.height == 0) {
          return 0;
        }
        var len = line.text.length,
            merged,
            cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
          var found = merged.find(0, true);
          cur = found.from.line;
          len += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
          var found$1 = merged.find(0, true);
          len -= cur.text.length - found$1.from.ch;
          cur = found$1.to.line;
          len += cur.text.length - found$1.to.ch;
        }
        return len;
      }
      function findMaxLine(cm) {
        var d = cm.display,
            doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function (line) {
          var len = lineLength(line);
          if (len > d.maxLineLength) {
            d.maxLineLength = len;
            d.maxLine = line;
          }
        });
      }
      function iterateBidiSections(order, from, to, f) {
        if (!order) {
          return f(from, to, "ltr");
        }
        var found = false;
        for (var i = 0; i < order.length; ++i) {
          var part = order[i];
          if (part.from < to && part.to > from || from == to && part.to == from) {
            f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
            found = true;
          }
        }
        if (!found) {
          f(from, to, "ltr");
        }
      }
      function bidiLeft(part) {
        return part.level % 2 ? part.to : part.from;
      }
      function bidiRight(part) {
        return part.level % 2 ? part.from : part.to;
      }
      function lineLeft(line) {
        var order = getOrder(line);
        return order ? bidiLeft(order[0]) : 0;
      }
      function lineRight(line) {
        var order = getOrder(line);
        if (!order) {
          return line.text.length;
        }
        return bidiRight(lst(order));
      }
      function compareBidiLevel(order, a, b) {
        var linedir = order[0].level;
        if (a == linedir) {
          return true;
        }
        if (b == linedir) {
          return false;
        }
        return a < b;
      }
      var bidiOther = null;
      function getBidiPartAt(order, pos) {
        var found;
        bidiOther = null;
        for (var i = 0; i < order.length; ++i) {
          var cur = order[i];
          if (cur.from < pos && cur.to > pos) {
            return i;
          }
          if (cur.from == pos || cur.to == pos) {
            if (found == null) {
              found = i;
            } else if (compareBidiLevel(order, cur.level, order[found].level)) {
              if (cur.from != cur.to) {
                bidiOther = found;
              }
              return i;
            } else {
              if (cur.from != cur.to) {
                bidiOther = i;
              }
              return found;
            }
          }
        }
        return found;
      }
      function moveInLine(line, pos, dir, byUnit) {
        if (!byUnit) {
          return pos + dir;
        }
        do {
          pos += dir;
        } while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
        return pos;
      }
      function moveVisually(line, start, dir, byUnit) {
        var bidi = getOrder(line);
        if (!bidi) {
          return moveLogically(line, start, dir, byUnit);
        }
        var pos = getBidiPartAt(bidi, start),
            part = bidi[pos];
        var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);
        for (;;) {
          if (target > part.from && target < part.to) {
            return target;
          }
          if (target == part.from || target == part.to) {
            if (getBidiPartAt(bidi, target) == pos) {
              return target;
            }
            part = bidi[pos += dir];
            return dir > 0 == part.level % 2 ? part.to : part.from;
          } else {
            part = bidi[pos += dir];
            if (!part) {
              return null;
            }
            if (dir > 0 == part.level % 2) {
              target = moveInLine(line, part.to, -1, byUnit);
            } else {
              target = moveInLine(line, part.from, 1, byUnit);
            }
          }
        }
      }
      function moveLogically(line, start, dir, byUnit) {
        var target = start + dir;
        if (byUnit) {
          while (target > 0 && isExtendingChar(line.text.charAt(target))) {
            target += dir;
          }
        }
        return target < 0 || target > line.text.length ? null : target;
      }
      var bidiOrdering = function () {
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
        var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
        function charType(code) {
          if (code <= 0xf7) {
            return lowTypes.charAt(code);
          } else if (0x590 <= code && code <= 0x5f4) {
            return "R";
          } else if (0x600 <= code && code <= 0x6ed) {
            return arabicTypes.charAt(code - 0x600);
          } else if (0x6ee <= code && code <= 0x8ac) {
            return "r";
          } else if (0x2000 <= code && code <= 0x200b) {
            return "w";
          } else if (code == 0x200c) {
            return "b";
          } else {
            return "L";
          }
        }
        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/,
            isStrong = /[LRr]/,
            countsAsLeft = /[Lb1n]/,
            countsAsNum = /[1n]/;
        var outerType = "L";
        function BidiSpan(level, from, to) {
          this.level = level;
          this.from = from;
          this.to = to;
        }
        return function (str) {
          if (!bidiRE.test(str)) {
            return false;
          }
          var len = str.length,
              types = [];
          for (var i = 0; i < len; ++i) {
            types.push(charType(str.charCodeAt(i)));
          }
          for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
            var type = types[i$1];
            if (type == "m") {
              types[i$1] = prev;
            } else {
              prev = type;
            }
          }
          for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
            var type$1 = types[i$2];
            if (type$1 == "1" && cur == "r") {
              types[i$2] = "n";
            } else if (isStrong.test(type$1)) {
              cur = type$1;
              if (type$1 == "r") {
                types[i$2] = "R";
              }
            }
          }
          for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
            var type$2 = types[i$3];
            if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
              types[i$3] = "1";
            } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
              types[i$3] = prev$1;
            }
            prev$1 = type$2;
          }
          for (var i$4 = 0; i$4 < len; ++i$4) {
            var type$3 = types[i$4];
            if (type$3 == ",") {
              types[i$4] = "N";
            } else if (type$3 == "%") {
              var end = void 0;
              for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
              var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";
              for (var j = i$4; j < end; ++j) {
                types[j] = replace;
              }
              i$4 = end - 1;
            }
          }
          for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
            var type$4 = types[i$5];
            if (cur$1 == "L" && type$4 == "1") {
              types[i$5] = "L";
            } else if (isStrong.test(type$4)) {
              cur$1 = type$4;
            }
          }
          for (var i$6 = 0; i$6 < len; ++i$6) {
            if (isNeutral.test(types[i$6])) {
              var end$1 = void 0;
              for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
              var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
              var after = (end$1 < len ? types[end$1] : outerType) == "L";
              var replace$1 = before || after ? "L" : "R";
              for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                types[j$1] = replace$1;
              }
              i$6 = end$1 - 1;
            }
          }
          var order = [],
              m;
          for (var i$7 = 0; i$7 < len;) {
            if (countsAsLeft.test(types[i$7])) {
              var start = i$7;
              for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
              order.push(new BidiSpan(0, start, i$7));
            } else {
              var pos = i$7,
                  at = order.length;
              for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
              for (var j$2 = pos; j$2 < i$7;) {
                if (countsAsNum.test(types[j$2])) {
                  if (pos < j$2) {
                    order.splice(at, 0, new BidiSpan(1, pos, j$2));
                  }
                  var nstart = j$2;
                  for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
                  order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                  pos = j$2;
                } else {
                  ++j$2;
                }
              }
              if (pos < i$7) {
                order.splice(at, 0, new BidiSpan(1, pos, i$7));
              }
            }
          }
          if (order[0].level == 1 && (m = str.match(/^\s+/))) {
            order[0].from = m[0].length;
            order.unshift(new BidiSpan(0, 0, m[0].length));
          }
          if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
            lst(order).to -= m[0].length;
            order.push(new BidiSpan(0, len - m[0].length, len));
          }
          if (order[0].level == 2) {
            order.unshift(new BidiSpan(1, order[0].to, order[0].to));
          }
          if (order[0].level != lst(order).level) {
            order.push(new BidiSpan(order[0].level, len, len));
          }
          return order;
        };
      }();
      function getOrder(line) {
        var order = line.order;
        if (order == null) {
          order = line.order = bidiOrdering(line.text);
        }
        return order;
      }
      var noHandlers = [];
      var on = function (emitter, type, f) {
        if (emitter.addEventListener) {
          emitter.addEventListener(type, f, false);
        } else if (emitter.attachEvent) {
          emitter.attachEvent("on" + type, f);
        } else {
          var map = emitter._handlers || (emitter._handlers = {});
          map[type] = (map[type] || noHandlers).concat(f);
        }
      };
      function getHandlers(emitter, type) {
        return emitter._handlers && emitter._handlers[type] || noHandlers;
      }
      function off(emitter, type, f) {
        if (emitter.removeEventListener) {
          emitter.removeEventListener(type, f, false);
        } else if (emitter.detachEvent) {
          emitter.detachEvent("on" + type, f);
        } else {
          var map = emitter._handlers,
              arr = map && map[type];
          if (arr) {
            var index = indexOf(arr, f);
            if (index > -1) {
              map[type] = arr.slice(0, index).concat(arr.slice(index + 1));
            }
          }
        }
      }
      function signal(emitter, type) {
        var handlers = getHandlers(emitter, type);
        if (!handlers.length) {
          return;
        }
        var args = Array.prototype.slice.call(arguments, 2);
        for (var i = 0; i < handlers.length; ++i) {
          handlers[i].apply(null, args);
        }
      }
      function signalDOMEvent(cm, e, override) {
        if (typeof e == "string") {
          e = {
            type: e,
            preventDefault: function () {
              this.defaultPrevented = true;
            }
          };
        }
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
      }
      function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (!arr) {
          return;
        }
        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
        for (var i = 0; i < arr.length; ++i) {
          if (indexOf(set, arr[i]) == -1) {
            set.push(arr[i]);
          }
        }
      }
      function hasHandler(emitter, type) {
        return getHandlers(emitter, type).length > 0;
      }
      function eventMixin(ctor) {
        ctor.prototype.on = function (type, f) {
          on(this, type, f);
        };
        ctor.prototype.off = function (type, f) {
          off(this, type, f);
        };
      }
      function e_preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
      }
      function e_stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else {
          e.cancelBubble = true;
        }
      }
      function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
      }
      function e_stop(e) {
        e_preventDefault(e);
        e_stopPropagation(e);
      }
      function e_target(e) {
        return e.target || e.srcElement;
      }
      function e_button(e) {
        var b = e.which;
        if (b == null) {
          if (e.button & 1) {
            b = 1;
          } else if (e.button & 2) {
            b = 3;
          } else if (e.button & 4) {
            b = 2;
          }
        }
        if (mac && e.ctrlKey && b == 1) {
          b = 3;
        }
        return b;
      }
      var dragAndDrop = function () {
        if (ie && ie_version < 9) {
          return false;
        }
        var div = elt('div');
        return "draggable" in div || "dragDrop" in div;
      }();
      var zwspSupported;
      function zeroWidthElement(measure) {
        if (zwspSupported == null) {
          var test = elt("span", "\u200b");
          removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
          if (measure.firstChild.offsetHeight != 0) {
            zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
          }
        }
        var node = zwspSupported ? elt("span", "\u200b") : elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
        node.setAttribute("cm-text", "");
        return node;
      }
      var badBidiRects;
      function hasBadBidiRects(measure) {
        if (badBidiRects != null) {
          return badBidiRects;
        }
        var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        removeChildren(measure);
        if (!r0 || r0.left == r0.right) {
          return false;
        }
        return badBidiRects = r1.right - r0.right < 3;
      }
      var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
        var pos = 0,
            result = [],
            l = string.length;
        while (pos <= l) {
          var nl = string.indexOf("\n", pos);
          if (nl == -1) {
            nl = string.length;
          }
          var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
          var rt = line.indexOf("\r");
          if (rt != -1) {
            result.push(line.slice(0, rt));
            pos += rt + 1;
          } else {
            result.push(line);
            pos = nl + 1;
          }
        }
        return result;
      } : function (string) {
        return string.split(/\r\n?|\n/);
      };
      var hasSelection = window.getSelection ? function (te) {
        try {
          return te.selectionStart != te.selectionEnd;
        } catch (e) {
          return false;
        }
      } : function (te) {
        var range;
        try {
          range = te.ownerDocument.selection.createRange();
        } catch (e) {}
        if (!range || range.parentElement() != te) {
          return false;
        }
        return range.compareEndPoints("StartToEnd", range) != 0;
      };
      var hasCopyEvent = function () {
        var e = elt("div");
        if ("oncopy" in e) {
          return true;
        }
        e.setAttribute("oncopy", "return;");
        return typeof e.oncopy == "function";
      }();
      var badZoomedRects = null;
      function hasBadZoomedRects(measure) {
        if (badZoomedRects != null) {
          return badZoomedRects;
        }
        var node = removeChildrenAndAdd(measure, elt("span", "x"));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
      }
      var modes = {};
      var mimeModes = {};
      function defineMode(name, mode) {
        if (arguments.length > 2) {
          mode.dependencies = Array.prototype.slice.call(arguments, 2);
        }
        modes[name] = mode;
      }
      function defineMIME(mime, spec) {
        mimeModes[mime] = spec;
      }
      function resolveMode(spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];
          if (typeof found == "string") {
            found = { name: found };
          }
          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return resolveMode("application/xml");
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
          return resolveMode("application/json");
        }
        if (typeof spec == "string") {
          return { name: spec };
        } else {
          return spec || { name: "null" };
        }
      }
      function getMode(options, spec) {
        spec = resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory) {
          return getMode(options, "text/plain");
        }
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];
          for (var prop in exts) {
            if (!exts.hasOwnProperty(prop)) {
              continue;
            }
            if (modeObj.hasOwnProperty(prop)) {
              modeObj["_" + prop] = modeObj[prop];
            }
            modeObj[prop] = exts[prop];
          }
        }
        modeObj.name = spec.name;
        if (spec.helperType) {
          modeObj.helperType = spec.helperType;
        }
        if (spec.modeProps) {
          for (var prop$1 in spec.modeProps) {
            modeObj[prop$1] = spec.modeProps[prop$1];
          }
        }
        return modeObj;
      }
      var modeExtensions = {};
      function extendMode(mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        copyObj(properties, exts);
      }
      function copyState(mode, state) {
        if (state === true) {
          return state;
        }
        if (mode.copyState) {
          return mode.copyState(state);
        }
        var nstate = {};
        for (var n in state) {
          var val = state[n];
          if (val instanceof Array) {
            val = val.concat([]);
          }
          nstate[n] = val;
        }
        return nstate;
      }
      function innerMode(mode, state) {
        var info;
        while (mode.innerMode) {
          info = mode.innerMode(state);
          if (!info || info.mode == mode) {
            break;
          }
          state = info.state;
          mode = info.mode;
        }
        return info || {
          mode: mode,
          state: state
        };
      }
      function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
      }
      var StringStream = function (string, tabSize) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
      };
      StringStream.prototype = {
        eol: function () {
          return this.pos >= this.string.length;
        },
        sol: function () {
          return this.pos == this.lineStart;
        },
        peek: function () {
          return this.string.charAt(this.pos) || undefined;
        },
        next: function () {
          if (this.pos < this.string.length) {
            return this.string.charAt(this.pos++);
          }
        },
        eat: function (match) {
          var ch = this.string.charAt(this.pos);
          var ok;
          if (typeof match == "string") {
            ok = ch == match;
          } else {
            ok = ch && (match.test ? match.test(ch) : match(ch));
          }
          if (ok) {
            ++this.pos;
            return ch;
          }
        },
        eatWhile: function (match) {
          var start = this.pos;
          while (this.eat(match)) {}
          return this.pos > start;
        },
        eatSpace: function () {
          var this$1 = this;
          var start = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
            ++this$1.pos;
          }
          return this.pos > start;
        },
        skipToEnd: function () {
          this.pos = this.string.length;
        },
        skipTo: function (ch) {
          var found = this.string.indexOf(ch, this.pos);
          if (found > -1) {
            this.pos = found;
            return true;
          }
        },
        backUp: function (n) {
          this.pos -= n;
        },
        column: function () {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        indentation: function () {
          return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        match: function (pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            var cased = function (str) {
              return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false) {
                this.pos += pattern.length;
              }
              return true;
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0) {
              return null;
            }
            if (match && consume !== false) {
              this.pos += match[0].length;
            }
            return match;
          }
        },
        current: function () {
          return this.string.slice(this.start, this.pos);
        },
        hideFirstChars: function (n, inner) {
          this.lineStart += n;
          try {
            return inner();
          } finally {
            this.lineStart -= n;
          }
        }
      };
      function highlightLine(cm, line, state, forceToEnd) {
        var st = [cm.state.modeGen],
            lineClasses = {};
        runMode(cm, line.text, cm.doc.mode, state, function (end, style) {
          return st.push(end, style);
        }, lineClasses, forceToEnd);
        var loop = function (o) {
          var overlay = cm.state.overlays[o],
              i = 1,
              at = 0;
          runMode(cm, line.text, overlay.mode, true, function (end, style) {
            var start = i;
            while (at < end) {
              var i_end = st[i];
              if (i_end > end) {
                st.splice(i, 1, end, st[i + 1], i_end);
              }
              i += 2;
              at = Math.min(end, i_end);
            }
            if (!style) {
              return;
            }
            if (overlay.opaque) {
              st.splice(start, i - start, end, "overlay " + style);
              i = start + 2;
            } else {
              for (; start < i; start += 2) {
                var cur = st[start + 1];
                st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
              }
            }
          }, lineClasses);
        };
        for (var o = 0; o < cm.state.overlays.length; ++o) loop(o);
        return {
          styles: st,
          classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        };
      }
      function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
          var state = getStateBefore(cm, lineNo(line));
          var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
          line.stateAfter = state;
          line.styles = result.styles;
          if (result.classes) {
            line.styleClasses = result.classes;
          } else if (line.styleClasses) {
            line.styleClasses = null;
          }
          if (updateFrontier === cm.doc.frontier) {
            cm.doc.frontier++;
          }
        }
        return line.styles;
      }
      function getStateBefore(cm, n, precise) {
        var doc = cm.doc,
            display = cm.display;
        if (!doc.mode.startState) {
          return true;
        }
        var pos = findStartLine(cm, n, precise),
            state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
        if (!state) {
          state = startState(doc.mode);
        } else {
          state = copyState(doc.mode, state);
        }
        doc.iter(pos, n, function (line) {
          processLine(cm, line.text, state);
          var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
          line.stateAfter = save ? copyState(doc.mode, state) : null;
          ++pos;
        });
        if (precise) {
          doc.frontier = pos;
        }
        return state;
      }
      function processLine(cm, text, state, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize);
        stream.start = stream.pos = startAt || 0;
        if (text == "") {
          callBlankLine(mode, state);
        }
        while (!stream.eol()) {
          readToken(mode, stream, state);
          stream.start = stream.pos;
        }
      }
      function callBlankLine(mode, state) {
        if (mode.blankLine) {
          return mode.blankLine(state);
        }
        if (!mode.innerMode) {
          return;
        }
        var inner = innerMode(mode, state);
        if (inner.mode.blankLine) {
          return inner.mode.blankLine(inner.state);
        }
      }
      function readToken(mode, stream, state, inner) {
        for (var i = 0; i < 10; i++) {
          if (inner) {
            inner[0] = innerMode(mode, state).mode;
          }
          var style = mode.token(stream, state);
          if (stream.pos > stream.start) {
            return style;
          }
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.");
      }
      function takeToken(cm, pos, precise, asArray) {
        var getObj = function (copy) {
          return {
            start: stream.start,
            end: stream.pos,
            string: stream.current(),
            type: style || null,
            state: copy ? copyState(doc.mode, state) : state
          };
        };
        var doc = cm.doc,
            mode = doc.mode,
            style;
        pos = clipPos(doc, pos);
        var line = getLine(doc, pos.line),
            state = getStateBefore(cm, pos.line, precise);
        var stream = new StringStream(line.text, cm.options.tabSize),
            tokens;
        if (asArray) {
          tokens = [];
        }
        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
          stream.start = stream.pos;
          style = readToken(mode, stream, state);
          if (asArray) {
            tokens.push(getObj(true));
          }
        }
        return asArray ? tokens : getObj();
      }
      function extractLineClasses(type, output) {
        if (type) {
          for (;;) {
            var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
            if (!lineClass) {
              break;
            }
            type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
            var prop = lineClass[1] ? "bgClass" : "textClass";
            if (output[prop] == null) {
              output[prop] = lineClass[2];
            } else if (!new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)").test(output[prop])) {
              output[prop] += " " + lineClass[2];
            }
          }
        }
        return type;
      }
      function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null) {
          flattenSpans = cm.options.flattenSpans;
        }
        var curStart = 0,
            curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize),
            style;
        var inner = cm.options.addModeClass && [null];
        if (text == "") {
          extractLineClasses(callBlankLine(mode, state), lineClasses);
        }
        while (!stream.eol()) {
          if (stream.pos > cm.options.maxHighlightLength) {
            flattenSpans = false;
            if (forceToEnd) {
              processLine(cm, text, state, stream.pos);
            }
            stream.pos = text.length;
            style = null;
          } else {
            style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
          }
          if (inner) {
            var mName = inner[0].name;
            if (mName) {
              style = "m-" + (style ? mName + " " + style : mName);
            }
          }
          if (!flattenSpans || curStyle != style) {
            while (curStart < stream.start) {
              curStart = Math.min(stream.start, curStart + 5000);
              f(curStart, curStyle);
            }
            curStyle = style;
          }
          stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
          var pos = Math.min(stream.pos, curStart + 5000);
          f(pos, curStyle);
          curStart = pos;
        }
      }
      function findStartLine(cm, n, precise) {
        var minindent,
            minline,
            doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
        for (var search = n; search > lim; --search) {
          if (search <= doc.first) {
            return doc.first;
          }
          var line = getLine(doc, search - 1);
          if (line.stateAfter && (!precise || search <= doc.frontier)) {
            return search;
          }
          var indented = countColumn(line.text, null, cm.options.tabSize);
          if (minline == null || minindent > indented) {
            minline = search - 1;
            minindent = indented;
          }
        }
        return minline;
      }
      function Line(text, markedSpans, estimateHeight) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight ? estimateHeight(this) : 1;
      }
      eventMixin(Line);
      Line.prototype.lineNo = function () {
        return lineNo(this);
      };
      function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        if (line.styles) {
          line.styles = null;
        }
        if (line.order != null) {
          line.order = null;
        }
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        if (estHeight != line.height) {
          updateLineHeight(line, estHeight);
        }
      }
      function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
      }
      var styleToClassCache = {};
      var styleToClassCacheWithMode = {};
      function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style)) {
          return null;
        }
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
      }
      function buildLineContent(cm, lineView) {
        var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
        var builder = {
          pre: elt("pre", [content], "CodeMirror-line"),
          content: content,
          col: 0,
          pos: 0,
          cm: cm,
          trailingSpace: false,
          splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
        };
        lineView.measure = {};
        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
          var line = i ? lineView.rest[i - 1] : lineView.line,
              order = void 0;
          builder.pos = 0;
          builder.addToken = buildToken;
          if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line))) {
            builder.addToken = buildTokenBadBidi(builder.addToken, order);
          }
          builder.map = [];
          var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
          insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
          if (line.styleClasses) {
            if (line.styleClasses.bgClass) {
              builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
            }
            if (line.styleClasses.textClass) {
              builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
            }
          }
          if (builder.map.length == 0) {
            builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
          }
          if (i == 0) {
            lineView.measure.map = builder.map;
            lineView.measure.cache = {};
          } else {
            ;
            (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
            ;
            (lineView.measure.caches || (lineView.measure.caches = [])).push({});
          }
        }
        if (webkit) {
          var last = builder.content.lastChild;
          if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
            builder.content.className = "cm-tab-wrap-hack";
          }
        }
        signal(cm, "renderLine", cm, lineView.line, builder.pre);
        if (builder.pre.className) {
          builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
        }
        return builder;
      }
      function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "\u2022", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        token.setAttribute("aria-label", token.title);
        return token;
      }
      function buildToken(builder, text, style, startStyle, endStyle, title, css) {
        if (!text) {
          return;
        }
        var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
        var special = builder.cm.state.specialChars,
            mustWrap = false;
        var content;
        if (!special.test(text)) {
          builder.col += text.length;
          content = document.createTextNode(displayText);
          builder.map.push(builder.pos, builder.pos + text.length, content);
          if (ie && ie_version < 9) {
            mustWrap = true;
          }
          builder.pos += text.length;
        } else {
          content = document.createDocumentFragment();
          var pos = 0;
          while (true) {
            special.lastIndex = pos;
            var m = special.exec(text);
            var skipped = m ? m.index - pos : text.length - pos;
            if (skipped) {
              var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt]));
              } else {
                content.appendChild(txt);
              }
              builder.map.push(builder.pos, builder.pos + skipped, txt);
              builder.col += skipped;
              builder.pos += skipped;
            }
            if (!m) {
              break;
            }
            pos += skipped + 1;
            var txt$1 = void 0;
            if (m[0] == "\t") {
              var tabSize = builder.cm.options.tabSize,
                  tabWidth = tabSize - builder.col % tabSize;
              txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
              txt$1.setAttribute("role", "presentation");
              txt$1.setAttribute("cm-text", "\t");
              builder.col += tabWidth;
            } else if (m[0] == "\r" || m[0] == "\n") {
              txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
              txt$1.setAttribute("cm-text", m[0]);
              builder.col += 1;
            } else {
              txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
              txt$1.setAttribute("cm-text", m[0]);
              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt$1]));
              } else {
                content.appendChild(txt$1);
              }
              builder.col += 1;
            }
            builder.map.push(builder.pos, builder.pos + 1, txt$1);
            builder.pos++;
          }
        }
        builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
        if (style || startStyle || endStyle || mustWrap || css) {
          var fullStyle = style || "";
          if (startStyle) {
            fullStyle += startStyle;
          }
          if (endStyle) {
            fullStyle += endStyle;
          }
          var token = elt("span", [content], fullStyle, css);
          if (title) {
            token.title = title;
          }
          return builder.content.appendChild(token);
        }
        builder.content.appendChild(content);
      }
      function splitSpaces(text, trailingBefore) {
        if (text.length > 1 && !/  /.test(text)) {
          return text;
        }
        var spaceBefore = trailingBefore,
            result = "";
        for (var i = 0; i < text.length; i++) {
          var ch = text.charAt(i);
          if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {
            ch = "\u00a0";
          }
          result += ch;
          spaceBefore = ch == " ";
        }
        return result;
      }
      function buildTokenBadBidi(inner, order) {
        return function (builder, text, style, startStyle, endStyle, title, css) {
          style = style ? style + " cm-force-border" : "cm-force-border";
          var start = builder.pos,
              end = start + text.length;
          for (;;) {
            var part = void 0;
            for (var i = 0; i < order.length; i++) {
              part = order[i];
              if (part.to > start && part.from <= start) {
                break;
              }
            }
            if (part.to >= end) {
              return inner(builder, text, style, startStyle, endStyle, title, css);
            }
            inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
            startStyle = null;
            text = text.slice(part.to - start);
            start = part.to;
          }
        };
      }
      function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        if (widget) {
          builder.map.push(builder.pos, builder.pos + size, widget);
        }
        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
          if (!widget) {
            widget = builder.content.appendChild(document.createElement("span"));
          }
          widget.setAttribute("cm-marker", marker.id);
        }
        if (widget) {
          builder.cm.display.input.setUneditable(widget);
          builder.content.appendChild(widget);
        }
        builder.pos += size;
        builder.trailingSpace = false;
      }
      function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans,
            allText = line.text,
            at = 0;
        if (!spans) {
          for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {
            builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
          }
          return;
        }
        var len = allText.length,
            pos = 0,
            i = 1,
            text = "",
            style,
            css;
        var nextChange = 0,
            spanStyle,
            spanEndStyle,
            spanStartStyle,
            title,
            collapsed;
        for (;;) {
          if (nextChange == pos) {
            spanStyle = spanEndStyle = spanStartStyle = title = css = "";
            collapsed = null;
            nextChange = Infinity;
            var foundBookmarks = [],
                endStyles = void 0;
            for (var j = 0; j < spans.length; ++j) {
              var sp = spans[j],
                  m = sp.marker;
              if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                foundBookmarks.push(m);
              } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                  nextChange = sp.to;
                  spanEndStyle = "";
                }
                if (m.className) {
                  spanStyle += " " + m.className;
                }
                if (m.css) {
                  css = (css ? css + ";" : "") + m.css;
                }
                if (m.startStyle && sp.from == pos) {
                  spanStartStyle += " " + m.startStyle;
                }
                if (m.endStyle && sp.to == nextChange) {
                  (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
                }
                if (m.title && !title) {
                  title = m.title;
                }
                if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
                  collapsed = sp;
                }
              } else if (sp.from > pos && nextChange > sp.from) {
                nextChange = sp.from;
              }
            }
            if (endStyles) {
              for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                if (endStyles[j$1 + 1] == nextChange) {
                  spanEndStyle += " " + endStyles[j$1];
                }
              }
            }
            if (!collapsed || collapsed.from == pos) {
              for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
              }
            }
            if (collapsed && (collapsed.from || 0) == pos) {
              buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
              if (collapsed.to == null) {
                return;
              }
              if (collapsed.to == pos) {
                collapsed = false;
              }
            }
          }
          if (pos >= len) {
            break;
          }
          var upto = Math.min(len, nextChange);
          while (true) {
            if (text) {
              var end = pos + text.length;
              if (!collapsed) {
                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
              }
              if (end >= upto) {
                text = text.slice(upto - pos);
                pos = upto;
                break;
              }
              pos = end;
              spanStartStyle = "";
            }
            text = allText.slice(at, at = styles[i++]);
            style = interpretTokenStyle(styles[i++], builder.cm.options);
          }
        }
      }
      function LineView(doc, line, lineN) {
        this.line = line;
        this.rest = visualLineContinued(line);
        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc, line);
      }
      function buildViewArray(cm, from, to) {
        var array = [],
            nextPos;
        for (var pos = from; pos < to; pos = nextPos) {
          var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
          nextPos = pos + view.size;
          array.push(view);
        }
        return array;
      }
      var operationGroup = null;
      function pushOperation(op) {
        if (operationGroup) {
          operationGroup.ops.push(op);
        } else {
          op.ownsGroup = operationGroup = {
            ops: [op],
            delayedCallbacks: []
          };
        }
      }
      function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks,
            i = 0;
        do {
          for (; i < callbacks.length; i++) {
            callbacks[i].call(null);
          }
          for (var j = 0; j < group.ops.length; j++) {
            var op = group.ops[j];
            if (op.cursorActivityHandlers) {
              while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
                op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
              }
            }
          }
        } while (i < callbacks.length);
      }
      function finishOperation(op, endCb) {
        var group = op.ownsGroup;
        if (!group) {
          return;
        }
        try {
          fireCallbacksForOps(group);
        } finally {
          operationGroup = null;
          endCb(group);
        }
      }
      var orphanDelayedCallbacks = null;
      function signalLater(emitter, type) {
        var arr = getHandlers(emitter, type);
        if (!arr.length) {
          return;
        }
        var args = Array.prototype.slice.call(arguments, 2),
            list;
        if (operationGroup) {
          list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
          list = orphanDelayedCallbacks;
        } else {
          list = orphanDelayedCallbacks = [];
          setTimeout(fireOrphanDelayed, 0);
        }
        var loop = function (i) {
          list.push(function () {
            return arr[i].apply(null, args);
          });
        };
        for (var i = 0; i < arr.length; ++i) loop(i);
      }
      function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i) {
          delayed[i]();
        }
      }
      function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
          var type = lineView.changes[j];
          if (type == "text") {
            updateLineText(cm, lineView);
          } else if (type == "gutter") {
            updateLineGutter(cm, lineView, lineN, dims);
          } else if (type == "class") {
            updateLineClasses(lineView);
          } else if (type == "widget") {
            updateLineWidgets(cm, lineView, dims);
          }
        }
        lineView.changes = null;
      }
      function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
          lineView.node = elt("div", null, null, "position: relative");
          if (lineView.text.parentNode) {
            lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
          }
          lineView.node.appendChild(lineView.text);
          if (ie && ie_version < 8) {
            lineView.node.style.zIndex = 2;
          }
        }
        return lineView.node;
      }
      function updateLineBackground(lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
        if (cls) {
          cls += " CodeMirror-linebackground";
        }
        if (lineView.background) {
          if (cls) {
            lineView.background.className = cls;
          } else {
            lineView.background.parentNode.removeChild(lineView.background);
            lineView.background = null;
          }
        } else if (cls) {
          var wrap = ensureLineWrapped(lineView);
          lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
        }
      }
      function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        if (ext && ext.line == lineView.line) {
          cm.display.externalMeasured = null;
          lineView.measure = ext.measure;
          return ext.built;
        }
        return buildLineContent(cm, lineView);
      }
      function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);
        if (lineView.text == lineView.node) {
          lineView.node = built.pre;
        }
        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;
        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
          lineView.bgClass = built.bgClass;
          lineView.textClass = built.textClass;
          updateLineClasses(lineView);
        } else if (cls) {
          lineView.text.className = cls;
        }
      }
      function updateLineClasses(lineView) {
        updateLineBackground(lineView);
        if (lineView.line.wrapClass) {
          ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        } else if (lineView.node != lineView.text) {
          lineView.node.className = "";
        }
        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || "";
      }
      function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
          lineView.node.removeChild(lineView.gutter);
          lineView.gutter = null;
        }
        if (lineView.gutterBackground) {
          lineView.node.removeChild(lineView.gutterBackground);
          lineView.gutterBackground = null;
        }
        if (lineView.line.gutterClass) {
          var wrap = ensureLineWrapped(lineView);
          lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
          wrap.insertBefore(lineView.gutterBackground, lineView.text);
        }
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
          var wrap$1 = ensureLineWrapped(lineView);
          var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
          cm.display.input.setUneditable(gutterWrap);
          wrap$1.insertBefore(gutterWrap, lineView.text);
          if (lineView.line.gutterClass) {
            gutterWrap.className += " " + lineView.line.gutterClass;
          }
          if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
            lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
          }
          if (markers) {
            for (var k = 0; k < cm.options.gutters.length; ++k) {
              var id = cm.options.gutters[k],
                  found = markers.hasOwnProperty(id) && markers[id];
              if (found) {
                gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
              }
            }
          }
        }
      }
      function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable) {
          lineView.alignable = null;
        }
        for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
          next = node.nextSibling;
          if (node.className == "CodeMirror-linewidget") {
            lineView.node.removeChild(node);
          }
        }
        insertLineWidgets(cm, lineView, dims);
      }
      function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;
        if (built.bgClass) {
          lineView.bgClass = built.bgClass;
        }
        if (built.textClass) {
          lineView.textClass = built.textClass;
        }
        updateLineClasses(lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node;
      }
      function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
        if (lineView.rest) {
          for (var i = 0; i < lineView.rest.length; i++) {
            insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
          }
        }
      }
      function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets) {
          return;
        }
        var wrap = ensureLineWrapped(lineView);
        for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
          var widget = ws[i],
              node = elt("div", [widget.node], "CodeMirror-linewidget");
          if (!widget.handleMouseEvents) {
            node.setAttribute("cm-ignore-events", "true");
          }
          positionLineWidget(widget, node, lineView, dims);
          cm.display.input.setUneditable(node);
          if (allowAbove && widget.above) {
            wrap.insertBefore(node, lineView.gutter || lineView.text);
          } else {
            wrap.appendChild(node);
          }
          signalLater(widget, "redraw");
        }
      }
      function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
          ;
          (lineView.alignable || (lineView.alignable = [])).push(node);
          var width = dims.wrapperWidth;
          node.style.left = dims.fixedPos + "px";
          if (!widget.coverGutter) {
            width -= dims.gutterTotalWidth;
            node.style.paddingLeft = dims.gutterTotalWidth + "px";
          }
          node.style.width = width + "px";
        }
        if (widget.coverGutter) {
          node.style.zIndex = 5;
          node.style.position = "relative";
          if (!widget.noHScroll) {
            node.style.marginLeft = -dims.gutterTotalWidth + "px";
          }
        }
      }
      function widgetHeight(widget) {
        if (widget.height != null) {
          return widget.height;
        }
        var cm = widget.doc.cm;
        if (!cm) {
          return 0;
        }
        if (!contains(document.body, widget.node)) {
          var parentStyle = "position: relative;";
          if (widget.coverGutter) {
            parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
          }
          if (widget.noHScroll) {
            parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
          }
          removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
        }
        return widget.height = widget.node.parentNode.offsetHeight;
      }
      function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
          if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
            return true;
          }
        }
      }
      function paddingTop(display) {
        return display.lineSpace.offsetTop;
      }
      function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
      }
      function paddingH(display) {
        if (display.cachedPaddingH) {
          return display.cachedPaddingH;
        }
        var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        var data = {
          left: parseInt(style.paddingLeft),
          right: parseInt(style.paddingRight)
        };
        if (!isNaN(data.left) && !isNaN(data.right)) {
          display.cachedPaddingH = data;
        }
        return data;
      }
      function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
      }
      function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
      }
      function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
      }
      function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
          var heights = lineView.measure.heights = [];
          if (wrapping) {
            lineView.measure.width = curWidth;
            var rects = lineView.text.firstChild.getClientRects();
            for (var i = 0; i < rects.length - 1; i++) {
              var cur = rects[i],
                  next = rects[i + 1];
              if (Math.abs(cur.bottom - next.bottom) > 2) {
                heights.push((cur.bottom + next.top) / 2 - rect.top);
              }
            }
          }
          heights.push(rect.bottom - rect.top);
        }
      }
      function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line) {
          return {
            map: lineView.measure.map,
            cache: lineView.measure.cache
          };
        }
        for (var i = 0; i < lineView.rest.length; i++) {
          if (lineView.rest[i] == line) {
            return {
              map: lineView.measure.maps[i],
              cache: lineView.measure.caches[i]
            };
          }
        }
        for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
          if (lineNo(lineView.rest[i$1]) > lineN) {
            return {
              map: lineView.measure.maps[i$1],
              cache: lineView.measure.caches[i$1],
              before: true
            };
          }
        }
      }
      function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
      }
      function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
      }
      function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
          return cm.display.view[findViewIndex(cm, lineN)];
        }
        var ext = cm.display.externalMeasured;
        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
          return ext;
        }
      }
      function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);
        if (view && !view.text) {
          view = null;
        } else if (view && view.changes) {
          updateLineForChanges(cm, view, lineN, getDimensions(cm));
          cm.curOp.forceUpdate = true;
        }
        if (!view) {
          view = updateExternalMeasurement(cm, line);
        }
        var info = mapFromLineView(view, line, lineN);
        return {
          line: line,
          view: view,
          rect: null,
          map: info.map,
          cache: info.cache,
          before: info.before,
          hasHeights: false
        };
      }
      function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before) {
          ch = -1;
        }
        var key = ch + (bias || ""),
            found;
        if (prepared.cache.hasOwnProperty(key)) {
          found = prepared.cache[key];
        } else {
          if (!prepared.rect) {
            prepared.rect = prepared.view.text.getBoundingClientRect();
          }
          if (!prepared.hasHeights) {
            ensureLineHeights(cm, prepared.view, prepared.rect);
            prepared.hasHeights = true;
          }
          found = measureCharInner(cm, prepared, ch, bias);
          if (!found.bogus) {
            prepared.cache[key] = found;
          }
        }
        return {
          left: found.left,
          right: found.right,
          top: varHeight ? found.rtop : found.top,
          bottom: varHeight ? found.rbottom : found.bottom
        };
      }
      var nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      function nodeAndOffsetInLineMap(map, ch, bias) {
        var node, start, end, collapse, mStart, mEnd;
        for (var i = 0; i < map.length; i += 3) {
          mStart = map[i];
          mEnd = map[i + 1];
          if (ch < mStart) {
            start = 0;
            end = 1;
            collapse = "left";
          } else if (ch < mEnd) {
            start = ch - mStart;
            end = start + 1;
          } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
            end = mEnd - mStart;
            start = end - 1;
            if (ch >= mEnd) {
              collapse = "right";
            }
          }
          if (start != null) {
            node = map[i + 2];
            if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
              collapse = bias;
            }
            if (bias == "left" && start == 0) {
              while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
                node = map[(i -= 3) + 2];
                collapse = "left";
              }
            }
            if (bias == "right" && start == mEnd - mStart) {
              while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
                node = map[(i += 3) + 2];
                collapse = "right";
              }
            }
            break;
          }
        }
        return {
          node: node,
          start: start,
          end: end,
          collapse: collapse,
          coverStart: mStart,
          coverEnd: mEnd
        };
      }
      function getUsefulRect(rects, bias) {
        var rect = nullRect;
        if (bias == "left") {
          for (var i = 0; i < rects.length; i++) {
            if ((rect = rects[i]).left != rect.right) {
              break;
            }
          }
        } else {
          for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
            if ((rect = rects[i$1]).left != rect.right) {
              break;
            }
          }
        }
        return rect;
      }
      function measureCharInner(cm, prepared, ch, bias) {
        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        var node = place.node,
            start = place.start,
            end = place.end,
            collapse = place.collapse;
        var rect;
        if (node.nodeType == 3) {
          for (var i$1 = 0; i$1 < 4; i$1++) {
            while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
              --start;
            }
            while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
              ++end;
            }
            if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
              rect = node.parentNode.getBoundingClientRect();
            } else {
              rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
            }
            if (rect.left || rect.right || start == 0) {
              break;
            }
            end = start;
            start = start - 1;
            collapse = "right";
          }
          if (ie && ie_version < 11) {
            rect = maybeUpdateRectForZooming(cm.display.measure, rect);
          }
        } else {
          if (start > 0) {
            collapse = bias = "right";
          }
          var rects;
          if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          } else {
            rect = node.getBoundingClientRect();
          }
        }
        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
          var rSpan = node.parentNode.getClientRects()[0];
          if (rSpan) {
            rect = {
              left: rSpan.left,
              right: rSpan.left + charWidth(cm.display),
              top: rSpan.top,
              bottom: rSpan.bottom
            };
          } else {
            rect = nullRect;
          }
        }
        var rtop = rect.top - prepared.rect.top,
            rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        var i = 0;
        for (; i < heights.length - 1; i++) {
          if (mid < heights[i]) {
            break;
          }
        }
        var top = i ? heights[i - 1] : 0,
            bot = heights[i];
        var result = {
          left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
          right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
          top: top,
          bottom: bot
        };
        if (!rect.left && !rect.right) {
          result.bogus = true;
        }
        if (!cm.options.singleCursorHeightPerLine) {
          result.rtop = rtop;
          result.rbottom = rbot;
        }
        return result;
      }
      function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
          return rect;
        }
        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
          left: rect.left * scaleX,
          right: rect.right * scaleX,
          top: rect.top * scaleY,
          bottom: rect.bottom * scaleY
        };
      }
      function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
          lineView.measure.cache = {};
          lineView.measure.heights = null;
          if (lineView.rest) {
            for (var i = 0; i < lineView.rest.length; i++) {
              lineView.measure.caches[i] = {};
            }
          }
        }
      }
      function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren(cm.display.lineMeasure);
        for (var i = 0; i < cm.display.view.length; i++) {
          clearLineMeasurementCacheFor(cm.display.view[i]);
        }
      }
      function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
        if (!cm.options.lineWrapping) {
          cm.display.maxLineChanged = true;
        }
        cm.display.lineNumChars = null;
      }
      function pageScrollX() {
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      }
      function pageScrollY() {
        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
      }
      function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
        if (!includeWidgets && lineObj.widgets) {
          for (var i = 0; i < lineObj.widgets.length; ++i) {
            if (lineObj.widgets[i].above) {
              var size = widgetHeight(lineObj.widgets[i]);
              rect.top += size;
              rect.bottom += size;
            }
          }
        }
        if (context == "line") {
          return rect;
        }
        if (!context) {
          context = "local";
        }
        var yOff = heightAtLine(lineObj);
        if (context == "local") {
          yOff += paddingTop(cm.display);
        } else {
          yOff -= cm.display.viewOffset;
        }
        if (context == "page" || context == "window") {
          var lOff = cm.display.lineSpace.getBoundingClientRect();
          yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
          var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
          rect.left += xOff;
          rect.right += xOff;
        }
        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
      }
      function fromCoordSystem(cm, coords, context) {
        if (context == "div") {
          return coords;
        }
        var left = coords.left,
            top = coords.top;
        if (context == "page") {
          left -= pageScrollX();
          top -= pageScrollY();
        } else if (context == "local" || !context) {
          var localBox = cm.display.sizer.getBoundingClientRect();
          left += localBox.left;
          top += localBox.top;
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {
          left: left - lineSpaceBox.left,
          top: top - lineSpaceBox.top
        };
      }
      function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj) {
          lineObj = getLine(cm.doc, pos.line);
        }
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
      }
      function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine(cm.doc, pos.line);
        if (!preparedMeasure) {
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }
        function get(ch, right) {
          var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
          if (right) {
            m.left = m.right;
          } else {
            m.right = m.left;
          }
          return intoCoordSystem(cm, lineObj, m, context);
        }
        function getBidi(ch, partPos) {
          var part = order[partPos],
              right = part.level % 2;
          if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
            part = order[--partPos];
            ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
            right = true;
          } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
            part = order[++partPos];
            ch = bidiLeft(part) - part.level % 2;
            right = false;
          }
          if (right && ch == part.to && ch > part.from) {
            return get(ch - 1);
          }
          return get(ch, right);
        }
        var order = getOrder(lineObj),
            ch = pos.ch;
        if (!order) {
          return get(ch);
        }
        var partPos = getBidiPartAt(order, ch);
        var val = getBidi(ch, partPos);
        if (bidiOther != null) {
          val.other = getBidi(ch, bidiOther);
        }
        return val;
      }
      function estimateCoords(cm, pos) {
        var left = 0;
        pos = clipPos(cm.doc, pos);
        if (!cm.options.lineWrapping) {
          left = charWidth(cm.display) * pos.ch;
        }
        var lineObj = getLine(cm.doc, pos.line);
        var top = heightAtLine(lineObj) + paddingTop(cm.display);
        return {
          left: left,
          right: left,
          top: top,
          bottom: top + lineObj.height
        };
      }
      function PosWithInfo(line, ch, outside, xRel) {
        var pos = Pos(line, ch);
        pos.xRel = xRel;
        if (outside) {
          pos.outside = true;
        }
        return pos;
      }
      function coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0) {
          return PosWithInfo(doc.first, 0, true, -1);
        }
        var lineN = lineAtHeight(doc, y),
            last = doc.first + doc.size - 1;
        if (lineN > last) {
          return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
        }
        if (x < 0) {
          x = 0;
        }
        var lineObj = getLine(doc, lineN);
        for (;;) {
          var found = coordsCharInner(cm, lineObj, lineN, x, y);
          var merged = collapsedSpanAtEnd(lineObj);
          var mergedPos = merged && merged.find(0, true);
          if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) {
            lineN = lineNo(lineObj = mergedPos.to.line);
          } else {
            return found;
          }
        }
      }
      function coordsCharInner(cm, lineObj, lineNo, x, y) {
        var innerOff = y - heightAtLine(lineObj);
        var wrongLine = false,
            adjust = 2 * cm.display.wrapper.clientWidth;
        var preparedMeasure = prepareMeasureForLine(cm, lineObj);
        function getX(ch) {
          var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
          wrongLine = true;
          if (innerOff > sp.bottom) {
            return sp.left - adjust;
          } else if (innerOff < sp.top) {
            return sp.left + adjust;
          } else {
            wrongLine = false;
          }
          return sp.left;
        }
        var bidi = getOrder(lineObj),
            dist = lineObj.text.length;
        var from = lineLeft(lineObj),
            to = lineRight(lineObj);
        var fromX = getX(from),
            fromOutside = wrongLine,
            toX = getX(to),
            toOutside = wrongLine;
        if (x > toX) {
          return PosWithInfo(lineNo, to, toOutside, 1);
        }
        for (;;) {
          if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
            var ch = x < fromX || x - fromX <= toX - x ? from : to;
            var outside = ch == from ? fromOutside : toOutside;
            var xDiff = x - (ch == from ? fromX : toX);
            if (toOutside && !bidi && !/\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 && ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {
              var charSize = measureCharPrepared(cm, preparedMeasure, ch, "right");
              if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {
                outside = false;
                ch++;
                xDiff = x - charSize.right;
              }
            }
            while (isExtendingChar(lineObj.text.charAt(ch))) {
              ++ch;
            }
            var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
            return pos;
          }
          var step = Math.ceil(dist / 2),
              middle = from + step;
          if (bidi) {
            middle = from;
            for (var i = 0; i < step; ++i) {
              middle = moveVisually(lineObj, middle, 1);
            }
          }
          var middleX = getX(middle);
          if (middleX > x) {
            to = middle;
            toX = middleX;
            if (toOutside = wrongLine) {
              toX += 1000;
            }
            dist = step;
          } else {
            from = middle;
            fromX = middleX;
            fromOutside = wrongLine;
            dist -= step;
          }
        }
      }
      var measureText;
      function textHeight(display) {
        if (display.cachedTextHeight != null) {
          return display.cachedTextHeight;
        }
        if (measureText == null) {
          measureText = elt("pre");
          for (var i = 0; i < 49; ++i) {
            measureText.appendChild(document.createTextNode("x"));
            measureText.appendChild(elt("br"));
          }
          measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3) {
          display.cachedTextHeight = height;
        }
        removeChildren(display.measure);
        return height || 1;
      }
      function charWidth(display) {
        if (display.cachedCharWidth != null) {
          return display.cachedCharWidth;
        }
        var anchor = elt("span", "xxxxxxxxxx");
        var pre = elt("pre", [anchor]);
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(),
            width = (rect.right - rect.left) / 10;
        if (width > 2) {
          display.cachedCharWidth = width;
        }
        return width || 10;
      }
      function getDimensions(cm) {
        var d = cm.display,
            left = {},
            width = {};
        var gutterLeft = d.gutters.clientLeft;
        for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
          left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
          width[cm.options.gutters[i]] = n.clientWidth;
        }
        return {
          fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth
        };
      }
      function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
      }
      function estimateHeight(cm) {
        var th = textHeight(cm.display),
            wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function (line) {
          if (lineIsHidden(cm.doc, line)) {
            return 0;
          }
          var widgetsHeight = 0;
          if (line.widgets) {
            for (var i = 0; i < line.widgets.length; i++) {
              if (line.widgets[i].height) {
                widgetsHeight += line.widgets[i].height;
              }
            }
          }
          if (wrapping) {
            return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
          } else {
            return widgetsHeight + th;
          }
        };
      }
      function estimateLineHeights(cm) {
        var doc = cm.doc,
            est = estimateHeight(cm);
        doc.iter(function (line) {
          var estHeight = est(line);
          if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
          }
        });
      }
      function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
          return null;
        }
        var x,
            y,
            space = display.lineSpace.getBoundingClientRect();
        try {
          x = e.clientX - space.left;
          y = e.clientY - space.top;
        } catch (e) {
          return null;
        }
        var coords = coordsChar(cm, x, y),
            line;
        if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
          var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
          coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords;
      }
      function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo) {
          return null;
        }
        n -= cm.display.viewFrom;
        if (n < 0) {
          return null;
        }
        var view = cm.display.view;
        for (var i = 0; i < view.length; i++) {
          n -= view[i].size;
          if (n < 0) {
            return i;
          }
        }
      }
      function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
      }
      function prepareSelection(cm, primary) {
        var doc = cm.doc,
            result = {};
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();
        for (var i = 0; i < doc.sel.ranges.length; i++) {
          if (primary === false && i == doc.sel.primIndex) {
            continue;
          }
          var range = doc.sel.ranges[i];
          if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) {
            continue;
          }
          var collapsed = range.empty();
          if (collapsed || cm.options.showCursorWhenSelecting) {
            drawSelectionCursor(cm, range.head, curFragment);
          }
          if (!collapsed) {
            drawSelectionRange(cm, range, selFragment);
          }
        }
        return result;
      }
      function drawSelectionCursor(cm, head, output) {
        var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
        var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
        cursor.style.left = pos.left + "px";
        cursor.style.top = pos.top + "px";
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
        if (pos.other) {
          var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
          otherCursor.style.display = "";
          otherCursor.style.left = pos.other.left + "px";
          otherCursor.style.top = pos.other.top + "px";
          otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
        }
      }
      function drawSelectionRange(cm, range, output) {
        var display = cm.display,
            doc = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display),
            leftSide = padding.left;
        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        function add(left, top, width, bottom) {
          if (top < 0) {
            top = 0;
          }
          top = Math.round(top);
          bottom = Math.round(bottom);
          fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
        }
        function drawForLine(line, fromArg, toArg) {
          var lineObj = getLine(doc, line);
          var lineLen = lineObj.text.length;
          var start, end;
          function coords(ch, bias) {
            return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
          }
          iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
            var leftPos = coords(from, "left"),
                rightPos,
                left,
                right;
            if (from == to) {
              rightPos = leftPos;
              left = right = leftPos.left;
            } else {
              rightPos = coords(to - 1, "right");
              if (dir == "rtl") {
                var tmp = leftPos;
                leftPos = rightPos;
                rightPos = tmp;
              }
              left = leftPos.left;
              right = rightPos.right;
            }
            if (fromArg == null && from == 0) {
              left = leftSide;
            }
            if (rightPos.top - leftPos.top > 3) {
              add(left, leftPos.top, null, leftPos.bottom);
              left = leftSide;
              if (leftPos.bottom < rightPos.top) {
                add(left, leftPos.bottom, null, rightPos.top);
              }
            }
            if (toArg == null && to == lineLen) {
              right = rightSide;
            }
            if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left) {
              start = leftPos;
            }
            if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right) {
              end = rightPos;
            }
            if (left < leftSide + 1) {
              left = leftSide;
            }
            add(left, rightPos.top, right - left, rightPos.bottom);
          });
          return {
            start: start,
            end: end
          };
        }
        var sFrom = range.from(),
            sTo = range.to();
        if (sFrom.line == sTo.line) {
          drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
          var fromLine = getLine(doc, sFrom.line),
              toLine = getLine(doc, sTo.line);
          var singleVLine = visualLine(fromLine) == visualLine(toLine);
          var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
          var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
          if (singleVLine) {
            if (leftEnd.top < rightStart.top - 2) {
              add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
              add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
            } else {
              add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
            }
          }
          if (leftEnd.bottom < rightStart.top) {
            add(leftSide, leftEnd.bottom, null, rightStart.top);
          }
        }
        output.appendChild(fragment);
      }
      function restartBlink(cm) {
        if (!cm.state.focused) {
          return;
        }
        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursorDiv.style.visibility = "";
        if (cm.options.cursorBlinkRate > 0) {
          display.blinker = setInterval(function () {
            return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
          }, cm.options.cursorBlinkRate);
        } else if (cm.options.cursorBlinkRate < 0) {
          display.cursorDiv.style.visibility = "hidden";
        }
      }
      function ensureFocus(cm) {
        if (!cm.state.focused) {
          cm.display.input.focus();
          onFocus(cm);
        }
      }
      function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(function () {
          if (cm.state.delayingBlurEvent) {
            cm.state.delayingBlurEvent = false;
            onBlur(cm);
          }
        }, 100);
      }
      function onFocus(cm, e) {
        if (cm.state.delayingBlurEvent) {
          cm.state.delayingBlurEvent = false;
        }
        if (cm.options.readOnly == "nocursor") {
          return;
        }
        if (!cm.state.focused) {
          signal(cm, "focus", cm, e);
          cm.state.focused = true;
          addClass(cm.display.wrapper, "CodeMirror-focused");
          if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
            cm.display.input.reset();
            if (webkit) {
              setTimeout(function () {
                return cm.display.input.reset(true);
              }, 20);
            }
          }
          cm.display.input.receivedFocus();
        }
        restartBlink(cm);
      }
      function onBlur(cm, e) {
        if (cm.state.delayingBlurEvent) {
          return;
        }
        if (cm.state.focused) {
          signal(cm, "blur", cm, e);
          cm.state.focused = false;
          rmClass(cm.display.wrapper, "CodeMirror-focused");
        }
        clearInterval(cm.display.blinker);
        setTimeout(function () {
          if (!cm.state.focused) {
            cm.display.shift = false;
          }
        }, 150);
      }
      function alignHorizontally(cm) {
        var display = cm.display,
            view = display.view;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
          return;
        }
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth,
            left = comp + "px";
        for (var i = 0; i < view.length; i++) {
          if (!view[i].hidden) {
            if (cm.options.fixedGutter) {
              if (view[i].gutter) {
                view[i].gutter.style.left = left;
              }
              if (view[i].gutterBackground) {
                view[i].gutterBackground.style.left = left;
              }
            }
            var align = view[i].alignable;
            if (align) {
              for (var j = 0; j < align.length; j++) {
                align[j].style.left = left;
              }
            }
          }
        }
        if (cm.options.fixedGutter) {
          display.gutters.style.left = comp + gutterW + "px";
        }
      }
      function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers) {
          return false;
        }
        var doc = cm.doc,
            last = lineNumberFor(cm.options, doc.first + doc.size - 1),
            display = cm.display;
        if (last.length != display.lineNumChars) {
          var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
          var innerW = test.firstChild.offsetWidth,
              padding = test.offsetWidth - innerW;
          display.lineGutter.style.width = "";
          display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
          display.lineNumWidth = display.lineNumInnerWidth + padding;
          display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
          display.lineGutter.style.width = display.lineNumWidth + "px";
          updateGutterSpace(cm);
          return true;
        }
        return false;
      }
      function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        for (var i = 0; i < display.view.length; i++) {
          var cur = display.view[i],
              height = void 0;
          if (cur.hidden) {
            continue;
          }
          if (ie && ie_version < 8) {
            var bot = cur.node.offsetTop + cur.node.offsetHeight;
            height = bot - prevBottom;
            prevBottom = bot;
          } else {
            var box = cur.node.getBoundingClientRect();
            height = box.bottom - box.top;
          }
          var diff = cur.line.height - height;
          if (height < 2) {
            height = textHeight(display);
          }
          if (diff > .001 || diff < -.001) {
            updateLineHeight(cur.line, height);
            updateWidgetHeight(cur.line);
            if (cur.rest) {
              for (var j = 0; j < cur.rest.length; j++) {
                updateWidgetHeight(cur.rest[j]);
              }
            }
          }
        }
      }
      function updateWidgetHeight(line) {
        if (line.widgets) {
          for (var i = 0; i < line.widgets.length; ++i) {
            line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
          }
        }
      }
      function visibleLines(display, doc, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
        var from = lineAtHeight(doc, top),
            to = lineAtHeight(doc, bottom);
        if (viewport && viewport.ensure) {
          var ensureFrom = viewport.ensure.from.line,
              ensureTo = viewport.ensure.to.line;
          if (ensureFrom < from) {
            from = ensureFrom;
            to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
          } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
            from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
            to = ensureTo;
          }
        }
        return {
          from: from,
          to: Math.max(to, from + 1)
        };
      }
      function setScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2) {
          return;
        }
        cm.doc.scrollTop = val;
        if (!gecko) {
          updateDisplaySimple(cm, { top: val });
        }
        if (cm.display.scroller.scrollTop != val) {
          cm.display.scroller.scrollTop = val;
        }
        cm.display.scrollbars.setScrollTop(val);
        if (gecko) {
          updateDisplaySimple(cm);
        }
        startWorker(cm, 100);
      }
      function setScrollLeft(cm, val, isScroller) {
        if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) {
          return;
        }
        val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val) {
          cm.display.scroller.scrollLeft = val;
        }
        cm.display.scrollbars.setScrollLeft(val);
      }
      var wheelSamples = 0;
      var wheelPixelsPerUnit = null;
      if (ie) {
        wheelPixelsPerUnit = -.53;
      } else if (gecko) {
        wheelPixelsPerUnit = 15;
      } else if (chrome) {
        wheelPixelsPerUnit = -.7;
      } else if (safari) {
        wheelPixelsPerUnit = -1 / 3;
      }
      function wheelEventDelta(e) {
        var dx = e.wheelDeltaX,
            dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
          dx = e.detail;
        }
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
          dy = e.detail;
        } else if (dy == null) {
          dy = e.wheelDelta;
        }
        return {
          x: dx,
          y: dy
        };
      }
      function wheelEventPixels(e) {
        var delta = wheelEventDelta(e);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta;
      }
      function onScrollWheel(cm, e) {
        var delta = wheelEventDelta(e),
            dx = delta.x,
            dy = delta.y;
        var display = cm.display,
            scroll = display.scroller;
        var canScrollX = scroll.scrollWidth > scroll.clientWidth;
        var canScrollY = scroll.scrollHeight > scroll.clientHeight;
        if (!(dx && canScrollX || dy && canScrollY)) {
          return;
        }
        if (dy && mac && webkit) {
          outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i = 0; i < view.length; i++) {
              if (view[i].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
        }
        if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
          if (dy && canScrollY) {
            setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
          }
          setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
          if (!dy || dy && canScrollY) {
            e_preventDefault(e);
          }
          display.wheelStartX = null;
          return;
        }
        if (dy && wheelPixelsPerUnit != null) {
          var pixels = dy * wheelPixelsPerUnit;
          var top = cm.doc.scrollTop,
              bot = top + display.wrapper.clientHeight;
          if (pixels < 0) {
            top = Math.max(0, top + pixels - 50);
          } else {
            bot = Math.min(cm.doc.height, bot + pixels + 50);
          }
          updateDisplaySimple(cm, {
            top: top,
            bottom: bot
          });
        }
        if (wheelSamples < 20) {
          if (display.wheelStartX == null) {
            display.wheelStartX = scroll.scrollLeft;
            display.wheelStartY = scroll.scrollTop;
            display.wheelDX = dx;
            display.wheelDY = dy;
            setTimeout(function () {
              if (display.wheelStartX == null) {
                return;
              }
              var movedX = scroll.scrollLeft - display.wheelStartX;
              var movedY = scroll.scrollTop - display.wheelStartY;
              var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
              display.wheelStartX = display.wheelStartY = null;
              if (!sample) {
                return;
              }
              wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
              ++wheelSamples;
            }, 200);
          } else {
            display.wheelDX += dx;
            display.wheelDY += dy;
          }
        }
      }
      function measureForScrollbars(cm) {
        var d = cm.display,
            gutterW = d.gutters.offsetWidth;
        var docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
          clientHeight: d.scroller.clientHeight,
          viewHeight: d.wrapper.clientHeight,
          scrollWidth: d.scroller.scrollWidth,
          clientWidth: d.scroller.clientWidth,
          viewWidth: d.wrapper.clientWidth,
          barLeft: cm.options.fixedGutter ? gutterW : 0,
          docHeight: docH,
          scrollHeight: docH + scrollGap(cm) + d.barHeight,
          nativeBarWidth: d.nativeBarWidth,
          gutterWidth: gutterW
        };
      }
      function NativeScrollbars(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
        var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        place(vert);
        place(horiz);
        on(vert, "scroll", function () {
          if (vert.clientHeight) {
            scroll(vert.scrollTop, "vertical");
          }
        });
        on(horiz, "scroll", function () {
          if (horiz.clientWidth) {
            scroll(horiz.scrollLeft, "horizontal");
          }
        });
        this.checkedZeroWidth = false;
        if (ie && ie_version < 8) {
          this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
        }
      }
      NativeScrollbars.prototype = copyObj({
        update: function (measure) {
          var needsH = measure.scrollWidth > measure.clientWidth + 1;
          var needsV = measure.scrollHeight > measure.clientHeight + 1;
          var sWidth = measure.nativeBarWidth;
          if (needsV) {
            this.vert.style.display = "block";
            this.vert.style.bottom = needsH ? sWidth + "px" : "0";
            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
          } else {
            this.vert.style.display = "";
            this.vert.firstChild.style.height = "0";
          }
          if (needsH) {
            this.horiz.style.display = "block";
            this.horiz.style.right = needsV ? sWidth + "px" : "0";
            this.horiz.style.left = measure.barLeft + "px";
            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
            this.horiz.firstChild.style.width = measure.scrollWidth - measure.clientWidth + totalWidth + "px";
          } else {
            this.horiz.style.display = "";
            this.horiz.firstChild.style.width = "0";
          }
          if (!this.checkedZeroWidth && measure.clientHeight > 0) {
            if (sWidth == 0) {
              this.zeroWidthHack();
            }
            this.checkedZeroWidth = true;
          }
          return {
            right: needsV ? sWidth : 0,
            bottom: needsH ? sWidth : 0
          };
        },
        setScrollLeft: function (pos) {
          if (this.horiz.scrollLeft != pos) {
            this.horiz.scrollLeft = pos;
          }
          if (this.disableHoriz) {
            this.enableZeroWidthBar(this.horiz, this.disableHoriz);
          }
        },
        setScrollTop: function (pos) {
          if (this.vert.scrollTop != pos) {
            this.vert.scrollTop = pos;
          }
          if (this.disableVert) {
            this.enableZeroWidthBar(this.vert, this.disableVert);
          }
        },
        zeroWidthHack: function () {
          var w = mac && !mac_geMountainLion ? "12px" : "18px";
          this.horiz.style.height = this.vert.style.width = w;
          this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
          this.disableHoriz = new Delayed();
          this.disableVert = new Delayed();
        },
        enableZeroWidthBar: function (bar, delay) {
          bar.style.pointerEvents = "auto";
          function maybeDisable() {
            var box = bar.getBoundingClientRect();
            var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);
            if (elt != bar) {
              bar.style.pointerEvents = "none";
            } else {
              delay.set(1000, maybeDisable);
            }
          }
          delay.set(1000, maybeDisable);
        },
        clear: function () {
          var parent = this.horiz.parentNode;
          parent.removeChild(this.horiz);
          parent.removeChild(this.vert);
        }
      }, NativeScrollbars.prototype);
      function NullScrollbars() {}
      NullScrollbars.prototype = copyObj({
        update: function () {
          return {
            bottom: 0,
            right: 0
          };
        },
        setScrollLeft: function () {},
        setScrollTop: function () {},
        clear: function () {}
      }, NullScrollbars.prototype);
      function updateScrollbars(cm, measure) {
        if (!measure) {
          measure = measureForScrollbars(cm);
        }
        var startWidth = cm.display.barWidth,
            startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
          if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
            updateHeightsInViewport(cm);
          }
          updateScrollbarsInner(cm, measureForScrollbars(cm));
          startWidth = cm.display.barWidth;
          startHeight = cm.display.barHeight;
        }
      }
      function updateScrollbarsInner(cm, measure) {
        var d = cm.display;
        var sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
        d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
        if (sizes.right && sizes.bottom) {
          d.scrollbarFiller.style.display = "block";
          d.scrollbarFiller.style.height = sizes.bottom + "px";
          d.scrollbarFiller.style.width = sizes.right + "px";
        } else {
          d.scrollbarFiller.style.display = "";
        }
        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
          d.gutterFiller.style.display = "block";
          d.gutterFiller.style.height = sizes.bottom + "px";
          d.gutterFiller.style.width = measure.gutterWidth + "px";
        } else {
          d.gutterFiller.style.display = "";
        }
      }
      var scrollbarModel = {
        "native": NativeScrollbars,
        "null": NullScrollbars
      };
      function initScrollbars(cm) {
        if (cm.display.scrollbars) {
          cm.display.scrollbars.clear();
          if (cm.display.scrollbars.addClass) {
            rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
          }
        }
        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
          cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
          on(node, "mousedown", function () {
            if (cm.state.focused) {
              setTimeout(function () {
                return cm.display.input.focus();
              }, 0);
            }
          });
          node.setAttribute("cm-not-content", "true");
        }, function (pos, axis) {
          if (axis == "horizontal") {
            setScrollLeft(cm, pos);
          } else {
            setScrollTop(cm, pos);
          }
        }, cm);
        if (cm.display.scrollbars.addClass) {
          addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
      }
      function maybeScrollWindow(cm, coords) {
        if (signalDOMEvent(cm, "scrollCursorIntoView")) {
          return;
        }
        var display = cm.display,
            box = display.sizer.getBoundingClientRect(),
            doScroll = null;
        if (coords.top + box.top < 0) {
          doScroll = true;
        } else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
          doScroll = false;
        }
        if (doScroll != null && !phantom) {
          var scrollNode = elt("div", "\u200b", null, "position: absolute;\n                         top: " + (coords.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + coords.left + "px; width: 2px;");
          cm.display.lineSpace.appendChild(scrollNode);
          scrollNode.scrollIntoView(doScroll);
          cm.display.lineSpace.removeChild(scrollNode);
        }
      }
      function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null) {
          margin = 0;
        }
        var coords;
        for (var limit = 0; limit < 5; limit++) {
          var changed = false;
          coords = cursorCoords(cm, pos);
          var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
          var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin);
          var startTop = cm.doc.scrollTop,
              startLeft = cm.doc.scrollLeft;
          if (scrollPos.scrollTop != null) {
            setScrollTop(cm, scrollPos.scrollTop);
            if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
              changed = true;
            }
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
              changed = true;
            }
          }
          if (!changed) {
            break;
          }
        }
        return coords;
      }
      function scrollIntoView(cm, x1, y1, x2, y2) {
        var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
        if (scrollPos.scrollTop != null) {
          setScrollTop(cm, scrollPos.scrollTop);
        }
        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
        }
      }
      function calculateScrollPos(cm, x1, y1, x2, y2) {
        var display = cm.display,
            snapMargin = textHeight(cm.display);
        if (y1 < 0) {
          y1 = 0;
        }
        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen = displayHeight(cm),
            result = {};
        if (y2 - y1 > screen) {
          y2 = y1 + screen;
        }
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = y1 < snapMargin,
            atBottom = y2 > docBottom - snapMargin;
        if (y1 < screentop) {
          result.scrollTop = atTop ? 0 : y1;
        } else if (y2 > screentop + screen) {
          var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
          if (newTop != screentop) {
            result.scrollTop = newTop;
          }
        }
        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
        var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
        var tooWide = x2 - x1 > screenw;
        if (tooWide) {
          x2 = x1 + screenw;
        }
        if (x1 < 10) {
          result.scrollLeft = 0;
        } else if (x1 < screenleft) {
          result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
        } else if (x2 > screenw + screenleft - 3) {
          result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
        }
        return result;
      }
      function addToScrollPos(cm, left, top) {
        if (left != null || top != null) {
          resolveScrollToPos(cm);
        }
        if (left != null) {
          cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
        }
        if (top != null) {
          cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
        }
      }
      function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor(),
            from = cur,
            to = cur;
        if (!cm.options.lineWrapping) {
          from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
          to = Pos(cur.line, cur.ch + 1);
        }
        cm.curOp.scrollToPos = {
          from: from,
          to: to,
          margin: cm.options.cursorScrollMargin,
          isCursor: true
        };
      }
      function resolveScrollToPos(cm) {
        var range = cm.curOp.scrollToPos;
        if (range) {
          cm.curOp.scrollToPos = null;
          var from = estimateCoords(cm, range.from),
              to = estimateCoords(cm, range.to);
          var sPos = calculateScrollPos(cm, Math.min(from.left, to.left), Math.min(from.top, to.top) - range.margin, Math.max(from.right, to.right), Math.max(from.bottom, to.bottom) + range.margin);
          cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
        }
      }
      var nextOpId = 0;
      function startOperation(cm) {
        cm.curOp = {
          cm: cm,
          viewChanged: false,
          startHeight: cm.doc.height,
          forceUpdate: false,
          updateInput: null,
          typing: false,
          changeObjs: null,
          cursorActivityHandlers: null,
          cursorActivityCalled: 0,
          selectionChanged: false,
          updateMaxLine: false,
          scrollLeft: null,
          scrollTop: null,
          scrollToPos: null,
          focus: false,
          id: ++nextOpId
        };
        pushOperation(cm.curOp);
      }
      function endOperation(cm) {
        var op = cm.curOp;
        finishOperation(op, function (group) {
          for (var i = 0; i < group.ops.length; i++) {
            group.ops[i].cm.curOp = null;
          }
          endOperations(group);
        });
      }
      function endOperations(group) {
        var ops = group.ops;
        for (var i = 0; i < ops.length; i++) {
          endOperation_R1(ops[i]);
        }
        for (var i$1 = 0; i$1 < ops.length; i$1++) {
          endOperation_W1(ops[i$1]);
        }
        for (var i$2 = 0; i$2 < ops.length; i$2++) {
          endOperation_R2(ops[i$2]);
        }
        for (var i$3 = 0; i$3 < ops.length; i$3++) {
          endOperation_W2(ops[i$3]);
        }
        for (var i$4 = 0; i$4 < ops.length; i$4++) {
          endOperation_finish(ops[i$4]);
        }
      }
      function endOperation_R1(op) {
        var cm = op.cm,
            display = cm.display;
        maybeClipScrollbars(cm);
        if (op.updateMaxLine) {
          findMaxLine(cm);
        }
        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
          top: op.scrollTop,
          ensure: op.scrollToPos
        }, op.forceUpdate);
      }
      function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
      }
      function endOperation_R2(op) {
        var cm = op.cm,
            display = cm.display;
        if (op.updatedDisplay) {
          updateHeightsInViewport(cm);
        }
        op.barMeasure = measureForScrollbars(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping) {
          op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
          cm.display.sizerWidth = op.adjustWidthTo;
          op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
          op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
        }
        if (op.updatedDisplay || op.selectionChanged) {
          op.preparedSelection = display.input.prepareSelection(op.focus);
        }
      }
      function endOperation_W2(op) {
        var cm = op.cm;
        if (op.adjustWidthTo != null) {
          cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
          if (op.maxScrollLeft < cm.doc.scrollLeft) {
            setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
          }
          cm.display.maxLineChanged = false;
        }
        var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());
        if (op.preparedSelection) {
          cm.display.input.showSelection(op.preparedSelection, takeFocus);
        }
        if (op.updatedDisplay || op.startHeight != cm.doc.height) {
          updateScrollbars(cm, op.barMeasure);
        }
        if (op.updatedDisplay) {
          setDocumentHeight(cm, op.barMeasure);
        }
        if (op.selectionChanged) {
          restartBlink(cm);
        }
        if (cm.state.focused && op.updateInput) {
          cm.display.input.reset(op.typing);
        }
        if (takeFocus) {
          ensureFocus(op.cm);
        }
      }
      function endOperation_finish(op) {
        var cm = op.cm,
            display = cm.display,
            doc = cm.doc;
        if (op.updatedDisplay) {
          postUpdateDisplay(cm, op.update);
        }
        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
          display.wheelStartX = display.wheelStartY = null;
        }
        if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
          doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
          display.scrollbars.setScrollTop(doc.scrollTop);
          display.scroller.scrollTop = doc.scrollTop;
        }
        if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
          doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
          display.scrollbars.setScrollLeft(doc.scrollLeft);
          display.scroller.scrollLeft = doc.scrollLeft;
          alignHorizontally(cm);
        }
        if (op.scrollToPos) {
          var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
          if (op.scrollToPos.isCursor && cm.state.focused) {
            maybeScrollWindow(cm, coords);
          }
        }
        var hidden = op.maybeHiddenMarkers,
            unhidden = op.maybeUnhiddenMarkers;
        if (hidden) {
          for (var i = 0; i < hidden.length; ++i) {
            if (!hidden[i].lines.length) {
              signal(hidden[i], "hide");
            }
          }
        }
        if (unhidden) {
          for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {
            if (unhidden[i$1].lines.length) {
              signal(unhidden[i$1], "unhide");
            }
          }
        }
        if (display.wrapper.offsetHeight) {
          doc.scrollTop = cm.display.scroller.scrollTop;
        }
        if (op.changeObjs) {
          signal(cm, "changes", cm, op.changeObjs);
        }
        if (op.update) {
          op.update.finish();
        }
      }
      function runInOp(cm, f) {
        if (cm.curOp) {
          return f();
        }
        startOperation(cm);
        try {
          return f();
        } finally {
          endOperation(cm);
        }
      }
      function operation(cm, f) {
        return function () {
          if (cm.curOp) {
            return f.apply(cm, arguments);
          }
          startOperation(cm);
          try {
            return f.apply(cm, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function methodOp(f) {
        return function () {
          if (this.curOp) {
            return f.apply(this, arguments);
          }
          startOperation(this);
          try {
            return f.apply(this, arguments);
          } finally {
            endOperation(this);
          }
        };
      }
      function docMethodOp(f) {
        return function () {
          var cm = this.cm;
          if (!cm || cm.curOp) {
            return f.apply(this, arguments);
          }
          startOperation(cm);
          try {
            return f.apply(this, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function regChange(cm, from, to, lendiff) {
        if (from == null) {
          from = cm.doc.first;
        }
        if (to == null) {
          to = cm.doc.first + cm.doc.size;
        }
        if (!lendiff) {
          lendiff = 0;
        }
        var display = cm.display;
        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
          display.updateLineNumbers = from;
        }
        cm.curOp.viewChanged = true;
        if (from >= display.viewTo) {
          if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
            resetView(cm);
          }
        } else if (to <= display.viewFrom) {
          if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
            resetView(cm);
          } else {
            display.viewFrom += lendiff;
            display.viewTo += lendiff;
          }
        } else if (from <= display.viewFrom && to >= display.viewTo) {
          resetView(cm);
        } else if (from <= display.viewFrom) {
          var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cut) {
            display.view = display.view.slice(cut.index);
            display.viewFrom = cut.lineN;
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        } else if (to >= display.viewTo) {
          var cut$1 = viewCuttingPoint(cm, from, from, -1);
          if (cut$1) {
            display.view = display.view.slice(0, cut$1.index);
            display.viewTo = cut$1.lineN;
          } else {
            resetView(cm);
          }
        } else {
          var cutTop = viewCuttingPoint(cm, from, from, -1);
          var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cutTop && cutBot) {
            display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        }
        var ext = display.externalMeasured;
        if (ext) {
          if (to < ext.lineN) {
            ext.lineN += lendiff;
          } else if (from < ext.lineN + ext.size) {
            display.externalMeasured = null;
          }
        }
      }
      function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = true;
        var display = cm.display,
            ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
          display.externalMeasured = null;
        }
        if (line < display.viewFrom || line >= display.viewTo) {
          return;
        }
        var lineView = display.view[findViewIndex(cm, line)];
        if (lineView.node == null) {
          return;
        }
        var arr = lineView.changes || (lineView.changes = []);
        if (indexOf(arr, type) == -1) {
          arr.push(type);
        }
      }
      function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
      }
      function viewCuttingPoint(cm, oldN, newN, dir) {
        var index = findViewIndex(cm, oldN),
            diff,
            view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
          return {
            index: index,
            lineN: newN
          };
        }
        var n = cm.display.viewFrom;
        for (var i = 0; i < index; i++) {
          n += view[i].size;
        }
        if (n != oldN) {
          if (dir > 0) {
            if (index == view.length - 1) {
              return null;
            }
            diff = n + view[index].size - oldN;
            index++;
          } else {
            diff = n - oldN;
          }
          oldN += diff;
          newN += diff;
        }
        while (visualLineNo(cm.doc, newN) != newN) {
          if (index == (dir < 0 ? 0 : view.length - 1)) {
            return null;
          }
          newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
          index += dir;
        }
        return {
          index: index,
          lineN: newN
        };
      }
      function adjustView(cm, from, to) {
        var display = cm.display,
            view = display.view;
        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
          display.view = buildViewArray(cm, from, to);
          display.viewFrom = from;
        } else {
          if (display.viewFrom > from) {
            display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
          } else if (display.viewFrom < from) {
            display.view = display.view.slice(findViewIndex(cm, from));
          }
          display.viewFrom = from;
          if (display.viewTo < to) {
            display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
          } else if (display.viewTo > to) {
            display.view = display.view.slice(0, findViewIndex(cm, to));
          }
        }
        display.viewTo = to;
      }
      function countDirtyView(cm) {
        var view = cm.display.view,
            dirty = 0;
        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];
          if (!lineView.hidden && (!lineView.node || lineView.changes)) {
            ++dirty;
          }
        }
        return dirty;
      }
      function startWorker(cm, time) {
        if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo) {
          cm.state.highlight.set(time, bind(highlightWorker, cm));
        }
      }
      function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.frontier < doc.first) {
          doc.frontier = doc.first;
        }
        if (doc.frontier >= cm.display.viewTo) {
          return;
        }
        var end = +new Date() + cm.options.workTime;
        var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
        var changedLines = [];
        doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
          if (doc.frontier >= cm.display.viewFrom) {
            var oldStyles = line.styles,
                tooLong = line.text.length > cm.options.maxHighlightLength;
            var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
            line.styles = highlighted.styles;
            var oldCls = line.styleClasses,
                newCls = highlighted.classes;
            if (newCls) {
              line.styleClasses = newCls;
            } else if (oldCls) {
              line.styleClasses = null;
            }
            var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
            for (var i = 0; !ischange && i < oldStyles.length; ++i) {
              ischange = oldStyles[i] != line.styles[i];
            }
            if (ischange) {
              changedLines.push(doc.frontier);
            }
            line.stateAfter = tooLong ? state : copyState(doc.mode, state);
          } else {
            if (line.text.length <= cm.options.maxHighlightLength) {
              processLine(cm, line.text, state);
            }
            line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
          }
          ++doc.frontier;
          if (+new Date() > end) {
            startWorker(cm, cm.options.workDelay);
            return true;
          }
        });
        if (changedLines.length) {
          runInOp(cm, function () {
            for (var i = 0; i < changedLines.length; i++) {
              regLineChange(cm, changedLines[i], "text");
            }
          });
        }
      }
      function DisplayUpdate(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport;
        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.wrapperWidth = display.wrapper.clientWidth;
        this.oldDisplayWidth = displayWidth(cm);
        this.force = force;
        this.dims = getDimensions(cm);
        this.events = [];
      }
      DisplayUpdate.prototype.signal = function (emitter, type) {
        if (hasHandler(emitter, type)) {
          this.events.push(arguments);
        }
      };
      DisplayUpdate.prototype.finish = function () {
        var this$1 = this;
        for (var i = 0; i < this.events.length; i++) {
          signal.apply(null, this$1.events[i]);
        }
      };
      function maybeClipScrollbars(cm) {
        var display = cm.display;
        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
          display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
          display.heightForcer.style.height = scrollGap(cm) + "px";
          display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
          display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
          display.scrollbarsClipped = true;
        }
      }
      function updateDisplayIfNeeded(cm, update) {
        var display = cm.display,
            doc = cm.doc;
        if (update.editorIsHidden) {
          resetView(cm);
          return false;
        }
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
          return false;
        }
        if (maybeUpdateLineNumberWidth(cm)) {
          resetView(cm);
          update.dims = getDimensions(cm);
        }
        var end = doc.first + doc.size;
        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        if (display.viewFrom < from && from - display.viewFrom < 20) {
          from = Math.max(doc.first, display.viewFrom);
        }
        if (display.viewTo > to && display.viewTo - to < 20) {
          to = Math.min(end, display.viewTo);
        }
        if (sawCollapsedSpans) {
          from = visualLineNo(cm.doc, from);
          to = visualLineEndNo(cm.doc, to);
        }
        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to);
        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
        cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);
        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
          return false;
        }
        var focused = activeElt();
        if (toUpdate > 4) {
          display.lineDiv.style.display = "none";
        }
        patchDisplay(cm, display.updateLineNumbers, update.dims);
        if (toUpdate > 4) {
          display.lineDiv.style.display = "";
        }
        display.renderedView = display.view;
        if (focused && activeElt() != focused && focused.offsetHeight) {
          focused.focus();
        }
        removeChildren(display.cursorDiv);
        removeChildren(display.selectionDiv);
        display.gutters.style.height = display.sizer.style.minHeight = 0;
        if (different) {
          display.lastWrapHeight = update.wrapperHeight;
          display.lastWrapWidth = update.wrapperWidth;
          startWorker(cm, 400);
        }
        display.updateLineNumbers = null;
        return true;
      }
      function postUpdateDisplay(cm, update) {
        var viewport = update.viewport;
        for (var first = true;; first = false) {
          if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
            if (viewport && viewport.top != null) {
              viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
            }
            update.visible = visibleLines(cm.display, cm.doc, viewport);
            if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
              break;
            }
          }
          if (!updateDisplayIfNeeded(cm, update)) {
            break;
          }
          updateHeightsInViewport(cm);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
        }
        update.signal(cm, "update", cm);
        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
          update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
          cm.display.reportedViewFrom = cm.display.viewFrom;
          cm.display.reportedViewTo = cm.display.viewTo;
        }
      }
      function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
          updateHeightsInViewport(cm);
          postUpdateDisplay(cm, update);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.finish();
        }
      }
      function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display,
            lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv,
            cur = container.firstChild;
        function rm(node) {
          var next = node.nextSibling;
          if (webkit && mac && cm.display.currentWheelTarget == node) {
            node.style.display = "none";
          } else {
            node.parentNode.removeChild(node);
          }
          return next;
        }
        var view = display.view,
            lineN = display.viewFrom;
        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];
          if (lineView.hidden) {} else if (!lineView.node || lineView.node.parentNode != container) {
            var node = buildLineElement(cm, lineView, lineN, dims);
            container.insertBefore(node, cur);
          } else {
            while (cur != lineView.node) {
              cur = rm(cur);
            }
            var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
            if (lineView.changes) {
              if (indexOf(lineView.changes, "gutter") > -1) {
                updateNumber = false;
              }
              updateLineForChanges(cm, lineView, lineN, dims);
            }
            if (updateNumber) {
              removeChildren(lineView.lineNumber);
              lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
            }
            cur = lineView.node.nextSibling;
          }
          lineN += lineView.size;
        }
        while (cur) {
          cur = rm(cur);
        }
      }
      function updateGutterSpace(cm) {
        var width = cm.display.gutters.offsetWidth;
        cm.display.sizer.style.marginLeft = width + "px";
      }
      function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px";
        cm.display.heightForcer.style.top = measure.docHeight + "px";
        cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
      }
      function updateGutters(cm) {
        var gutters = cm.display.gutters,
            specs = cm.options.gutters;
        removeChildren(gutters);
        var i = 0;
        for (; i < specs.length; ++i) {
          var gutterClass = specs[i];
          var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
          if (gutterClass == "CodeMirror-linenumbers") {
            cm.display.lineGutter = gElt;
            gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
          }
        }
        gutters.style.display = i ? "" : "none";
        updateGutterSpace(cm);
      }
      function setGuttersForLineNumbers(options) {
        var found = indexOf(options.gutters, "CodeMirror-linenumbers");
        if (found == -1 && options.lineNumbers) {
          options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
        } else if (found > -1 && !options.lineNumbers) {
          options.gutters = options.gutters.slice(0);
          options.gutters.splice(found, 1);
        }
      }
      function Selection(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
      }
      Selection.prototype = {
        primary: function () {
          return this.ranges[this.primIndex];
        },
        equals: function (other) {
          var this$1 = this;
          if (other == this) {
            return true;
          }
          if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
            return false;
          }
          for (var i = 0; i < this.ranges.length; i++) {
            var here = this$1.ranges[i],
                there = other.ranges[i];
            if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) {
              return false;
            }
          }
          return true;
        },
        deepCopy: function () {
          var this$1 = this;
          var out = [];
          for (var i = 0; i < this.ranges.length; i++) {
            out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));
          }
          return new Selection(out, this.primIndex);
        },
        somethingSelected: function () {
          var this$1 = this;
          for (var i = 0; i < this.ranges.length; i++) {
            if (!this$1.ranges[i].empty()) {
              return true;
            }
          }
          return false;
        },
        contains: function (pos, end) {
          var this$1 = this;
          if (!end) {
            end = pos;
          }
          for (var i = 0; i < this.ranges.length; i++) {
            var range = this$1.ranges[i];
            if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
              return i;
            }
          }
          return -1;
        }
      };
      function Range(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      }
      Range.prototype = {
        from: function () {
          return minPos(this.anchor, this.head);
        },
        to: function () {
          return maxPos(this.anchor, this.head);
        },
        empty: function () {
          return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        }
      };
      function normalizeSelection(ranges, primIndex) {
        var prim = ranges[primIndex];
        ranges.sort(function (a, b) {
          return cmp(a.from(), b.from());
        });
        primIndex = indexOf(ranges, prim);
        for (var i = 1; i < ranges.length; i++) {
          var cur = ranges[i],
              prev = ranges[i - 1];
          if (cmp(prev.to(), cur.from()) >= 0) {
            var from = minPos(prev.from(), cur.from()),
                to = maxPos(prev.to(), cur.to());
            var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
            if (i <= primIndex) {
              --primIndex;
            }
            ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
          }
        }
        return new Selection(ranges, primIndex);
      }
      function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor, head || anchor)], 0);
      }
      function changeEnd(change) {
        if (!change.text) {
          return change.to;
        }
        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
      }
      function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0) {
          return pos;
        }
        if (cmp(pos, change.to) <= 0) {
          return changeEnd(change);
        }
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
            ch = pos.ch;
        if (pos.line == change.to.line) {
          ch += changeEnd(change).ch - change.to.ch;
        }
        return Pos(line, ch);
      }
      function computeSelAfterChange(doc, change) {
        var out = [];
        for (var i = 0; i < doc.sel.ranges.length; i++) {
          var range = doc.sel.ranges[i];
          out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
        }
        return normalizeSelection(out, doc.sel.primIndex);
      }
      function offsetPos(pos, old, nw) {
        if (pos.line == old.line) {
          return Pos(nw.line, pos.ch - old.ch + nw.ch);
        } else {
          return Pos(nw.line + (pos.line - old.line), pos.ch);
        }
      }
      function computeReplacedSel(doc, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc.first, 0),
            newPrev = oldPrev;
        for (var i = 0; i < changes.length; i++) {
          var change = changes[i];
          var from = offsetPos(change.from, oldPrev, newPrev);
          var to = offsetPos(changeEnd(change), oldPrev, newPrev);
          oldPrev = change.to;
          newPrev = to;
          if (hint == "around") {
            var range = doc.sel.ranges[i],
                inv = cmp(range.head, range.anchor) < 0;
            out[i] = new Range(inv ? to : from, inv ? from : to);
          } else {
            out[i] = new Range(from, from);
          }
        }
        return new Selection(out, doc.sel.primIndex);
      }
      function loadMode(cm) {
        cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
      }
      function resetModeState(cm) {
        cm.doc.iter(function (line) {
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          if (line.styles) {
            line.styles = null;
          }
        });
        cm.doc.frontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp) {
          regChange(cm);
        }
      }
      function isWholeLineUpdate(doc, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
      }
      function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
          return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text, spans) {
          updateLine(line, text, spans, estimateHeight);
          signalLater(line, "change", line, change);
        }
        function linesFor(start, end) {
          var result = [];
          for (var i = start; i < end; ++i) {
            result.push(new Line(text[i], spansFor(i), estimateHeight));
          }
          return result;
        }
        var from = change.from,
            to = change.to,
            text = change.text;
        var firstLine = getLine(doc, from.line),
            lastLine = getLine(doc, to.line);
        var lastText = lst(text),
            lastSpans = spansFor(text.length - 1),
            nlines = to.line - from.line;
        if (change.full) {
          doc.insert(0, linesFor(0, text.length));
          doc.remove(text.length, doc.size - text.length);
        } else if (isWholeLineUpdate(doc, change)) {
          var added = linesFor(0, text.length - 1);
          update(lastLine, lastLine.text, lastSpans);
          if (nlines) {
            doc.remove(from.line, nlines);
          }
          if (added.length) {
            doc.insert(from.line, added);
          }
        } else if (firstLine == lastLine) {
          if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
          } else {
            var added$1 = linesFor(1, text.length - 1);
            added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            doc.insert(from.line + 1, added$1);
          }
        } else if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
          doc.remove(from.line + 1, nlines);
        } else {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
          var added$2 = linesFor(1, text.length - 1);
          if (nlines > 1) {
            doc.remove(from.line + 1, nlines - 1);
          }
          doc.insert(from.line + 1, added$2);
        }
        signalLater(doc, "change", doc, change);
      }
      function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
          if (doc.linked) {
            for (var i = 0; i < doc.linked.length; ++i) {
              var rel = doc.linked[i];
              if (rel.doc == skip) {
                continue;
              }
              var shared = sharedHist && rel.sharedHist;
              if (sharedHistOnly && !shared) {
                continue;
              }
              f(rel.doc, shared);
              propagate(rel.doc, doc, shared);
            }
          }
        }
        propagate(doc, null, true);
      }
      function attachDoc(cm, doc) {
        if (doc.cm) {
          throw new Error("This document is already in use.");
        }
        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        if (!cm.options.lineWrapping) {
          findMaxLine(cm);
        }
        cm.options.mode = doc.modeOption;
        regChange(cm);
      }
      function History(startGen) {
        this.done = [];
        this.undone = [];
        this.undoDepth = Infinity;
        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null;
        this.generation = this.maxGeneration = startGen || 1;
      }
      function historyChangeFromChange(doc, change) {
        var histChange = {
          from: copyPos(change.from),
          to: changeEnd(change),
          text: getBetween(doc, change.from, change.to)
        };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function (doc) {
          return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
      }
      function clearSelectionEvents(array) {
        while (array.length) {
          var last = lst(array);
          if (last.ranges) {
            array.pop();
          } else {
            break;
          }
        }
      }
      function lastChangeEvent(hist, force) {
        if (force) {
          clearSelectionEvents(hist.done);
          return lst(hist.done);
        } else if (hist.done.length && !lst(hist.done).ranges) {
          return lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
          hist.done.pop();
          return lst(hist.done);
        }
      }
      function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date(),
            cur;
        var last;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
          last = lst(cur.changes);
          if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
            last.to = changeEnd(change);
          } else {
            cur.changes.push(historyChangeFromChange(doc, change));
          }
        } else {
          var before = lst(hist.done);
          if (!before || !before.ranges) {
            pushSelectionToHistory(doc.sel, hist.done);
          }
          cur = {
            changes: [historyChangeFromChange(doc, change)],
            generation: hist.generation
          };
          hist.done.push(cur);
          while (hist.done.length > hist.undoDepth) {
            hist.done.shift();
            if (!hist.done[0].ranges) {
              hist.done.shift();
            }
          }
        }
        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;
        if (!last) {
          signal(doc, "historyAdded");
        }
      }
      function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
      }
      function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history,
            origin = options && options.origin;
        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
          hist.done[hist.done.length - 1] = sel;
        } else {
          pushSelectionToHistory(sel, hist.done);
        }
        hist.lastSelTime = +new Date();
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;
        if (options && options.clearRedo !== false) {
          clearSelectionEvents(hist.undone);
        }
      }
      function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        if (!(top && top.ranges && top.equals(sel))) {
          dest.push(sel);
        }
      }
      function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id],
            n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
          if (line.markedSpans) {
            (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
          }
          ++n;
        });
      }
      function removeClearedSpans(spans) {
        if (!spans) {
          return null;
        }
        var out;
        for (var i = 0; i < spans.length; ++i) {
          if (spans[i].marker.explicitlyCleared) {
            if (!out) {
              out = spans.slice(0, i);
            }
          } else if (out) {
            out.push(spans[i]);
          }
        }
        return !out ? spans : out.length ? out : null;
      }
      function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found) {
          return null;
        }
        var nw = [];
        for (var i = 0; i < change.text.length; ++i) {
          nw.push(removeClearedSpans(found[i]));
        }
        return nw;
      }
      function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);
        if (!old) {
          return stretched;
        }
        if (!stretched) {
          return old;
        }
        for (var i = 0; i < old.length; ++i) {
          var oldCur = old[i],
              stretchCur = stretched[i];
          if (oldCur && stretchCur) {
            spans: for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];
              for (var k = 0; k < oldCur.length; ++k) {
                if (oldCur[k].marker == span.marker) {
                  continue spans;
                }
              }
              oldCur.push(span);
            }
          } else if (stretchCur) {
            old[i] = stretchCur;
          }
        }
        return old;
      }
      function copyHistoryArray(events, newGroup, instantiateSel) {
        var copy = [];
        for (var i = 0; i < events.length; ++i) {
          var event = events[i];
          if (event.ranges) {
            copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
            continue;
          }
          var changes = event.changes,
              newChanges = [];
          copy.push({ changes: newChanges });
          for (var j = 0; j < changes.length; ++j) {
            var change = changes[j],
                m = void 0;
            newChanges.push({
              from: change.from,
              to: change.to,
              text: change.text
            });
            if (newGroup) {
              for (var prop in change) {
                if (m = prop.match(/^spans_(\d+)$/)) {
                  if (indexOf(newGroup, Number(m[1])) > -1) {
                    lst(newChanges)[prop] = change[prop];
                    delete change[prop];
                  }
                }
              }
            }
          }
        }
        return copy;
      }
      function extendRange(doc, range, head, other) {
        if (doc.cm && doc.cm.display.shift || doc.extend) {
          var anchor = range.anchor;
          if (other) {
            var posBefore = cmp(head, anchor) < 0;
            if (posBefore != cmp(other, anchor) < 0) {
              anchor = head;
              head = other;
            } else if (posBefore != cmp(head, other) < 0) {
              head = other;
            }
          }
          return new Range(anchor, head);
        } else {
          return new Range(other || head, head);
        }
      }
      function extendSelection(doc, head, other, options) {
        setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
      }
      function extendSelections(doc, heads, options) {
        var out = [];
        for (var i = 0; i < doc.sel.ranges.length; i++) {
          out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
        }
        var newSel = normalizeSelection(out, doc.sel.primIndex);
        setSelection(doc, newSel, options);
      }
      function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range;
        setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
      }
      function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
      }
      function filterSelectionChange(doc, sel, options) {
        var obj = {
          ranges: sel.ranges,
          update: function (ranges) {
            var this$1 = this;
            this.ranges = [];
            for (var i = 0; i < ranges.length; i++) {
              this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
            }
          },
          origin: options && options.origin
        };
        signal(doc, "beforeSelectionChange", doc, obj);
        if (doc.cm) {
          signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
        }
        if (obj.ranges != sel.ranges) {
          return normalizeSelection(obj.ranges, obj.ranges.length - 1);
        } else {
          return sel;
        }
      }
      function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done,
            last = lst(done);
        if (last && last.ranges) {
          done[done.length - 1] = sel;
          setSelectionNoUndo(doc, sel, options);
        } else {
          setSelection(doc, sel, options);
        }
      }
      function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options);
        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
      }
      function setSelectionNoUndo(doc, sel, options) {
        if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
          sel = filterSelectionChange(doc, sel, options);
        }
        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
        if (!(options && options.scroll === false) && doc.cm) {
          ensureCursorVisible(doc.cm);
        }
      }
      function setSelectionInner(doc, sel) {
        if (sel.equals(doc.sel)) {
          return;
        }
        doc.sel = sel;
        if (doc.cm) {
          doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
          signalCursorActivity(doc.cm);
        }
        signalLater(doc, "cursorActivity", doc);
      }
      function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
      }
      function skipAtomicInSelection(doc, sel, bias, mayClear) {
        var out;
        for (var i = 0; i < sel.ranges.length; i++) {
          var range = sel.ranges[i];
          var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
          var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
          var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
          if (out || newAnchor != range.anchor || newHead != range.head) {
            if (!out) {
              out = sel.ranges.slice(0, i);
            }
            out[i] = new Range(newAnchor, newHead);
          }
        }
        return out ? normalizeSelection(out, sel.primIndex) : sel;
      }
      function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
        var line = getLine(doc, pos.line);
        if (line.markedSpans) {
          for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i],
                m = sp.marker;
            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
              if (mayClear) {
                signal(m, "beforeCursorEnter");
                if (m.explicitlyCleared) {
                  if (!line.markedSpans) {
                    break;
                  } else {
                    --i;
                    continue;
                  }
                }
              }
              if (!m.atomic) {
                continue;
              }
              if (oldPos) {
                var near = m.find(dir < 0 ? 1 : -1),
                    diff = void 0;
                if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft) {
                  near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
                }
                if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                  return skipAtomicInner(doc, near, pos, dir, mayClear);
                }
              }
              var far = m.find(dir < 0 ? -1 : 1);
              if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) {
                far = movePos(doc, far, dir, far.line == pos.line ? line : null);
              }
              return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
            }
          }
        }
        return pos;
      }
      function skipAtomic(doc, pos, oldPos, bias, mayClear) {
        var dir = bias || 1;
        var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
        if (!found) {
          doc.cantEdit = true;
          return Pos(doc.first, 0);
        }
        return found;
      }
      function movePos(doc, pos, dir, line) {
        if (dir < 0 && pos.ch == 0) {
          if (pos.line > doc.first) {
            return clipPos(doc, Pos(pos.line - 1));
          } else {
            return null;
          }
        } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
          if (pos.line < doc.first + doc.size - 1) {
            return Pos(pos.line + 1, 0);
          } else {
            return null;
          }
        } else {
          return new Pos(pos.line, pos.ch + dir);
        }
      }
      function selectAll(cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
      }
      function filterChange(doc, change, update) {
        var obj = {
          canceled: false,
          from: change.from,
          to: change.to,
          text: change.text,
          origin: change.origin,
          cancel: function () {
            return obj.canceled = true;
          }
        };
        if (update) {
          obj.update = function (from, to, text, origin) {
            if (from) {
              obj.from = clipPos(doc, from);
            }
            if (to) {
              obj.to = clipPos(doc, to);
            }
            if (text) {
              obj.text = text;
            }
            if (origin !== undefined) {
              obj.origin = origin;
            }
          };
        }
        signal(doc, "beforeChange", doc, obj);
        if (doc.cm) {
          signal(doc.cm, "beforeChange", doc.cm, obj);
        }
        if (obj.canceled) {
          return null;
        }
        return {
          from: obj.from,
          to: obj.to,
          text: obj.text,
          origin: obj.origin
        };
      }
      function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
          if (!doc.cm.curOp) {
            return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
          }
          if (doc.cm.state.suppressEdits) {
            return;
          }
        }
        if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
          change = filterChange(doc, change, true);
          if (!change) {
            return;
          }
        }
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
        if (split) {
          for (var i = split.length - 1; i >= 0; --i) {
            makeChangeInner(doc, {
              from: split[i].from,
              to: split[i].to,
              text: i ? [""] : change.text
            });
          }
        } else {
          makeChangeInner(doc, change);
        }
      }
      function makeChangeInner(doc, change) {
        if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
          return;
        }
        var selAfter = computeSelAfterChange(doc, change);
        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];
        linkedDocs(doc, function (doc, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc.history) == -1) {
            rebaseHist(doc.history, change);
            rebased.push(doc.history);
          }
          makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        });
      }
      function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) {
          return;
        }
        var hist = doc.history,
            event,
            selAfter = doc.sel;
        var source = type == "undo" ? hist.done : hist.undone,
            dest = type == "undo" ? hist.undone : hist.done;
        var i = 0;
        for (; i < source.length; i++) {
          event = source[i];
          if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
            break;
          }
        }
        if (i == source.length) {
          return;
        }
        hist.lastOrigin = hist.lastSelOrigin = null;
        for (;;) {
          event = source.pop();
          if (event.ranges) {
            pushSelectionToHistory(event, dest);
            if (allowSelectionOnly && !event.equals(doc.sel)) {
              setSelection(doc, event, { clearRedo: false });
              return;
            }
            selAfter = event;
          } else {
            break;
          }
        }
        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({
          changes: antiChanges,
          generation: hist.generation
        });
        hist.generation = event.generation || ++hist.maxGeneration;
        var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
        var loop = function (i) {
          var change = event.changes[i];
          change.origin = type;
          if (filter && !filterChange(doc, change, false)) {
            source.length = 0;
            return {};
          }
          antiChanges.push(historyChangeFromChange(doc, change));
          var after = i ? computeSelAfterChange(doc, change) : lst(source);
          makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
          if (!i && doc.cm) {
            doc.cm.scrollIntoView({
              from: change.from,
              to: changeEnd(change)
            });
          }
          var rebased = [];
          linkedDocs(doc, function (doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
              rebaseHist(doc.history, change);
              rebased.push(doc.history);
            }
            makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
          });
        };
        for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
          var returned = loop(i$1);
          if (returned) return returned.v;
        }
      }
      function shiftDoc(doc, distance) {
        if (distance == 0) {
          return;
        }
        doc.first += distance;
        doc.sel = new Selection(map(doc.sel.ranges, function (range) {
          return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
        }), doc.sel.primIndex);
        if (doc.cm) {
          regChange(doc.cm, doc.first, doc.first - distance, distance);
          for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
            regLineChange(doc.cm, l, "gutter");
          }
        }
      }
      function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp) {
          return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        }
        if (change.to.line < doc.first) {
          shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
          return;
        }
        if (change.from.line > doc.lastLine()) {
          return;
        }
        if (change.from.line < doc.first) {
          var shift = change.text.length - 1 - (doc.first - change.from.line);
          shiftDoc(doc, shift);
          change = {
            from: Pos(doc.first, 0),
            to: Pos(change.to.line + shift, change.to.ch),
            text: [lst(change.text)],
            origin: change.origin
          };
        }
        var last = doc.lastLine();
        if (change.to.line > last) {
          change = {
            from: change.from,
            to: Pos(last, getLine(doc, last).text.length),
            text: [change.text[0]],
            origin: change.origin
          };
        }
        change.removed = getBetween(doc, change.from, change.to);
        if (!selAfter) {
          selAfter = computeSelAfterChange(doc, change);
        }
        if (doc.cm) {
          makeChangeSingleDocInEditor(doc.cm, change, spans);
        } else {
          updateDoc(doc, change, spans);
        }
        setSelectionNoUndo(doc, selAfter, sel_dontScroll);
      }
      function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc,
            display = cm.display,
            from = change.from,
            to = change.to;
        var recomputeMaxLength = false,
            checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
          checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
          doc.iter(checkWidthStart, to.line + 1, function (line) {
            if (line == display.maxLine) {
              recomputeMaxLength = true;
              return true;
            }
          });
        }
        if (doc.sel.contains(change.from, change.to) > -1) {
          signalCursorActivity(cm);
        }
        updateDoc(doc, change, spans, estimateHeight(cm));
        if (!cm.options.lineWrapping) {
          doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
            var len = lineLength(line);
            if (len > display.maxLineLength) {
              display.maxLine = line;
              display.maxLineLength = len;
              display.maxLineChanged = true;
              recomputeMaxLength = false;
            }
          });
          if (recomputeMaxLength) {
            cm.curOp.updateMaxLine = true;
          }
        }
        doc.frontier = Math.min(doc.frontier, from.line);
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1;
        if (change.full) {
          regChange(cm);
        } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
          regLineChange(cm, from.line, "text");
        } else {
          regChange(cm, from.line, to.line + 1, lendiff);
        }
        var changesHandler = hasHandler(cm, "changes"),
            changeHandler = hasHandler(cm, "change");
        if (changeHandler || changesHandler) {
          var obj = {
            from: from,
            to: to,
            text: change.text,
            removed: change.removed,
            origin: change.origin
          };
          if (changeHandler) {
            signalLater(cm, "change", cm, obj);
          }
          if (changesHandler) {
            (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
          }
        }
        cm.display.selForContextMenu = null;
      }
      function replaceRange(doc, code, from, to, origin) {
        if (!to) {
          to = from;
        }
        if (cmp(to, from) < 0) {
          var tmp = to;
          to = from;
          from = tmp;
        }
        if (typeof code == "string") {
          code = doc.splitLines(code);
        }
        makeChange(doc, {
          from: from,
          to: to,
          text: code,
          origin: origin
        });
      }
      function rebaseHistSelSingle(pos, from, to, diff) {
        if (to < pos.line) {
          pos.line += diff;
        } else if (from < pos.line) {
          pos.line = from;
          pos.ch = 0;
        }
      }
      function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
          var sub = array[i],
              ok = true;
          if (sub.ranges) {
            if (!sub.copied) {
              sub = array[i] = sub.deepCopy();
              sub.copied = true;
            }
            for (var j = 0; j < sub.ranges.length; j++) {
              rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
              rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
            }
            continue;
          }
          for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
            var cur = sub.changes[j$1];
            if (to < cur.from.line) {
              cur.from = Pos(cur.from.line + diff, cur.from.ch);
              cur.to = Pos(cur.to.line + diff, cur.to.ch);
            } else if (from <= cur.to.line) {
              ok = false;
              break;
            }
          }
          if (!ok) {
            array.splice(0, i + 1);
            i = 0;
          }
        }
      }
      function rebaseHist(hist, change) {
        var from = change.from.line,
            to = change.to.line,
            diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
      }
      function changeLine(doc, handle, changeType, op) {
        var no = handle,
            line = handle;
        if (typeof handle == "number") {
          line = getLine(doc, clipLine(doc, handle));
        } else {
          no = lineNo(handle);
        }
        if (no == null) {
          return null;
        }
        if (op(line, no) && doc.cm) {
          regLineChange(doc.cm, no, changeType);
        }
        return line;
      }
      function LeafChunk(lines) {
        var this$1 = this;
        this.lines = lines;
        this.parent = null;
        var height = 0;
        for (var i = 0; i < lines.length; ++i) {
          lines[i].parent = this$1;
          height += lines[i].height;
        }
        this.height = height;
      }
      LeafChunk.prototype = {
        chunkSize: function () {
          return this.lines.length;
        },
        removeInner: function (at, n) {
          var this$1 = this;
          for (var i = at, e = at + n; i < e; ++i) {
            var line = this$1.lines[i];
            this$1.height -= line.height;
            cleanUpLine(line);
            signalLater(line, "delete");
          }
          this.lines.splice(at, n);
        },
        collapse: function (lines) {
          lines.push.apply(lines, this.lines);
        },
        insertInner: function (at, lines, height) {
          var this$1 = this;
          this.height += height;
          this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
          for (var i = 0; i < lines.length; ++i) {
            lines[i].parent = this$1;
          }
        },
        iterN: function (at, n, op) {
          var this$1 = this;
          for (var e = at + n; at < e; ++at) {
            if (op(this$1.lines[at])) {
              return true;
            }
          }
        }
      };
      function BranchChunk(children) {
        var this$1 = this;
        this.children = children;
        var size = 0,
            height = 0;
        for (var i = 0; i < children.length; ++i) {
          var ch = children[i];
          size += ch.chunkSize();
          height += ch.height;
          ch.parent = this$1;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
      }
      BranchChunk.prototype = {
        chunkSize: function () {
          return this.size;
        },
        removeInner: function (at, n) {
          var this$1 = this;
          this.size -= n;
          for (var i = 0; i < this.children.length; ++i) {
            var child = this$1.children[i],
                sz = child.chunkSize();
            if (at < sz) {
              var rm = Math.min(n, sz - at),
                  oldHeight = child.height;
              child.removeInner(at, rm);
              this$1.height -= oldHeight - child.height;
              if (sz == rm) {
                this$1.children.splice(i--, 1);
                child.parent = null;
              }
              if ((n -= rm) == 0) {
                break;
              }
              at = 0;
            } else {
              at -= sz;
            }
          }
          if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
            var lines = [];
            this.collapse(lines);
            this.children = [new LeafChunk(lines)];
            this.children[0].parent = this;
          }
        },
        collapse: function (lines) {
          var this$1 = this;
          for (var i = 0; i < this.children.length; ++i) {
            this$1.children[i].collapse(lines);
          }
        },
        insertInner: function (at, lines, height) {
          var this$1 = this;
          this.size += lines.length;
          this.height += height;
          for (var i = 0; i < this.children.length; ++i) {
            var child = this$1.children[i],
                sz = child.chunkSize();
            if (at <= sz) {
              child.insertInner(at, lines, height);
              if (child.lines && child.lines.length > 50) {
                var remaining = child.lines.length % 25 + 25;
                for (var pos = remaining; pos < child.lines.length;) {
                  var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                  child.height -= leaf.height;
                  this$1.children.splice(++i, 0, leaf);
                  leaf.parent = this$1;
                }
                child.lines = child.lines.slice(0, remaining);
                this$1.maybeSpill();
              }
              break;
            }
            at -= sz;
          }
        },
        maybeSpill: function () {
          if (this.children.length <= 10) {
            return;
          }
          var me = this;
          do {
            var spilled = me.children.splice(me.children.length - 5, 5);
            var sibling = new BranchChunk(spilled);
            if (!me.parent) {
              var copy = new BranchChunk(me.children);
              copy.parent = me;
              me.children = [copy, sibling];
              me = copy;
            } else {
              me.size -= sibling.size;
              me.height -= sibling.height;
              var myIndex = indexOf(me.parent.children, me);
              me.parent.children.splice(myIndex + 1, 0, sibling);
            }
            sibling.parent = me.parent;
          } while (me.children.length > 10);
          me.parent.maybeSpill();
        },
        iterN: function (at, n, op) {
          var this$1 = this;
          for (var i = 0; i < this.children.length; ++i) {
            var child = this$1.children[i],
                sz = child.chunkSize();
            if (at < sz) {
              var used = Math.min(n, sz - at);
              if (child.iterN(at, used, op)) {
                return true;
              }
              if ((n -= used) == 0) {
                break;
              }
              at = 0;
            } else {
              at -= sz;
            }
          }
        }
      };
      function LineWidget(doc, node, options) {
        var this$1 = this;
        if (options) {
          for (var opt in options) {
            if (options.hasOwnProperty(opt)) {
              this$1[opt] = options[opt];
            }
          }
        }
        this.doc = doc;
        this.node = node;
      }
      eventMixin(LineWidget);
      function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
          addToScrollPos(cm, null, diff);
        }
      }
      LineWidget.prototype.clear = function () {
        var this$1 = this;
        var cm = this.doc.cm,
            ws = this.line.widgets,
            line = this.line,
            no = lineNo(line);
        if (no == null || !ws) {
          return;
        }
        for (var i = 0; i < ws.length; ++i) {
          if (ws[i] == this$1) {
            ws.splice(i--, 1);
          }
        }
        if (!ws.length) {
          line.widgets = null;
        }
        var height = widgetHeight(this);
        updateLineHeight(line, Math.max(0, line.height - height));
        if (cm) {
          runInOp(cm, function () {
            adjustScrollWhenAboveVisible(cm, line, -height);
            regLineChange(cm, no, "widget");
          });
        }
      };
      LineWidget.prototype.changed = function () {
        var oldH = this.height,
            cm = this.doc.cm,
            line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        if (!diff) {
          return;
        }
        updateLineHeight(line, line.height + diff);
        if (cm) {
          runInOp(cm, function () {
            cm.curOp.forceUpdate = true;
            adjustScrollWhenAboveVisible(cm, line, diff);
          });
        }
      };
      function addLineWidget(doc, handle, node, options) {
        var widget = new LineWidget(doc, node, options);
        var cm = doc.cm;
        if (cm && widget.noHScroll) {
          cm.display.alignWidgets = true;
        }
        changeLine(doc, handle, "widget", function (line) {
          var widgets = line.widgets || (line.widgets = []);
          if (widget.insertAt == null) {
            widgets.push(widget);
          } else {
            widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
          }
          widget.line = line;
          if (cm && !lineIsHidden(doc, line)) {
            var aboveVisible = heightAtLine(line) < doc.scrollTop;
            updateLineHeight(line, line.height + widgetHeight(widget));
            if (aboveVisible) {
              addToScrollPos(cm, null, widget.height);
            }
            cm.curOp.forceUpdate = true;
          }
          return true;
        });
        return widget;
      }
      var nextMarkerId = 0;
      function TextMarker(doc, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc;
        this.id = ++nextMarkerId;
      }
      eventMixin(TextMarker);
      TextMarker.prototype.clear = function () {
        var this$1 = this;
        if (this.explicitlyCleared) {
          return;
        }
        var cm = this.doc.cm,
            withOp = cm && !cm.curOp;
        if (withOp) {
          startOperation(cm);
        }
        if (hasHandler(this, "clear")) {
          var found = this.find();
          if (found) {
            signalLater(this, "clear", found.from, found.to);
          }
        }
        var min = null,
            max = null;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this$1.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this$1);
          if (cm && !this$1.collapsed) {
            regLineChange(cm, lineNo(line), "text");
          } else if (cm) {
            if (span.to != null) {
              max = lineNo(line);
            }
            if (span.from != null) {
              min = lineNo(line);
            }
          }
          line.markedSpans = removeMarkedSpan(line.markedSpans, span);
          if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm) {
            updateLineHeight(line, textHeight(cm.display));
          }
        }
        if (cm && this.collapsed && !cm.options.lineWrapping) {
          for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
            var visual = visualLine(this$1.lines[i$1]),
                len = lineLength(visual);
            if (len > cm.display.maxLineLength) {
              cm.display.maxLine = visual;
              cm.display.maxLineLength = len;
              cm.display.maxLineChanged = true;
            }
          }
        }
        if (min != null && cm && this.collapsed) {
          regChange(cm, min, max + 1);
        }
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
          this.doc.cantEdit = false;
          if (cm) {
            reCheckSelection(cm.doc);
          }
        }
        if (cm) {
          signalLater(cm, "markerCleared", cm, this);
        }
        if (withOp) {
          endOperation(cm);
        }
        if (this.parent) {
          this.parent.clear();
        }
      };
      TextMarker.prototype.find = function (side, lineObj) {
        var this$1 = this;
        if (side == null && this.type == "bookmark") {
          side = 1;
        }
        var from, to;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this$1.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this$1);
          if (span.from != null) {
            from = Pos(lineObj ? line : lineNo(line), span.from);
            if (side == -1) {
              return from;
            }
          }
          if (span.to != null) {
            to = Pos(lineObj ? line : lineNo(line), span.to);
            if (side == 1) {
              return to;
            }
          }
        }
        return from && {
          from: from,
          to: to
        };
      };
      TextMarker.prototype.changed = function () {
        var pos = this.find(-1, true),
            widget = this,
            cm = this.doc.cm;
        if (!pos || !cm) {
          return;
        }
        runInOp(cm, function () {
          var line = pos.line,
              lineN = lineNo(pos.line);
          var view = findViewForLine(cm, lineN);
          if (view) {
            clearLineMeasurementCacheFor(view);
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
          }
          cm.curOp.updateMaxLine = true;
          if (!lineIsHidden(widget.doc, line) && widget.height != null) {
            var oldHeight = widget.height;
            widget.height = null;
            var dHeight = widgetHeight(widget) - oldHeight;
            if (dHeight) {
              updateLineHeight(line, line.height + dHeight);
            }
          }
        });
      };
      TextMarker.prototype.attachLine = function (line) {
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
            (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
          }
        }
        this.lines.push(line);
      };
      TextMarker.prototype.detachLine = function (line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          ;
          (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
      };
      function markText(doc, from, to, options, type) {
        if (options && options.shared) {
          return markTextShared(doc, from, to, options, type);
        }
        if (doc.cm && !doc.cm.curOp) {
          return operation(doc.cm, markText)(doc, from, to, options, type);
        }
        var marker = new TextMarker(doc, type),
            diff = cmp(from, to);
        if (options) {
          copyObj(options, marker, false);
        }
        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
          return marker;
        }
        if (marker.replacedWith) {
          marker.collapsed = true;
          marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
          if (!options.handleMouseEvents) {
            marker.widgetNode.setAttribute("cm-ignore-events", "true");
          }
          if (options.insertLeft) {
            marker.widgetNode.insertLeft = true;
          }
        }
        if (marker.collapsed) {
          if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
            throw new Error("Inserting collapsed marker partially overlapping an existing one");
          }
          seeCollapsedSpans();
        }
        if (marker.addToHistory) {
          addChangeToHistory(doc, {
            from: from,
            to: to,
            origin: "markText"
          }, doc.sel, NaN);
        }
        var curLine = from.line,
            cm = doc.cm,
            updateMaxLine;
        doc.iter(curLine, to.line + 1, function (line) {
          if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
            updateMaxLine = true;
          }
          if (marker.collapsed && curLine != from.line) {
            updateLineHeight(line, 0);
          }
          addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
          ++curLine;
        });
        if (marker.collapsed) {
          doc.iter(from.line, to.line + 1, function (line) {
            if (lineIsHidden(doc, line)) {
              updateLineHeight(line, 0);
            }
          });
        }
        if (marker.clearOnEnter) {
          on(marker, "beforeCursorEnter", function () {
            return marker.clear();
          });
        }
        if (marker.readOnly) {
          seeReadOnlySpans();
          if (doc.history.done.length || doc.history.undone.length) {
            doc.clearHistory();
          }
        }
        if (marker.collapsed) {
          marker.id = ++nextMarkerId;
          marker.atomic = true;
        }
        if (cm) {
          if (updateMaxLine) {
            cm.curOp.updateMaxLine = true;
          }
          if (marker.collapsed) {
            regChange(cm, from.line, to.line + 1);
          } else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css) {
            for (var i = from.line; i <= to.line; i++) {
              regLineChange(cm, i, "text");
            }
          }
          if (marker.atomic) {
            reCheckSelection(cm.doc);
          }
          signalLater(cm, "markerAdded", cm, marker);
        }
        return marker;
      }
      function SharedTextMarker(markers, primary) {
        var this$1 = this;
        this.markers = markers;
        this.primary = primary;
        for (var i = 0; i < markers.length; ++i) {
          markers[i].parent = this$1;
        }
      }
      eventMixin(SharedTextMarker);
      SharedTextMarker.prototype.clear = function () {
        var this$1 = this;
        if (this.explicitlyCleared) {
          return;
        }
        this.explicitlyCleared = true;
        for (var i = 0; i < this.markers.length; ++i) {
          this$1.markers[i].clear();
        }
        signalLater(this, "clear");
      };
      SharedTextMarker.prototype.find = function (side, lineObj) {
        return this.primary.find(side, lineObj);
      };
      function markTextShared(doc, from, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [markText(doc, from, to, options, type)],
            primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc, function (doc) {
          if (widget) {
            options.widgetNode = widget.cloneNode(true);
          }
          markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
          for (var i = 0; i < doc.linked.length; ++i) {
            if (doc.linked[i].isParent) {
              return;
            }
          }
          primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
      }
      function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
          return m.parent;
        });
      }
      function copySharedMarkers(doc, markers) {
        for (var i = 0; i < markers.length; i++) {
          var marker = markers[i],
              pos = marker.find();
          var mFrom = doc.clipPos(pos.from),
              mTo = doc.clipPos(pos.to);
          if (cmp(mFrom, mTo)) {
            var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
            marker.markers.push(subMark);
            subMark.parent = marker;
          }
        }
      }
      function detachSharedMarkers(markers) {
        var loop = function (i) {
          var marker = markers[i],
              linked = [marker.primary.doc];
          linkedDocs(marker.primary.doc, function (d) {
            return linked.push(d);
          });
          for (var j = 0; j < marker.markers.length; j++) {
            var subMarker = marker.markers[j];
            if (indexOf(linked, subMarker.doc) == -1) {
              subMarker.parent = null;
              marker.markers.splice(j--, 1);
            }
          }
        };
        for (var i = 0; i < markers.length; i++) loop(i);
      }
      var nextDocId = 0;
      var Doc = function (text, mode, firstLine, lineSep) {
        if (!(this instanceof Doc)) {
          return new Doc(text, mode, firstLine, lineSep);
        }
        if (firstLine == null) {
          firstLine = 0;
        }
        BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.frontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        this.lineSep = lineSep;
        this.extend = false;
        if (typeof text == "string") {
          text = this.splitLines(text);
        }
        updateDoc(this, {
          from: start,
          to: start,
          text: text
        });
        setSelection(this, simpleSelection(start), sel_dontScroll);
      };
      Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function (from, to, op) {
          if (op) {
            this.iterN(from - this.first, to - from, op);
          } else {
            this.iterN(this.first, this.first + this.size, from);
          }
        },
        insert: function (at, lines) {
          var height = 0;
          for (var i = 0; i < lines.length; ++i) {
            height += lines[i].height;
          }
          this.insertInner(at - this.first, lines, height);
        },
        remove: function (at, n) {
          this.removeInner(at - this.first, n);
        },
        getValue: function (lineSep) {
          var lines = getLines(this, this.first, this.first + this.size);
          if (lineSep === false) {
            return lines;
          }
          return lines.join(lineSep || this.lineSeparator());
        },
        setValue: docMethodOp(function (code) {
          var top = Pos(this.first, 0),
              last = this.first + this.size - 1;
          makeChange(this, {
            from: top,
            to: Pos(last, getLine(this, last).text.length),
            text: this.splitLines(code),
            origin: "setValue",
            full: true
          }, true);
          setSelection(this, simpleSelection(top));
        }),
        replaceRange: function (code, from, to, origin) {
          from = clipPos(this, from);
          to = to ? clipPos(this, to) : from;
          replaceRange(this, code, from, to, origin);
        },
        getRange: function (from, to, lineSep) {
          var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
          if (lineSep === false) {
            return lines;
          }
          return lines.join(lineSep || this.lineSeparator());
        },
        getLine: function (line) {
          var l = this.getLineHandle(line);
          return l && l.text;
        },
        getLineHandle: function (line) {
          if (isLine(this, line)) {
            return getLine(this, line);
          }
        },
        getLineNumber: function (line) {
          return lineNo(line);
        },
        getLineHandleVisualStart: function (line) {
          if (typeof line == "number") {
            line = getLine(this, line);
          }
          return visualLine(line);
        },
        lineCount: function () {
          return this.size;
        },
        firstLine: function () {
          return this.first;
        },
        lastLine: function () {
          return this.first + this.size - 1;
        },
        clipPos: function (pos) {
          return clipPos(this, pos);
        },
        getCursor: function (start) {
          var range = this.sel.primary(),
              pos;
          if (start == null || start == "head") {
            pos = range.head;
          } else if (start == "anchor") {
            pos = range.anchor;
          } else if (start == "end" || start == "to" || start === false) {
            pos = range.to();
          } else {
            pos = range.from();
          }
          return pos;
        },
        listSelections: function () {
          return this.sel.ranges;
        },
        somethingSelected: function () {
          return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function (line, ch, options) {
          setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function (anchor, head, options) {
          setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function (head, other, options) {
          extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function (heads, options) {
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: docMethodOp(function (f, options) {
          var heads = map(this.sel.ranges, f);
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        setSelections: docMethodOp(function (ranges, primary, options) {
          var this$1 = this;
          if (!ranges.length) {
            return;
          }
          var out = [];
          for (var i = 0; i < ranges.length; i++) {
            out[i] = new Range(clipPos(this$1, ranges[i].anchor), clipPos(this$1, ranges[i].head));
          }
          if (primary == null) {
            primary = Math.min(ranges.length - 1, this.sel.primIndex);
          }
          setSelection(this, normalizeSelection(out, primary), options);
        }),
        addSelection: docMethodOp(function (anchor, head, options) {
          var ranges = this.sel.ranges.slice(0);
          ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
          setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
        }),
        getSelection: function (lineSep) {
          var this$1 = this;
          var ranges = this.sel.ranges,
              lines;
          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
            lines = lines ? lines.concat(sel) : sel;
          }
          if (lineSep === false) {
            return lines;
          } else {
            return lines.join(lineSep || this.lineSeparator());
          }
        },
        getSelections: function (lineSep) {
          var this$1 = this;
          var parts = [],
              ranges = this.sel.ranges;
          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
            if (lineSep !== false) {
              sel = sel.join(lineSep || this$1.lineSeparator());
            }
            parts[i] = sel;
          }
          return parts;
        },
        replaceSelection: function (code, collapse, origin) {
          var dup = [];
          for (var i = 0; i < this.sel.ranges.length; i++) {
            dup[i] = code;
          }
          this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function (code, collapse, origin) {
          var this$1 = this;
          var changes = [],
              sel = this.sel;
          for (var i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i];
            changes[i] = {
              from: range.from(),
              to: range.to(),
              text: this$1.splitLines(code[i]),
              origin: origin
            };
          }
          var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
          for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {
            makeChange(this$1, changes[i$1]);
          }
          if (newSel) {
            setSelectionReplaceHistory(this, newSel);
          } else if (this.cm) {
            ensureCursorVisible(this.cm);
          }
        }),
        undo: docMethodOp(function () {
          makeChangeFromHistory(this, "undo");
        }),
        redo: docMethodOp(function () {
          makeChangeFromHistory(this, "redo");
        }),
        undoSelection: docMethodOp(function () {
          makeChangeFromHistory(this, "undo", true);
        }),
        redoSelection: docMethodOp(function () {
          makeChangeFromHistory(this, "redo", true);
        }),
        setExtending: function (val) {
          this.extend = val;
        },
        getExtending: function () {
          return this.extend;
        },
        historySize: function () {
          var hist = this.history,
              done = 0,
              undone = 0;
          for (var i = 0; i < hist.done.length; i++) {
            if (!hist.done[i].ranges) {
              ++done;
            }
          }
          for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {
            if (!hist.undone[i$1].ranges) {
              ++undone;
            }
          }
          return {
            undo: done,
            redo: undone
          };
        },
        clearHistory: function () {
          this.history = new History(this.history.maxGeneration);
        },
        markClean: function () {
          this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function (forceSplit) {
          if (forceSplit) {
            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
          }
          return this.history.generation;
        },
        isClean: function (gen) {
          return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function () {
          return {
            done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone)
          };
        },
        setHistory: function (histData) {
          var hist = this.history = new History(this.history.maxGeneration);
          hist.done = copyHistoryArray(histData.done.slice(0), null, true);
          hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },
        setGutterMarker: docMethodOp(function (line, gutterID, value) {
          return changeLine(this, line, "gutter", function (line) {
            var markers = line.gutterMarkers || (line.gutterMarkers = {});
            markers[gutterID] = value;
            if (!value && isEmpty(markers)) {
              line.gutterMarkers = null;
            }
            return true;
          });
        }),
        clearGutter: docMethodOp(function (gutterID) {
          var this$1 = this;
          var i = this.first;
          this.iter(function (line) {
            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
              changeLine(this$1, line, "gutter", function () {
                line.gutterMarkers[gutterID] = null;
                if (isEmpty(line.gutterMarkers)) {
                  line.gutterMarkers = null;
                }
                return true;
              });
            }
            ++i;
          });
        }),
        lineInfo: function (line) {
          var n;
          if (typeof line == "number") {
            if (!isLine(this, line)) {
              return null;
            }
            n = line;
            line = getLine(this, line);
            if (!line) {
              return null;
            }
          } else {
            n = lineNo(line);
            if (n == null) {
              return null;
            }
          }
          return {
            line: n,
            handle: line,
            text: line.text,
            gutterMarkers: line.gutterMarkers,
            textClass: line.textClass,
            bgClass: line.bgClass,
            wrapClass: line.wrapClass,
            widgets: line.widgets
          };
        },
        addLineClass: docMethodOp(function (handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            if (!line[prop]) {
              line[prop] = cls;
            } else if (classTest(cls).test(line[prop])) {
              return false;
            } else {
              line[prop] += " " + cls;
            }
            return true;
          });
        }),
        removeLineClass: docMethodOp(function (handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            var cur = line[prop];
            if (!cur) {
              return false;
            } else if (cls == null) {
              line[prop] = null;
            } else {
              var found = cur.match(classTest(cls));
              if (!found) {
                return false;
              }
              var end = found.index + found[0].length;
              line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
            }
            return true;
          });
        }),
        addLineWidget: docMethodOp(function (handle, node, options) {
          return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function (widget) {
          widget.clear();
        },
        markText: function (from, to, options) {
          return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
        },
        setBookmark: function (pos, options) {
          var realOpts = {
            replacedWith: options && (options.nodeType == null ? options.widget : options),
            insertLeft: options && options.insertLeft,
            clearWhenEmpty: false,
            shared: options && options.shared,
            handleMouseEvents: options && options.handleMouseEvents
          };
          pos = clipPos(this, pos);
          return markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function (pos) {
          pos = clipPos(this, pos);
          var markers = [],
              spans = getLine(this, pos.line).markedSpans;
          if (spans) {
            for (var i = 0; i < spans.length; ++i) {
              var span = spans[i];
              if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                markers.push(span.marker.parent || span.marker);
              }
            }
          }
          return markers;
        },
        findMarks: function (from, to, filter) {
          from = clipPos(this, from);
          to = clipPos(this, to);
          var found = [],
              lineNo = from.line;
          this.iter(from.line, to.line + 1, function (line) {
            var spans = line.markedSpans;
            if (spans) {
              for (var i = 0; i < spans.length; i++) {
                var span = spans[i];
                if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                  found.push(span.marker.parent || span.marker);
                }
              }
            }
            ++lineNo;
          });
          return found;
        },
        getAllMarks: function () {
          var markers = [];
          this.iter(function (line) {
            var sps = line.markedSpans;
            if (sps) {
              for (var i = 0; i < sps.length; ++i) {
                if (sps[i].from != null) {
                  markers.push(sps[i].marker);
                }
              }
            }
          });
          return markers;
        },
        posFromIndex: function (off) {
          var ch,
              lineNo = this.first,
              sepSize = this.lineSeparator().length;
          this.iter(function (line) {
            var sz = line.text.length + sepSize;
            if (sz > off) {
              ch = off;
              return true;
            }
            off -= sz;
            ++lineNo;
          });
          return clipPos(this, Pos(lineNo, ch));
        },
        indexFromPos: function (coords) {
          coords = clipPos(this, coords);
          var index = coords.ch;
          if (coords.line < this.first || coords.ch < 0) {
            return 0;
          }
          var sepSize = this.lineSeparator().length;
          this.iter(this.first, coords.line, function (line) {
            index += line.text.length + sepSize;
          });
          return index;
        },
        copy: function (copyHistory) {
          var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep);
          doc.scrollTop = this.scrollTop;
          doc.scrollLeft = this.scrollLeft;
          doc.sel = this.sel;
          doc.extend = false;
          if (copyHistory) {
            doc.history.undoDepth = this.history.undoDepth;
            doc.setHistory(this.getHistory());
          }
          return doc;
        },
        linkedDoc: function (options) {
          if (!options) {
            options = {};
          }
          var from = this.first,
              to = this.first + this.size;
          if (options.from != null && options.from > from) {
            from = options.from;
          }
          if (options.to != null && options.to < to) {
            to = options.to;
          }
          var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
          if (options.sharedHist) {
            copy.history = this.history;
            ;
          }
          (this.linked || (this.linked = [])).push({
            doc: copy,
            sharedHist: options.sharedHist
          });
          copy.linked = [{
            doc: this,
            isParent: true,
            sharedHist: options.sharedHist
          }];
          copySharedMarkers(copy, findSharedMarkers(this));
          return copy;
        },
        unlinkDoc: function (other) {
          var this$1 = this;
          if (other instanceof CodeMirror) {
            other = other.doc;
          }
          if (this.linked) {
            for (var i = 0; i < this.linked.length; ++i) {
              var link = this$1.linked[i];
              if (link.doc != other) {
                continue;
              }
              this$1.linked.splice(i, 1);
              other.unlinkDoc(this$1);
              detachSharedMarkers(findSharedMarkers(this$1));
              break;
            }
          }
          if (other.history == this.history) {
            var splitIds = [other.id];
            linkedDocs(other, function (doc) {
              return splitIds.push(doc.id);
            }, true);
            other.history = new History(null);
            other.history.done = copyHistoryArray(this.history.done, splitIds);
            other.history.undone = copyHistoryArray(this.history.undone, splitIds);
          }
        },
        iterLinkedDocs: function (f) {
          linkedDocs(this, f);
        },
        getMode: function () {
          return this.mode;
        },
        getEditor: function () {
          return this.cm;
        },
        splitLines: function (str) {
          if (this.lineSep) {
            return str.split(this.lineSep);
          }
          return splitLinesAuto(str);
        },
        lineSeparator: function () {
          return this.lineSep || "\n";
        }
      });
      Doc.prototype.eachLine = Doc.prototype.iter;
      var lastDrop = 0;
      function onDrop(e) {
        var cm = this;
        clearDragCursor(cm);
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e_preventDefault(e);
        if (ie) {
          lastDrop = +new Date();
        }
        var pos = posFromMouse(cm, e, true),
            files = e.dataTransfer.files;
        if (!pos || cm.isReadOnly()) {
          return;
        }
        if (files && files.length && window.FileReader && window.File) {
          var n = files.length,
              text = Array(n),
              read = 0;
          var loadFile = function (file, i) {
            if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
              return;
            }
            var reader = new FileReader();
            reader.onload = operation(cm, function () {
              var content = reader.result;
              if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                content = "";
              }
              text[i] = content;
              if (++read == n) {
                pos = clipPos(cm.doc, pos);
                var change = {
                  from: pos,
                  to: pos,
                  text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                  origin: "paste"
                };
                makeChange(cm.doc, change);
                setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
              }
            });
            reader.readAsText(file);
          };
          for (var i = 0; i < n; ++i) {
            loadFile(files[i], i);
          }
        } else {
          if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
            cm.state.draggingText(e);
            setTimeout(function () {
              return cm.display.input.focus();
            }, 20);
            return;
          }
          try {
            var text$1 = e.dataTransfer.getData("Text");
            if (text$1) {
              var selected;
              if (cm.state.draggingText && !cm.state.draggingText.copy) {
                selected = cm.listSelections();
              }
              setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
              if (selected) {
                for (var i$1 = 0; i$1 < selected.length; ++i$1) {
                  replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
                }
              }
              cm.replaceSelection(text$1, "around", "paste");
              cm.display.input.focus();
            }
          } catch (e) {}
        }
      }
      function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
          e_stop(e);
          return;
        }
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e.dataTransfer.setData("Text", cm.getSelection());
        e.dataTransfer.effectAllowed = "copyMove";
        if (e.dataTransfer.setDragImage && !safari) {
          var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
          img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          if (presto) {
            img.width = img.height = 1;
            cm.display.wrapper.appendChild(img);
            img._top = img.offsetTop;
          }
          e.dataTransfer.setDragImage(img, 0, 0);
          if (presto) {
            img.parentNode.removeChild(img);
          }
        }
      }
      function onDragOver(cm, e) {
        var pos = posFromMouse(cm, e);
        if (!pos) {
          return;
        }
        var frag = document.createDocumentFragment();
        drawSelectionCursor(cm, pos, frag);
        if (!cm.display.dragCursor) {
          cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
          cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
        }
        removeChildrenAndAdd(cm.display.dragCursor, frag);
      }
      function clearDragCursor(cm) {
        if (cm.display.dragCursor) {
          cm.display.lineSpace.removeChild(cm.display.dragCursor);
          cm.display.dragCursor = null;
        }
      }
      function forEachCodeMirror(f) {
        if (!document.body.getElementsByClassName) {
          return;
        }
        var byClass = document.body.getElementsByClassName("CodeMirror");
        for (var i = 0; i < byClass.length; i++) {
          var cm = byClass[i].CodeMirror;
          if (cm) {
            f(cm);
          }
        }
      }
      var globalsRegistered = false;
      function ensureGlobalHandlers() {
        if (globalsRegistered) {
          return;
        }
        registerGlobalHandlers();
        globalsRegistered = true;
      }
      function registerGlobalHandlers() {
        var resizeTimer;
        on(window, "resize", function () {
          if (resizeTimer == null) {
            resizeTimer = setTimeout(function () {
              resizeTimer = null;
              forEachCodeMirror(onResize);
            }, 100);
          }
        });
        on(window, "blur", function () {
          return forEachCodeMirror(onBlur);
        });
      }
      function onResize(cm) {
        var d = cm.display;
        if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth) {
          return;
        }
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.scrollbarsClipped = false;
        cm.setSize();
      }
      var keyNames = {
        3: "Enter",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        127: "Delete",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      };
      for (var i = 0; i < 10; i++) {
        keyNames[i + 48] = keyNames[i + 96] = String(i);
      }
      for (var i$1 = 65; i$1 <= 90; i$1++) {
        keyNames[i$1] = String.fromCharCode(i$1);
      }
      for (var i$2 = 1; i$2 <= 12; i$2++) {
        keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
      }
      var keyMap = {};
      keyMap.basic = {
        "Left": "goCharLeft",
        "Right": "goCharRight",
        "Up": "goLineUp",
        "Down": "goLineDown",
        "End": "goLineEnd",
        "Home": "goLineStartSmart",
        "PageUp": "goPageUp",
        "PageDown": "goPageDown",
        "Delete": "delCharAfter",
        "Backspace": "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab",
        "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent",
        "Insert": "toggleOverwrite",
        "Esc": "singleSelection"
      };
      keyMap.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        fallthrough: "basic"
      };
      keyMap.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Alt-F": "goWordRight",
        "Alt-B": "goWordLeft",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-D": "delWordAfter",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
      };
      keyMap.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        fallthrough: ["basic", "emacsy"]
      };
      keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
      function normalizeKeyName(name) {
        var parts = name.split(/-(?!$)/);
        name = parts[parts.length - 1];
        var alt, ctrl, shift, cmd;
        for (var i = 0; i < parts.length - 1; i++) {
          var mod = parts[i];
          if (/^(cmd|meta|m)$/i.test(mod)) {
            cmd = true;
          } else if (/^a(lt)?$/i.test(mod)) {
            alt = true;
          } else if (/^(c|ctrl|control)$/i.test(mod)) {
            ctrl = true;
          } else if (/^s(hift)?$/i.test(mod)) {
            shift = true;
          } else {
            throw new Error("Unrecognized modifier name: " + mod);
          }
        }
        if (alt) {
          name = "Alt-" + name;
        }
        if (ctrl) {
          name = "Ctrl-" + name;
        }
        if (cmd) {
          name = "Cmd-" + name;
        }
        if (shift) {
          name = "Shift-" + name;
        }
        return name;
      }
      function normalizeKeyMap(keymap) {
        var copy = {};
        for (var keyname in keymap) {
          if (keymap.hasOwnProperty(keyname)) {
            var value = keymap[keyname];
            if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
              continue;
            }
            if (value == "...") {
              delete keymap[keyname];
              continue;
            }
            var keys = map(keyname.split(" "), normalizeKeyName);
            for (var i = 0; i < keys.length; i++) {
              var val = void 0,
                  name = void 0;
              if (i == keys.length - 1) {
                name = keys.join(" ");
                val = value;
              } else {
                name = keys.slice(0, i + 1).join(" ");
                val = "...";
              }
              var prev = copy[name];
              if (!prev) {
                copy[name] = val;
              } else if (prev != val) {
                throw new Error("Inconsistent bindings for " + name);
              }
            }
            delete keymap[keyname];
          }
        }
        for (var prop in copy) {
          keymap[prop] = copy[prop];
        }
        return keymap;
      }
      function lookupKey(key, map, handle, context) {
        map = getKeyMap(map);
        var found = map.call ? map.call(key, context) : map[key];
        if (found === false) {
          return "nothing";
        }
        if (found === "...") {
          return "multi";
        }
        if (found != null && handle(found)) {
          return "handled";
        }
        if (map.fallthrough) {
          if (Object.prototype.toString.call(map.fallthrough) != "[object Array]") {
            return lookupKey(key, map.fallthrough, handle, context);
          }
          for (var i = 0; i < map.fallthrough.length; i++) {
            var result = lookupKey(key, map.fallthrough[i], handle, context);
            if (result) {
              return result;
            }
          }
        }
      }
      function isModifierKey(value) {
        var name = typeof value == "string" ? value : keyNames[value.keyCode];
        return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
      }
      function keyName(event, noShift) {
        if (presto && event.keyCode == 34 && event["char"]) {
          return false;
        }
        var base = keyNames[event.keyCode],
            name = base;
        if (name == null || event.altGraphKey) {
          return false;
        }
        if (event.altKey && base != "Alt") {
          name = "Alt-" + name;
        }
        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
          name = "Ctrl-" + name;
        }
        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") {
          name = "Cmd-" + name;
        }
        if (!noShift && event.shiftKey && base != "Shift") {
          name = "Shift-" + name;
        }
        return name;
      }
      function getKeyMap(val) {
        return typeof val == "string" ? keyMap[val] : val;
      }
      function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges,
            kill = [];
        for (var i = 0; i < ranges.length; i++) {
          var toKill = compute(ranges[i]);
          while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
            var replaced = kill.pop();
            if (cmp(replaced.from, toKill.from) < 0) {
              toKill.from = replaced.from;
              break;
            }
          }
          kill.push(toKill);
        }
        runInOp(cm, function () {
          for (var i = kill.length - 1; i >= 0; i--) {
            replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
          }
          ensureCursorVisible(cm);
        });
      }
      var commands = {
        selectAll: selectAll,
        singleSelection: function (cm) {
          return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
        },
        killLine: function (cm) {
          return deleteNearSelection(cm, function (range) {
            if (range.empty()) {
              var len = getLine(cm.doc, range.head.line).text.length;
              if (range.head.ch == len && range.head.line < cm.lastLine()) {
                return {
                  from: range.head,
                  to: Pos(range.head.line + 1, 0)
                };
              } else {
                return {
                  from: range.head,
                  to: Pos(range.head.line, len)
                };
              }
            } else {
              return {
                from: range.from(),
                to: range.to()
              };
            }
          });
        },
        deleteLine: function (cm) {
          return deleteNearSelection(cm, function (range) {
            return {
              from: Pos(range.from().line, 0),
              to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
            };
          });
        },
        delLineLeft: function (cm) {
          return deleteNearSelection(cm, function (range) {
            return {
              from: Pos(range.from().line, 0),
              to: range.from()
            };
          });
        },
        delWrappedLineLeft: function (cm) {
          return deleteNearSelection(cm, function (range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var leftPos = cm.coordsChar({
              left: 0,
              top: top
            }, "div");
            return {
              from: leftPos,
              to: range.from()
            };
          });
        },
        delWrappedLineRight: function (cm) {
          return deleteNearSelection(cm, function (range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var rightPos = cm.coordsChar({
              left: cm.display.lineDiv.offsetWidth + 100,
              top: top
            }, "div");
            return {
              from: range.from(),
              to: rightPos
            };
          });
        },
        undo: function (cm) {
          return cm.undo();
        },
        redo: function (cm) {
          return cm.redo();
        },
        undoSelection: function (cm) {
          return cm.undoSelection();
        },
        redoSelection: function (cm) {
          return cm.redoSelection();
        },
        goDocStart: function (cm) {
          return cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function (cm) {
          return cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function (cm) {
          return cm.extendSelectionsBy(function (range) {
            return lineStart(cm, range.head.line);
          }, {
            origin: "+move",
            bias: 1
          });
        },
        goLineStartSmart: function (cm) {
          return cm.extendSelectionsBy(function (range) {
            return lineStartSmart(cm, range.head);
          }, {
            origin: "+move",
            bias: 1
          });
        },
        goLineEnd: function (cm) {
          return cm.extendSelectionsBy(function (range) {
            return lineEnd(cm, range.head.line);
          }, {
            origin: "+move",
            bias: -1
          });
        },
        goLineRight: function (cm) {
          return cm.extendSelectionsBy(function (range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            return cm.coordsChar({
              left: cm.display.lineDiv.offsetWidth + 100,
              top: top
            }, "div");
          }, sel_move);
        },
        goLineLeft: function (cm) {
          return cm.extendSelectionsBy(function (range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            return cm.coordsChar({
              left: 0,
              top: top
            }, "div");
          }, sel_move);
        },
        goLineLeftSmart: function (cm) {
          return cm.extendSelectionsBy(function (range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var pos = cm.coordsChar({
              left: 0,
              top: top
            }, "div");
            if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
              return lineStartSmart(cm, range.head);
            }
            return pos;
          }, sel_move);
        },
        goLineUp: function (cm) {
          return cm.moveV(-1, "line");
        },
        goLineDown: function (cm) {
          return cm.moveV(1, "line");
        },
        goPageUp: function (cm) {
          return cm.moveV(-1, "page");
        },
        goPageDown: function (cm) {
          return cm.moveV(1, "page");
        },
        goCharLeft: function (cm) {
          return cm.moveH(-1, "char");
        },
        goCharRight: function (cm) {
          return cm.moveH(1, "char");
        },
        goColumnLeft: function (cm) {
          return cm.moveH(-1, "column");
        },
        goColumnRight: function (cm) {
          return cm.moveH(1, "column");
        },
        goWordLeft: function (cm) {
          return cm.moveH(-1, "word");
        },
        goGroupRight: function (cm) {
          return cm.moveH(1, "group");
        },
        goGroupLeft: function (cm) {
          return cm.moveH(-1, "group");
        },
        goWordRight: function (cm) {
          return cm.moveH(1, "word");
        },
        delCharBefore: function (cm) {
          return cm.deleteH(-1, "char");
        },
        delCharAfter: function (cm) {
          return cm.deleteH(1, "char");
        },
        delWordBefore: function (cm) {
          return cm.deleteH(-1, "word");
        },
        delWordAfter: function (cm) {
          return cm.deleteH(1, "word");
        },
        delGroupBefore: function (cm) {
          return cm.deleteH(-1, "group");
        },
        delGroupAfter: function (cm) {
          return cm.deleteH(1, "group");
        },
        indentAuto: function (cm) {
          return cm.indentSelection("smart");
        },
        indentMore: function (cm) {
          return cm.indentSelection("add");
        },
        indentLess: function (cm) {
          return cm.indentSelection("subtract");
        },
        insertTab: function (cm) {
          return cm.replaceSelection("\t");
        },
        insertSoftTab: function (cm) {
          var spaces = [],
              ranges = cm.listSelections(),
              tabSize = cm.options.tabSize;
          for (var i = 0; i < ranges.length; i++) {
            var pos = ranges[i].from();
            var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
            spaces.push(spaceStr(tabSize - col % tabSize));
          }
          cm.replaceSelections(spaces);
        },
        defaultTab: function (cm) {
          if (cm.somethingSelected()) {
            cm.indentSelection("add");
          } else {
            cm.execCommand("insertTab");
          }
        },
        transposeChars: function (cm) {
          return runInOp(cm, function () {
            var ranges = cm.listSelections(),
                newSel = [];
            for (var i = 0; i < ranges.length; i++) {
              if (!ranges[i].empty()) {
                continue;
              }
              var cur = ranges[i].head,
                  line = getLine(cm.doc, cur.line).text;
              if (line) {
                if (cur.ch == line.length) {
                  cur = new Pos(cur.line, cur.ch - 1);
                }
                if (cur.ch > 0) {
                  cur = new Pos(cur.line, cur.ch + 1);
                  cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                } else if (cur.line > cm.doc.first) {
                  var prev = getLine(cm.doc, cur.line - 1).text;
                  if (prev) {
                    cur = new Pos(cur.line, 1);
                    cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                  }
                }
              }
              newSel.push(new Range(cur, cur));
            }
            cm.setSelections(newSel);
          });
        },
        newlineAndIndent: function (cm) {
          return runInOp(cm, function () {
            var sels = cm.listSelections();
            for (var i = sels.length - 1; i >= 0; i--) {
              cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
            }
            sels = cm.listSelections();
            for (var i$1 = 0; i$1 < sels.length; i$1++) {
              cm.indentLine(sels[i$1].from().line, null, true);
            }
            ensureCursorVisible(cm);
          });
        },
        openLine: function (cm) {
          return cm.replaceSelection("\n", "start");
        },
        toggleOverwrite: function (cm) {
          return cm.toggleOverwrite();
        }
      };
      function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(line);
        if (visual != line) {
          lineN = lineNo(visual);
        }
        var order = getOrder(visual);
        var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
        return Pos(lineN, ch);
      }
      function lineEnd(cm, lineN) {
        var merged,
            line = getLine(cm.doc, lineN);
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
          lineN = null;
        }
        var order = getOrder(line);
        var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
        return Pos(lineN == null ? lineNo(line) : lineN, ch);
      }
      function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line);
        var line = getLine(cm.doc, start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
          return Pos(start.line, inWS ? 0 : firstNonWS);
        }
        return start;
      }
      function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
          bound = commands[bound];
          if (!bound) {
            return false;
          }
        }
        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift,
            done = false;
        try {
          if (cm.isReadOnly()) {
            cm.state.suppressEdits = true;
          }
          if (dropShift) {
            cm.display.shift = false;
          }
          done = bound(cm) != Pass;
        } finally {
          cm.display.shift = prevShift;
          cm.state.suppressEdits = false;
        }
        return done;
      }
      function lookupKeyForEditor(cm, name, handle) {
        for (var i = 0; i < cm.state.keyMaps.length; i++) {
          var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
          if (result) {
            return result;
          }
        }
        return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
      }
      var stopSeq = new Delayed();
      function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
          if (isModifierKey(name)) {
            return "handled";
          }
          stopSeq.set(50, function () {
            if (cm.state.keySeq == seq) {
              cm.state.keySeq = null;
              cm.display.input.reset();
            }
          });
          name = seq + " " + name;
        }
        var result = lookupKeyForEditor(cm, name, handle);
        if (result == "multi") {
          cm.state.keySeq = name;
        }
        if (result == "handled") {
          signalLater(cm, "keyHandled", cm, name, e);
        }
        if (result == "handled" || result == "multi") {
          e_preventDefault(e);
          restartBlink(cm);
        }
        if (seq && !result && /\'$/.test(name)) {
          e_preventDefault(e);
          return true;
        }
        return !!result;
      }
      function handleKeyBinding(cm, e) {
        var name = keyName(e, true);
        if (!name) {
          return false;
        }
        if (e.shiftKey && !cm.state.keySeq) {
          return dispatchKey(cm, "Shift-" + name, e, function (b) {
            return doHandleBinding(cm, b, true);
          }) || dispatchKey(cm, name, e, function (b) {
            if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
              return doHandleBinding(cm, b);
            }
          });
        } else {
          return dispatchKey(cm, name, e, function (b) {
            return doHandleBinding(cm, b);
          });
        }
      }
      function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function (b) {
          return doHandleBinding(cm, b, true);
        });
      }
      var lastStoppedKey = null;
      function onKeyDown(e) {
        var cm = this;
        cm.curOp.focus = activeElt();
        if (signalDOMEvent(cm, e)) {
          return;
        }
        if (ie && ie_version < 11 && e.keyCode == 27) {
          e.returnValue = false;
        }
        var code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        var handled = handleKeyBinding(cm, e);
        if (presto) {
          lastStoppedKey = handled ? code : null;
          if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
            cm.replaceSelection("", null, "cut");
          }
        }
        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
          showCrossHair(cm);
        }
      }
      function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair");
        function up(e) {
          if (e.keyCode == 18 || !e.altKey) {
            rmClass(lineDiv, "CodeMirror-crosshair");
            off(document, "keyup", up);
            off(document, "mouseover", up);
          }
        }
        on(document, "keyup", up);
        on(document, "mouseover", up);
      }
      function onKeyUp(e) {
        if (e.keyCode == 16) {
          this.doc.sel.shift = false;
        }
        signalDOMEvent(this, e);
      }
      function onKeyPress(e) {
        var cm = this;
        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
          return;
        }
        var keyCode = e.keyCode,
            charCode = e.charCode;
        if (presto && keyCode == lastStoppedKey) {
          lastStoppedKey = null;
          e_preventDefault(e);
          return;
        }
        if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
          return;
        }
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (ch == "\x08") {
          return;
        }
        if (handleCharBinding(cm, e, ch)) {
          return;
        }
        cm.display.input.onKeyPress(e);
      }
      function onMouseDown(e) {
        var cm = this,
            display = cm.display;
        if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
          return;
        }
        display.input.ensurePolled();
        display.shift = e.shiftKey;
        if (eventInWidget(display, e)) {
          if (!webkit) {
            display.scroller.draggable = false;
            setTimeout(function () {
              return display.scroller.draggable = true;
            }, 100);
          }
          return;
        }
        if (clickInGutter(cm, e)) {
          return;
        }
        var start = posFromMouse(cm, e);
        window.focus();
        switch (e_button(e)) {
          case 1:
            if (cm.state.selectingText) {
              cm.state.selectingText(e);
            } else if (start) {
              leftButtonDown(cm, e, start);
            } else if (e_target(e) == display.scroller) {
              e_preventDefault(e);
            }
            break;
          case 2:
            if (webkit) {
              cm.state.lastMiddleDown = +new Date();
            }
            if (start) {
              extendSelection(cm.doc, start);
            }
            setTimeout(function () {
              return display.input.focus();
            }, 20);
            e_preventDefault(e);
            break;
          case 3:
            if (captureRightClick) {
              onContextMenu(cm, e);
            } else {
              delayBlurEvent(cm);
            }
            break;
        }
      }
      var lastClick;
      var lastDoubleClick;
      function leftButtonDown(cm, e, start) {
        if (ie) {
          setTimeout(bind(ensureFocus, cm), 0);
        } else {
          cm.curOp.focus = activeElt();
        }
        var now = +new Date(),
            type;
        if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
          type = "triple";
        } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
          type = "double";
          lastDoubleClick = {
            time: now,
            pos: start
          };
        } else {
          type = "single";
          lastClick = {
            time: now,
            pos: start
          };
        }
        var sel = cm.doc.sel,
            modifier = mac ? e.metaKey : e.ctrlKey,
            contained;
        if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && type == "single" && (contained = sel.contains(start)) > -1 && (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) && (cmp(contained.to(), start) > 0 || start.xRel < 0)) {
          leftButtonStartDrag(cm, e, start, modifier);
        } else {
          leftButtonSelect(cm, e, start, type, modifier);
        }
      }
      function leftButtonStartDrag(cm, e, start, modifier) {
        var display = cm.display,
            startTime = +new Date();
        var dragEnd = operation(cm, function (e2) {
          if (webkit) {
            display.scroller.draggable = false;
          }
          cm.state.draggingText = false;
          off(document, "mouseup", dragEnd);
          off(display.scroller, "drop", dragEnd);
          if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
            e_preventDefault(e2);
            if (!modifier && +new Date() - 200 < startTime) {
              extendSelection(cm.doc, start);
            }
            if (webkit || ie && ie_version == 9) {
              setTimeout(function () {
                document.body.focus();
                display.input.focus();
              }, 20);
            } else {
              display.input.focus();
            }
          }
        });
        if (webkit) {
          display.scroller.draggable = true;
        }
        cm.state.draggingText = dragEnd;
        dragEnd.copy = mac ? e.altKey : e.ctrlKey;
        if (display.scroller.dragDrop) {
          display.scroller.dragDrop();
        }
        on(document, "mouseup", dragEnd);
        on(display.scroller, "drop", dragEnd);
      }
      function leftButtonSelect(cm, e, start, type, addNew) {
        var display = cm.display,
            doc = cm.doc;
        e_preventDefault(e);
        var ourRange,
            ourIndex,
            startSel = doc.sel,
            ranges = startSel.ranges;
        if (addNew && !e.shiftKey) {
          ourIndex = doc.sel.contains(start);
          if (ourIndex > -1) {
            ourRange = ranges[ourIndex];
          } else {
            ourRange = new Range(start, start);
          }
        } else {
          ourRange = doc.sel.primary();
          ourIndex = doc.sel.primIndex;
        }
        if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
          type = "rect";
          if (!addNew) {
            ourRange = new Range(start, start);
          }
          start = posFromMouse(cm, e, true, true);
          ourIndex = -1;
        } else if (type == "double") {
          var word = cm.findWordAt(start);
          if (cm.display.shift || doc.extend) {
            ourRange = extendRange(doc, ourRange, word.anchor, word.head);
          } else {
            ourRange = word;
          }
        } else if (type == "triple") {
          var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
          if (cm.display.shift || doc.extend) {
            ourRange = extendRange(doc, ourRange, line.anchor, line.head);
          } else {
            ourRange = line;
          }
        } else {
          ourRange = extendRange(doc, ourRange, start);
        }
        if (!addNew) {
          ourIndex = 0;
          setSelection(doc, new Selection([ourRange], 0), sel_mouse);
          startSel = doc.sel;
        } else if (ourIndex == -1) {
          ourIndex = ranges.length;
          setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex), {
            scroll: false,
            origin: "*mouse"
          });
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
          setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
            scroll: false,
            origin: "*mouse"
          });
          startSel = doc.sel;
        } else {
          replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
        }
        var lastPos = start;
        function extendTo(pos) {
          if (cmp(lastPos, pos) == 0) {
            return;
          }
          lastPos = pos;
          if (type == "rect") {
            var ranges = [],
                tabSize = cm.options.tabSize;
            var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
            var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
            var left = Math.min(startCol, posCol),
                right = Math.max(startCol, posCol);
            for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
              var text = getLine(doc, line).text,
                  leftPos = findColumn(text, left, tabSize);
              if (left == right) {
                ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
              } else if (text.length > leftPos) {
                ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
              }
            }
            if (!ranges.length) {
              ranges.push(new Range(start, start));
            }
            setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
              origin: "*mouse",
              scroll: false
            });
            cm.scrollIntoView(pos);
          } else {
            var oldRange = ourRange;
            var anchor = oldRange.anchor,
                head = pos;
            if (type != "single") {
              var range;
              if (type == "double") {
                range = cm.findWordAt(pos);
              } else {
                range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
              }
              if (cmp(range.anchor, anchor) > 0) {
                head = range.head;
                anchor = minPos(oldRange.from(), range.anchor);
              } else {
                head = range.anchor;
                anchor = maxPos(oldRange.to(), range.head);
              }
            }
            var ranges$1 = startSel.ranges.slice(0);
            ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head);
            setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
          }
        }
        var editorSize = display.wrapper.getBoundingClientRect();
        var counter = 0;
        function extend(e) {
          var curCount = ++counter;
          var cur = posFromMouse(cm, e, true, type == "rect");
          if (!cur) {
            return;
          }
          if (cmp(cur, lastPos) != 0) {
            cm.curOp.focus = activeElt();
            extendTo(cur);
            var visible = visibleLines(display, doc);
            if (cur.line >= visible.to || cur.line < visible.from) {
              setTimeout(operation(cm, function () {
                if (counter == curCount) {
                  extend(e);
                }
              }), 150);
            }
          } else {
            var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
            if (outside) {
              setTimeout(operation(cm, function () {
                if (counter != curCount) {
                  return;
                }
                display.scroller.scrollTop += outside;
                extend(e);
              }), 50);
            }
          }
        }
        function done(e) {
          cm.state.selectingText = false;
          counter = Infinity;
          e_preventDefault(e);
          display.input.focus();
          off(document, "mousemove", move);
          off(document, "mouseup", up);
          doc.history.lastSelOrigin = null;
        }
        var move = operation(cm, function (e) {
          if (!e_button(e)) {
            done(e);
          } else {
            extend(e);
          }
        });
        var up = operation(cm, done);
        cm.state.selectingText = up;
        on(document, "mousemove", move);
        on(document, "mouseup", up);
      }
      function gutterEvent(cm, e, type, prevent) {
        var mX, mY;
        try {
          mX = e.clientX;
          mY = e.clientY;
        } catch (e) {
          return false;
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
          return false;
        }
        if (prevent) {
          e_preventDefault(e);
        }
        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type)) {
          return e_defaultPrevented(e);
        }
        mY -= lineBox.top - display.viewOffset;
        for (var i = 0; i < cm.options.gutters.length; ++i) {
          var g = display.gutters.childNodes[i];
          if (g && g.getBoundingClientRect().right >= mX) {
            var line = lineAtHeight(cm.doc, mY);
            var gutter = cm.options.gutters[i];
            signal(cm, type, cm, line, gutter, e);
            return e_defaultPrevented(e);
          }
        }
      }
      function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", true);
      }
      function onContextMenu(cm, e) {
        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
          return;
        }
        if (signalDOMEvent(cm, e, "contextmenu")) {
          return;
        }
        cm.display.input.onContextMenu(e);
      }
      function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, "gutterContextMenu")) {
          return false;
        }
        return gutterEvent(cm, e, "gutterContextMenu", false);
      }
      function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
      }
      var Init = { toString: function () {
          return "CodeMirror.Init";
        } };
      var defaults = {};
      var optionHandlers = {};
      function defineOptions(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers;
        function option(name, deflt, handle, notOnInit) {
          CodeMirror.defaults[name] = deflt;
          if (handle) {
            optionHandlers[name] = notOnInit ? function (cm, val, old) {
              if (old != Init) {
                handle(cm, val, old);
              }
            } : handle;
          }
        }
        CodeMirror.defineOption = option;
        CodeMirror.Init = Init;
        option("value", "", function (cm, val) {
          return cm.setValue(val);
        }, true);
        option("mode", null, function (cm, val) {
          cm.doc.modeOption = val;
          loadMode(cm);
        }, true);
        option("indentUnit", 2, loadMode, true);
        option("indentWithTabs", false);
        option("smartIndent", true);
        option("tabSize", 4, function (cm) {
          resetModeState(cm);
          clearCaches(cm);
          regChange(cm);
        }, true);
        option("lineSeparator", null, function (cm, val) {
          cm.doc.lineSep = val;
          if (!val) {
            return;
          }
          var newBreaks = [],
              lineNo = cm.doc.first;
          cm.doc.iter(function (line) {
            for (var pos = 0;;) {
              var found = line.text.indexOf(val, pos);
              if (found == -1) {
                break;
              }
              pos = found + val.length;
              newBreaks.push(Pos(lineNo, found));
            }
            lineNo++;
          });
          for (var i = newBreaks.length - 1; i >= 0; i--) {
            replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
          }
        });
        option("specialChars", /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
          cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
          if (old != Init) {
            cm.refresh();
          }
        });
        option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
          return cm.refresh();
        }, true);
        option("electricChars", true);
        option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
          throw new Error("inputStyle can not (yet) be changed in a running editor");
        }, true);
        option("spellcheck", false, function (cm, val) {
          return cm.getInputField().spellcheck = val;
        }, true);
        option("rtlMoveVisually", !windows);
        option("wholeLineUpdateBefore", true);
        option("theme", "default", function (cm) {
          themeChanged(cm);
          guttersChanged(cm);
        }, true);
        option("keyMap", "default", function (cm, val, old) {
          var next = getKeyMap(val);
          var prev = old != Init && getKeyMap(old);
          if (prev && prev.detach) {
            prev.detach(cm, next);
          }
          if (next.attach) {
            next.attach(cm, prev || null);
          }
        });
        option("extraKeys", null);
        option("lineWrapping", false, wrappingChanged, true);
        option("gutters", [], function (cm) {
          setGuttersForLineNumbers(cm.options);
          guttersChanged(cm);
        }, true);
        option("fixedGutter", true, function (cm, val) {
          cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
          cm.refresh();
        }, true);
        option("coverGutterNextToScrollbar", false, function (cm) {
          return updateScrollbars(cm);
        }, true);
        option("scrollbarStyle", "native", function (cm) {
          initScrollbars(cm);
          updateScrollbars(cm);
          cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
          cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
        }, true);
        option("lineNumbers", false, function (cm) {
          setGuttersForLineNumbers(cm.options);
          guttersChanged(cm);
        }, true);
        option("firstLineNumber", 1, guttersChanged, true);
        option("lineNumberFormatter", function (integer) {
          return integer;
        }, guttersChanged, true);
        option("showCursorWhenSelecting", false, updateSelection, true);
        option("resetSelectionOnContextMenu", true);
        option("lineWiseCopyCut", true);
        option("readOnly", false, function (cm, val) {
          if (val == "nocursor") {
            onBlur(cm);
            cm.display.input.blur();
            cm.display.disabled = true;
          } else {
            cm.display.disabled = false;
          }
          cm.display.input.readOnlyChanged(val);
        });
        option("disableInput", false, function (cm, val) {
          if (!val) {
            cm.display.input.reset();
          }
        }, true);
        option("dragDrop", true, dragDropChanged);
        option("allowDropFileTypes", null);
        option("cursorBlinkRate", 530);
        option("cursorScrollMargin", 0);
        option("cursorHeight", 1, updateSelection, true);
        option("singleCursorHeightPerLine", true, updateSelection, true);
        option("workTime", 100);
        option("workDelay", 100);
        option("flattenSpans", true, resetModeState, true);
        option("addModeClass", false, resetModeState, true);
        option("pollInterval", 100);
        option("undoDepth", 200, function (cm, val) {
          return cm.doc.history.undoDepth = val;
        });
        option("historyEventDelay", 1250);
        option("viewportMargin", 10, function (cm) {
          return cm.refresh();
        }, true);
        option("maxHighlightLength", 10000, resetModeState, true);
        option("moveInputWithCursor", true, function (cm, val) {
          if (!val) {
            cm.display.input.resetPosition();
          }
        });
        option("tabindex", null, function (cm, val) {
          return cm.display.input.getField().tabIndex = val || "";
        });
        option("autofocus", null);
      }
      function guttersChanged(cm) {
        updateGutters(cm);
        regChange(cm);
        setTimeout(function () {
          return alignHorizontally(cm);
        }, 20);
      }
      function dragDropChanged(cm, value, old) {
        var wasOn = old && old != Init;
        if (!value != !wasOn) {
          var funcs = cm.display.dragFunctions;
          var toggle = value ? on : off;
          toggle(cm.display.scroller, "dragstart", funcs.start);
          toggle(cm.display.scroller, "dragenter", funcs.enter);
          toggle(cm.display.scroller, "dragover", funcs.over);
          toggle(cm.display.scroller, "dragleave", funcs.leave);
          toggle(cm.display.scroller, "drop", funcs.drop);
        }
      }
      function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
          addClass(cm.display.wrapper, "CodeMirror-wrap");
          cm.display.sizer.style.minWidth = "";
          cm.display.sizerWidth = null;
        } else {
          rmClass(cm.display.wrapper, "CodeMirror-wrap");
          findMaxLine(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function () {
          return updateScrollbars(cm);
        }, 100);
      }
      function CodeMirror(place, options) {
        var this$1 = this;
        if (!(this instanceof CodeMirror)) {
          return new CodeMirror(place, options);
        }
        this.options = options = options ? copyObj(options) : {};
        copyObj(defaults, options, false);
        setGuttersForLineNumbers(options);
        var doc = options.value;
        if (typeof doc == "string") {
          doc = new Doc(doc, options.mode, null, options.lineSeparator);
        }
        this.doc = doc;
        var input = new CodeMirror.inputStyles[options.inputStyle](this);
        var display = this.display = new Display(place, doc, input);
        display.wrapper.CodeMirror = this;
        updateGutters(this);
        themeChanged(this);
        if (options.lineWrapping) {
          this.display.wrapper.className += " CodeMirror-wrap";
        }
        if (options.autofocus && !mobile) {
          display.input.focus();
        }
        initScrollbars(this);
        this.state = {
          keyMaps: [],
          overlays: [],
          modeGen: 0,
          overwrite: false,
          delayingBlurEvent: false,
          focused: false,
          suppressEdits: false,
          pasteIncoming: false,
          cutIncoming: false,
          selectingText: false,
          draggingText: false,
          highlight: new Delayed(),
          keySeq: null,
          specialChars: null
        };
        if (ie && ie_version < 11) {
          setTimeout(function () {
            return this$1.display.input.reset(true);
          }, 20);
        }
        registerEventHandlers(this);
        ensureGlobalHandlers();
        startOperation(this);
        this.curOp.forceUpdate = true;
        attachDoc(this, doc);
        if (options.autofocus && !mobile || this.hasFocus()) {
          setTimeout(bind(onFocus, this), 20);
        } else {
          onBlur(this);
        }
        for (var opt in optionHandlers) {
          if (optionHandlers.hasOwnProperty(opt)) {
            optionHandlers[opt](this$1, options[opt], Init);
          }
        }
        maybeUpdateLineNumberWidth(this);
        if (options.finishInit) {
          options.finishInit(this);
        }
        for (var i = 0; i < initHooks.length; ++i) {
          initHooks[i](this$1);
        }
        endOperation(this);
        if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
          display.lineDiv.style.textRendering = "auto";
        }
      }
      CodeMirror.defaults = defaults;
      CodeMirror.optionHandlers = optionHandlers;
      function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown));
        if (ie && ie_version < 11) {
          on(d.scroller, "dblclick", operation(cm, function (e) {
            if (signalDOMEvent(cm, e)) {
              return;
            }
            var pos = posFromMouse(cm, e);
            if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
              return;
            }
            e_preventDefault(e);
            var word = cm.findWordAt(pos);
            extendSelection(cm.doc, word.anchor, word.head);
          }));
        } else {
          on(d.scroller, "dblclick", function (e) {
            return signalDOMEvent(cm, e) || e_preventDefault(e);
          });
        }
        if (!captureRightClick) {
          on(d.scroller, "contextmenu", function (e) {
            return onContextMenu(cm, e);
          });
        }
        var touchFinished,
            prevTouch = { end: 0 };
        function finishTouch() {
          if (d.activeTouch) {
            touchFinished = setTimeout(function () {
              return d.activeTouch = null;
            }, 1000);
            prevTouch = d.activeTouch;
            prevTouch.end = +new Date();
          }
        }
        function isMouseLikeTouchEvent(e) {
          if (e.touches.length != 1) {
            return false;
          }
          var touch = e.touches[0];
          return touch.radiusX <= 1 && touch.radiusY <= 1;
        }
        function farAway(touch, other) {
          if (other.left == null) {
            return true;
          }
          var dx = other.left - touch.left,
              dy = other.top - touch.top;
          return dx * dx + dy * dy > 20 * 20;
        }
        on(d.scroller, "touchstart", function (e) {
          if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
            d.input.ensurePolled();
            clearTimeout(touchFinished);
            var now = +new Date();
            d.activeTouch = {
              start: now,
              moved: false,
              prev: now - prevTouch.end <= 300 ? prevTouch : null
            };
            if (e.touches.length == 1) {
              d.activeTouch.left = e.touches[0].pageX;
              d.activeTouch.top = e.touches[0].pageY;
            }
          }
        });
        on(d.scroller, "touchmove", function () {
          if (d.activeTouch) {
            d.activeTouch.moved = true;
          }
        });
        on(d.scroller, "touchend", function (e) {
          var touch = d.activeTouch;
          if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
            var pos = cm.coordsChar(d.activeTouch, "page"),
                range;
            if (!touch.prev || farAway(touch, touch.prev)) {
              range = new Range(pos, pos);
            } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
              range = cm.findWordAt(pos);
            } else {
              range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
            }
            cm.setSelection(range.anchor, range.head);
            cm.focus();
            e_preventDefault(e);
          }
          finishTouch();
        });
        on(d.scroller, "touchcancel", finishTouch);
        on(d.scroller, "scroll", function () {
          if (d.scroller.clientHeight) {
            setScrollTop(cm, d.scroller.scrollTop);
            setScrollLeft(cm, d.scroller.scrollLeft, true);
            signal(cm, "scroll", cm);
          }
        });
        on(d.scroller, "mousewheel", function (e) {
          return onScrollWheel(cm, e);
        });
        on(d.scroller, "DOMMouseScroll", function (e) {
          return onScrollWheel(cm, e);
        });
        on(d.wrapper, "scroll", function () {
          return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });
        d.dragFunctions = {
          enter: function (e) {
            if (!signalDOMEvent(cm, e)) {
              e_stop(e);
            }
          },
          over: function (e) {
            if (!signalDOMEvent(cm, e)) {
              onDragOver(cm, e);
              e_stop(e);
            }
          },
          start: function (e) {
            return onDragStart(cm, e);
          },
          drop: operation(cm, onDrop),
          leave: function (e) {
            if (!signalDOMEvent(cm, e)) {
              clearDragCursor(cm);
            }
          }
        };
        var inp = d.input.getField();
        on(inp, "keyup", function (e) {
          return onKeyUp.call(cm, e);
        });
        on(inp, "keydown", operation(cm, onKeyDown));
        on(inp, "keypress", operation(cm, onKeyPress));
        on(inp, "focus", function (e) {
          return onFocus(cm, e);
        });
        on(inp, "blur", function (e) {
          return onBlur(cm, e);
        });
      }
      var initHooks = [];
      CodeMirror.defineInitHook = function (f) {
        return initHooks.push(f);
      };
      function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc,
            state;
        if (how == null) {
          how = "add";
        }
        if (how == "smart") {
          if (!doc.mode.indent) {
            how = "prev";
          } else {
            state = getStateBefore(cm, n);
          }
        }
        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n),
            curSpace = countColumn(line.text, null, tabSize);
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        var curSpaceString = line.text.match(/^\s*/)[0],
            indentation;
        if (!aggressive && !/\S/.test(line.text)) {
          indentation = 0;
          how = "not";
        } else if (how == "smart") {
          indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
          if (indentation == Pass || indentation > 150) {
            if (!aggressive) {
              return;
            }
            how = "prev";
          }
        }
        if (how == "prev") {
          if (n > doc.first) {
            indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
          } else {
            indentation = 0;
          }
        } else if (how == "add") {
          indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
          indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
          indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);
        var indentString = "",
            pos = 0;
        if (cm.options.indentWithTabs) {
          for (var i = Math.floor(indentation / tabSize); i; --i) {
            pos += tabSize;
            indentString += "\t";
          }
        }
        if (pos < indentation) {
          indentString += spaceStr(indentation - pos);
        }
        if (indentString != curSpaceString) {
          replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
          line.stateAfter = null;
          return true;
        } else {
          for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
            var range = doc.sel.ranges[i$1];
            if (range.head.line == n && range.head.ch < curSpaceString.length) {
              var pos$1 = Pos(n, curSpaceString.length);
              replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
              break;
            }
          }
        }
      }
      var lastCopied = null;
      function setLastCopied(newLastCopied) {
        lastCopied = newLastCopied;
      }
      function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc = cm.doc;
        cm.display.shift = false;
        if (!sel) {
          sel = doc.sel;
        }
        var paste = cm.state.pasteIncoming || origin == "paste";
        var textLines = splitLinesAuto(inserted),
            multiPaste = null;
        if (paste && sel.ranges.length > 1) {
          if (lastCopied && lastCopied.text.join("\n") == inserted) {
            if (sel.ranges.length % lastCopied.text.length == 0) {
              multiPaste = [];
              for (var i = 0; i < lastCopied.text.length; i++) {
                multiPaste.push(doc.splitLines(lastCopied.text[i]));
              }
            }
          } else if (textLines.length == sel.ranges.length) {
            multiPaste = map(textLines, function (l) {
              return [l];
            });
          }
        }
        var updateInput;
        for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
          var range = sel.ranges[i$1];
          var from = range.from(),
              to = range.to();
          if (range.empty()) {
            if (deleted && deleted > 0) {
              from = Pos(from.line, from.ch - deleted);
            } else if (cm.state.overwrite && !paste) {
              to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
            } else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted) {
              from = to = Pos(from.line, 0);
            }
          }
          updateInput = cm.curOp.updateInput;
          var changeEvent = {
            from: from,
            to: to,
            text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
            origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
          };
          makeChange(cm.doc, changeEvent);
          signalLater(cm, "inputRead", cm, changeEvent);
        }
        if (inserted && !paste) {
          triggerElectric(cm, inserted);
        }
        ensureCursorVisible(cm);
        cm.curOp.updateInput = updateInput;
        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = false;
      }
      function handlePaste(e, cm) {
        var pasted = e.clipboardData && e.clipboardData.getData("Text");
        if (pasted) {
          e.preventDefault();
          if (!cm.isReadOnly() && !cm.options.disableInput) {
            runInOp(cm, function () {
              return applyTextInput(cm, pasted, 0, null, "paste");
            });
          }
          return true;
        }
      }
      function triggerElectric(cm, inserted) {
        if (!cm.options.electricChars || !cm.options.smartIndent) {
          return;
        }
        var sel = cm.doc.sel;
        for (var i = sel.ranges.length - 1; i >= 0; i--) {
          var range = sel.ranges[i];
          if (range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line) {
            continue;
          }
          var mode = cm.getModeAt(range.head);
          var indented = false;
          if (mode.electricChars) {
            for (var j = 0; j < mode.electricChars.length; j++) {
              if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                indented = indentLine(cm, range.head.line, "smart");
                break;
              }
            }
          } else if (mode.electricInput) {
            if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch))) {
              indented = indentLine(cm, range.head.line, "smart");
            }
          }
          if (indented) {
            signalLater(cm, "electricInput", cm, range.head.line);
          }
        }
      }
      function copyableRanges(cm) {
        var text = [],
            ranges = [];
        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
          var line = cm.doc.sel.ranges[i].head.line;
          var lineRange = {
            anchor: Pos(line, 0),
            head: Pos(line + 1, 0)
          };
          ranges.push(lineRange);
          text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        return {
          text: text,
          ranges: ranges
        };
      }
      function disableBrowserMagic(field, spellcheck) {
        field.setAttribute("autocorrect", "off");
        field.setAttribute("autocapitalize", "off");
        field.setAttribute("spellcheck", !!spellcheck);
      }
      function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
        var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        if (webkit) {
          te.style.width = "1000px";
        } else {
          te.setAttribute("wrap", "off");
        }
        if (ios) {
          te.style.border = "1px solid black";
        }
        disableBrowserMagic(te);
        return div;
      }
      function addEditorMethods(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers;
        var helpers = CodeMirror.helpers = {};
        CodeMirror.prototype = {
          constructor: CodeMirror,
          focus: function () {
            window.focus();
            this.display.input.focus();
          },
          setOption: function (option, value) {
            var options = this.options,
                old = options[option];
            if (options[option] == value && option != "mode") {
              return;
            }
            options[option] = value;
            if (optionHandlers.hasOwnProperty(option)) {
              operation(this, optionHandlers[option])(this, value, old);
            }
          },
          getOption: function (option) {
            return this.options[option];
          },
          getDoc: function () {
            return this.doc;
          },
          addKeyMap: function (map, bottom) {
            this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
          },
          removeKeyMap: function (map) {
            var maps = this.state.keyMaps;
            for (var i = 0; i < maps.length; ++i) {
              if (maps[i] == map || maps[i].name == map) {
                maps.splice(i, 1);
                return true;
              }
            }
          },
          addOverlay: methodOp(function (spec, options) {
            var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
            if (mode.startState) {
              throw new Error("Overlays may not be stateful.");
            }
            insertSorted(this.state.overlays, {
              mode: mode,
              modeSpec: spec,
              opaque: options && options.opaque,
              priority: options && options.priority || 0
            }, function (overlay) {
              return overlay.priority;
            });
            this.state.modeGen++;
            regChange(this);
          }),
          removeOverlay: methodOp(function (spec) {
            var this$1 = this;
            var overlays = this.state.overlays;
            for (var i = 0; i < overlays.length; ++i) {
              var cur = overlays[i].modeSpec;
              if (cur == spec || typeof spec == "string" && cur.name == spec) {
                overlays.splice(i, 1);
                this$1.state.modeGen++;
                regChange(this$1);
                return;
              }
            }
          }),
          indentLine: methodOp(function (n, dir, aggressive) {
            if (typeof dir != "string" && typeof dir != "number") {
              if (dir == null) {
                dir = this.options.smartIndent ? "smart" : "prev";
              } else {
                dir = dir ? "add" : "subtract";
              }
            }
            if (isLine(this.doc, n)) {
              indentLine(this, n, dir, aggressive);
            }
          }),
          indentSelection: methodOp(function (how) {
            var this$1 = this;
            var ranges = this.doc.sel.ranges,
                end = -1;
            for (var i = 0; i < ranges.length; i++) {
              var range = ranges[i];
              if (!range.empty()) {
                var from = range.from(),
                    to = range.to();
                var start = Math.max(end, from.line);
                end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                for (var j = start; j < end; ++j) {
                  indentLine(this$1, j, how);
                }
                var newRanges = this$1.doc.sel.ranges;
                if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {
                  replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
                }
              } else if (range.head.line > end) {
                indentLine(this$1, range.head.line, how, true);
                end = range.head.line;
                if (i == this$1.doc.sel.primIndex) {
                  ensureCursorVisible(this$1);
                }
              }
            }
          }),
          getTokenAt: function (pos, precise) {
            return takeToken(this, pos, precise);
          },
          getLineTokens: function (line, precise) {
            return takeToken(this, Pos(line), precise, true);
          },
          getTokenTypeAt: function (pos) {
            pos = clipPos(this.doc, pos);
            var styles = getLineStyles(this, getLine(this.doc, pos.line));
            var before = 0,
                after = (styles.length - 1) / 2,
                ch = pos.ch;
            var type;
            if (ch == 0) {
              type = styles[2];
            } else {
              for (;;) {
                var mid = before + after >> 1;
                if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                  after = mid;
                } else if (styles[mid * 2 + 1] < ch) {
                  before = mid + 1;
                } else {
                  type = styles[mid * 2 + 2];
                  break;
                }
              }
            }
            var cut = type ? type.indexOf("overlay ") : -1;
            return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
          },
          getModeAt: function (pos) {
            var mode = this.doc.mode;
            if (!mode.innerMode) {
              return mode;
            }
            return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
          },
          getHelper: function (pos, type) {
            return this.getHelpers(pos, type)[0];
          },
          getHelpers: function (pos, type) {
            var this$1 = this;
            var found = [];
            if (!helpers.hasOwnProperty(type)) {
              return found;
            }
            var help = helpers[type],
                mode = this.getModeAt(pos);
            if (typeof mode[type] == "string") {
              if (help[mode[type]]) {
                found.push(help[mode[type]]);
              }
            } else if (mode[type]) {
              for (var i = 0; i < mode[type].length; i++) {
                var val = help[mode[type][i]];
                if (val) {
                  found.push(val);
                }
              }
            } else if (mode.helperType && help[mode.helperType]) {
              found.push(help[mode.helperType]);
            } else if (help[mode.name]) {
              found.push(help[mode.name]);
            }
            for (var i$1 = 0; i$1 < help._global.length; i$1++) {
              var cur = help._global[i$1];
              if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1) {
                found.push(cur.val);
              }
            }
            return found;
          },
          getStateAfter: function (line, precise) {
            var doc = this.doc;
            line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
            return getStateBefore(this, line + 1, precise);
          },
          cursorCoords: function (start, mode) {
            var pos,
                range = this.doc.sel.primary();
            if (start == null) {
              pos = range.head;
            } else if (typeof start == "object") {
              pos = clipPos(this.doc, start);
            } else {
              pos = start ? range.from() : range.to();
            }
            return cursorCoords(this, pos, mode || "page");
          },
          charCoords: function (pos, mode) {
            return charCoords(this, clipPos(this.doc, pos), mode || "page");
          },
          coordsChar: function (coords, mode) {
            coords = fromCoordSystem(this, coords, mode || "page");
            return coordsChar(this, coords.left, coords.top);
          },
          lineAtHeight: function (height, mode) {
            height = fromCoordSystem(this, {
              top: height,
              left: 0
            }, mode || "page").top;
            return lineAtHeight(this.doc, height + this.display.viewOffset);
          },
          heightAtLine: function (line, mode, includeWidgets) {
            var end = false,
                lineObj;
            if (typeof line == "number") {
              var last = this.doc.first + this.doc.size - 1;
              if (line < this.doc.first) {
                line = this.doc.first;
              } else if (line > last) {
                line = last;
                end = true;
              }
              lineObj = getLine(this.doc, line);
            } else {
              lineObj = line;
            }
            return intoCoordSystem(this, lineObj, {
              top: 0,
              left: 0
            }, mode || "page", includeWidgets).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
          },
          defaultTextHeight: function () {
            return textHeight(this.display);
          },
          defaultCharWidth: function () {
            return charWidth(this.display);
          },
          getViewport: function () {
            return {
              from: this.display.viewFrom,
              to: this.display.viewTo
            };
          },
          addWidget: function (pos, node, scroll, vert, horiz) {
            var display = this.display;
            pos = cursorCoords(this, clipPos(this.doc, pos));
            var top = pos.bottom,
                left = pos.left;
            node.style.position = "absolute";
            node.setAttribute("cm-ignore-events", "true");
            this.display.input.setUneditable(node);
            display.sizer.appendChild(node);
            if (vert == "over") {
              top = pos.top;
            } else if (vert == "above" || vert == "near") {
              var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
                  hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
              if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                top = pos.top - node.offsetHeight;
              } else if (pos.bottom + node.offsetHeight <= vspace) {
                top = pos.bottom;
              }
              if (left + node.offsetWidth > hspace) {
                left = hspace - node.offsetWidth;
              }
            }
            node.style.top = top + "px";
            node.style.left = node.style.right = "";
            if (horiz == "right") {
              left = display.sizer.clientWidth - node.offsetWidth;
              node.style.right = "0px";
            } else {
              if (horiz == "left") {
                left = 0;
              } else if (horiz == "middle") {
                left = (display.sizer.clientWidth - node.offsetWidth) / 2;
              }
              node.style.left = left + "px";
            }
            if (scroll) {
              scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
            }
          },
          triggerOnKeyDown: methodOp(onKeyDown),
          triggerOnKeyPress: methodOp(onKeyPress),
          triggerOnKeyUp: onKeyUp,
          execCommand: function (cmd) {
            if (commands.hasOwnProperty(cmd)) {
              return commands[cmd].call(null, this);
            }
          },
          triggerElectric: methodOp(function (text) {
            triggerElectric(this, text);
          }),
          findPosH: function (from, amount, unit, visually) {
            var this$1 = this;
            var dir = 1;
            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }
            var cur = clipPos(this.doc, from);
            for (var i = 0; i < amount; ++i) {
              cur = findPosH(this$1.doc, cur, dir, unit, visually);
              if (cur.hitSide) {
                break;
              }
            }
            return cur;
          },
          moveH: methodOp(function (dir, unit) {
            var this$1 = this;
            this.extendSelectionsBy(function (range) {
              if (this$1.display.shift || this$1.doc.extend || range.empty()) {
                return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually);
              } else {
                return dir < 0 ? range.from() : range.to();
              }
            }, sel_move);
          }),
          deleteH: methodOp(function (dir, unit) {
            var sel = this.doc.sel,
                doc = this.doc;
            if (sel.somethingSelected()) {
              doc.replaceSelection("", null, "+delete");
            } else {
              deleteNearSelection(this, function (range) {
                var other = findPosH(doc, range.head, dir, unit, false);
                return dir < 0 ? {
                  from: other,
                  to: range.head
                } : {
                  from: range.head,
                  to: other
                };
              });
            }
          }),
          findPosV: function (from, amount, unit, goalColumn) {
            var this$1 = this;
            var dir = 1,
                x = goalColumn;
            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }
            var cur = clipPos(this.doc, from);
            for (var i = 0; i < amount; ++i) {
              var coords = cursorCoords(this$1, cur, "div");
              if (x == null) {
                x = coords.left;
              } else {
                coords.left = x;
              }
              cur = findPosV(this$1, coords, dir, unit);
              if (cur.hitSide) {
                break;
              }
            }
            return cur;
          },
          moveV: methodOp(function (dir, unit) {
            var this$1 = this;
            var doc = this.doc,
                goals = [];
            var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
            doc.extendSelectionsBy(function (range) {
              if (collapse) {
                return dir < 0 ? range.from() : range.to();
              }
              var headPos = cursorCoords(this$1, range.head, "div");
              if (range.goalColumn != null) {
                headPos.left = range.goalColumn;
              }
              goals.push(headPos.left);
              var pos = findPosV(this$1, headPos, dir, unit);
              if (unit == "page" && range == doc.sel.primary()) {
                addToScrollPos(this$1, null, charCoords(this$1, pos, "div").top - headPos.top);
              }
              return pos;
            }, sel_move);
            if (goals.length) {
              for (var i = 0; i < doc.sel.ranges.length; i++) {
                doc.sel.ranges[i].goalColumn = goals[i];
              }
            }
          }),
          findWordAt: function (pos) {
            var doc = this.doc,
                line = getLine(doc, pos.line).text;
            var start = pos.ch,
                end = pos.ch;
            if (line) {
              var helper = this.getHelper(pos, "wordChars");
              if ((pos.xRel < 0 || end == line.length) && start) {
                --start;
              } else {
                ++end;
              }
              var startChar = line.charAt(start);
              var check = isWordChar(startChar, helper) ? function (ch) {
                return isWordChar(ch, helper);
              } : /\s/.test(startChar) ? function (ch) {
                return (/\s/.test(ch)
                );
              } : function (ch) {
                return !/\s/.test(ch) && !isWordChar(ch);
              };
              while (start > 0 && check(line.charAt(start - 1))) {
                --start;
              }
              while (end < line.length && check(line.charAt(end))) {
                ++end;
              }
            }
            return new Range(Pos(pos.line, start), Pos(pos.line, end));
          },
          toggleOverwrite: function (value) {
            if (value != null && value == this.state.overwrite) {
              return;
            }
            if (this.state.overwrite = !this.state.overwrite) {
              addClass(this.display.cursorDiv, "CodeMirror-overwrite");
            } else {
              rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
            }
            signal(this, "overwriteToggle", this, this.state.overwrite);
          },
          hasFocus: function () {
            return this.display.input.getField() == activeElt();
          },
          isReadOnly: function () {
            return !!(this.options.readOnly || this.doc.cantEdit);
          },
          scrollTo: methodOp(function (x, y) {
            if (x != null || y != null) {
              resolveScrollToPos(this);
            }
            if (x != null) {
              this.curOp.scrollLeft = x;
            }
            if (y != null) {
              this.curOp.scrollTop = y;
            }
          }),
          getScrollInfo: function () {
            var scroller = this.display.scroller;
            return {
              left: scroller.scrollLeft,
              top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this),
              clientWidth: displayWidth(this)
            };
          },
          scrollIntoView: methodOp(function (range, margin) {
            if (range == null) {
              range = {
                from: this.doc.sel.primary().head,
                to: null
              };
              if (margin == null) {
                margin = this.options.cursorScrollMargin;
              }
            } else if (typeof range == "number") {
              range = {
                from: Pos(range, 0),
                to: null
              };
            } else if (range.from == null) {
              range = {
                from: range,
                to: null
              };
            }
            if (!range.to) {
              range.to = range.from;
            }
            range.margin = margin || 0;
            if (range.from.line != null) {
              resolveScrollToPos(this);
              this.curOp.scrollToPos = range;
            } else {
              var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left), Math.min(range.from.top, range.to.top) - range.margin, Math.max(range.from.right, range.to.right), Math.max(range.from.bottom, range.to.bottom) + range.margin);
              this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
            }
          }),
          setSize: methodOp(function (width, height) {
            var this$1 = this;
            var interpret = function (val) {
              return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
            };
            if (width != null) {
              this.display.wrapper.style.width = interpret(width);
            }
            if (height != null) {
              this.display.wrapper.style.height = interpret(height);
            }
            if (this.options.lineWrapping) {
              clearLineMeasurementCache(this);
            }
            var lineNo = this.display.viewFrom;
            this.doc.iter(lineNo, this.display.viewTo, function (line) {
              if (line.widgets) {
                for (var i = 0; i < line.widgets.length; i++) {
                  if (line.widgets[i].noHScroll) {
                    regLineChange(this$1, lineNo, "widget");
                    break;
                  }
                }
              }
              ++lineNo;
            });
            this.curOp.forceUpdate = true;
            signal(this, "refresh", this);
          }),
          operation: function (f) {
            return runInOp(this, f);
          },
          refresh: methodOp(function () {
            var oldHeight = this.display.cachedTextHeight;
            regChange(this);
            this.curOp.forceUpdate = true;
            clearCaches(this);
            this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
            updateGutterSpace(this);
            if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5) {
              estimateLineHeights(this);
            }
            signal(this, "refresh", this);
          }),
          swapDoc: methodOp(function (doc) {
            var old = this.doc;
            old.cm = null;
            attachDoc(this, doc);
            clearCaches(this);
            this.display.input.reset();
            this.scrollTo(doc.scrollLeft, doc.scrollTop);
            this.curOp.forceScroll = true;
            signalLater(this, "swapDoc", this, old);
            return old;
          }),
          getInputField: function () {
            return this.display.input.getField();
          },
          getWrapperElement: function () {
            return this.display.wrapper;
          },
          getScrollerElement: function () {
            return this.display.scroller;
          },
          getGutterElement: function () {
            return this.display.gutters;
          }
        };
        eventMixin(CodeMirror);
        CodeMirror.registerHelper = function (type, name, value) {
          if (!helpers.hasOwnProperty(type)) {
            helpers[type] = CodeMirror[type] = { _global: [] };
          }
          helpers[type][name] = value;
        };
        CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
          CodeMirror.registerHelper(type, name, value);
          helpers[type]._global.push({
            pred: predicate,
            val: value
          });
        };
      }
      function findPosH(doc, pos, dir, unit, visually) {
        var line = pos.line,
            ch = pos.ch,
            origDir = dir;
        var lineObj = getLine(doc, line);
        function findNextLine() {
          var l = line + dir;
          if (l < doc.first || l >= doc.first + doc.size) {
            return false;
          }
          line = l;
          return lineObj = getLine(doc, l);
        }
        function moveOnce(boundToLine) {
          var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
          if (next == null) {
            if (!boundToLine && findNextLine()) {
              if (visually) {
                ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
              } else {
                ch = dir < 0 ? lineObj.text.length : 0;
              }
            } else {
              return false;
            }
          } else {
            ch = next;
          }
          return true;
        }
        if (unit == "char") {
          moveOnce();
        } else if (unit == "column") {
          moveOnce(true);
        } else if (unit == "word" || unit == "group") {
          var sawType = null,
              group = unit == "group";
          var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
          for (var first = true;; first = false) {
            if (dir < 0 && !moveOnce(!first)) {
              break;
            }
            var cur = lineObj.text.charAt(ch) || "\n";
            var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
            if (group && !first && !type) {
              type = "s";
            }
            if (sawType && sawType != type) {
              if (dir < 0) {
                dir = 1;
                moveOnce();
              }
              break;
            }
            if (type) {
              sawType = type;
            }
            if (dir > 0 && !moveOnce(!first)) {
              break;
            }
          }
        }
        var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);
        if (!cmp(pos, result)) {
          result.hitSide = true;
        }
        return result;
      }
      function findPosV(cm, pos, dir, unit) {
        var doc = cm.doc,
            x = pos.left,
            y;
        if (unit == "page") {
          var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
          var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
          y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
        } else if (unit == "line") {
          y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        var target;
        for (;;) {
          target = coordsChar(cm, x, y);
          if (!target.outside) {
            break;
          }
          if (dir < 0 ? y <= 0 : y >= doc.height) {
            target.hitSide = true;
            break;
          }
          y += dir * 5;
        }
        return target;
      }
      function ContentEditableInput(cm) {
        this.cm = cm;
        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
        this.polling = new Delayed();
        this.composing = null;
        this.gracePeriod = false;
        this.readDOMTimeout = null;
      }
      ContentEditableInput.prototype = copyObj({
        init: function (display) {
          var this$1 = this;
          var input = this,
              cm = input.cm;
          var div = input.div = display.lineDiv;
          disableBrowserMagic(div, cm.options.spellcheck);
          on(div, "paste", function (e) {
            if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
              return;
            }
            if (ie_version <= 11) {
              setTimeout(operation(cm, function () {
                if (!input.pollContent()) {
                  regChange(cm);
                }
              }), 20);
            }
          });
          on(div, "compositionstart", function (e) {
            this$1.composing = { data: e.data };
          });
          on(div, "compositionupdate", function (e) {
            if (!this$1.composing) {
              this$1.composing = { data: e.data };
            }
          });
          on(div, "compositionend", function (e) {
            if (this$1.composing) {
              if (e.data != this$1.composing.data) {
                this$1.readFromDOMSoon();
              }
              this$1.composing = null;
            }
          });
          on(div, "touchstart", function () {
            return input.forceCompositionEnd();
          });
          on(div, "input", function () {
            if (!this$1.composing) {
              this$1.readFromDOMSoon();
            }
          });
          function onCopyCut(e) {
            if (signalDOMEvent(cm, e)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({
                lineWise: false,
                text: cm.getSelections()
              });
              if (e.type == "cut") {
                cm.replaceSelection("", null, "cut");
              }
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({
                lineWise: true,
                text: ranges.text
              });
              if (e.type == "cut") {
                cm.operation(function () {
                  cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                  cm.replaceSelection("", null, "cut");
                });
              }
            }
            if (e.clipboardData) {
              e.clipboardData.clearData();
              var content = lastCopied.text.join("\n");
              e.clipboardData.setData("Text", content);
              if (e.clipboardData.getData("Text") == content) {
                e.preventDefault();
                return;
              }
            }
            var kludge = hiddenTextarea(),
                te = kludge.firstChild;
            cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
            te.value = lastCopied.text.join("\n");
            var hadFocus = document.activeElement;
            selectInput(te);
            setTimeout(function () {
              cm.display.lineSpace.removeChild(kludge);
              hadFocus.focus();
              if (hadFocus == div) {
                input.showPrimarySelection();
              }
            }, 50);
          }
          on(div, "copy", onCopyCut);
          on(div, "cut", onCopyCut);
        },
        prepareSelection: function () {
          var result = prepareSelection(this.cm, false);
          result.focus = this.cm.state.focused;
          return result;
        },
        showSelection: function (info, takeFocus) {
          if (!info || !this.cm.display.view.length) {
            return;
          }
          if (info.focus || takeFocus) {
            this.showPrimarySelection();
          }
          this.showMultipleSelections(info);
        },
        showPrimarySelection: function () {
          var sel = window.getSelection(),
              prim = this.cm.doc.sel.primary();
          var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
          var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
          if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), prim.from()) == 0 && cmp(maxPos(curAnchor, curFocus), prim.to()) == 0) {
            return;
          }
          var start = posToDOM(this.cm, prim.from());
          var end = posToDOM(this.cm, prim.to());
          if (!start && !end) {
            return;
          }
          var view = this.cm.display.view;
          var old = sel.rangeCount && sel.getRangeAt(0);
          if (!start) {
            start = {
              node: view[0].measure.map[2],
              offset: 0
            };
          } else if (!end) {
            var measure = view[view.length - 1].measure;
            var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
            end = {
              node: map[map.length - 1],
              offset: map[map.length - 2] - map[map.length - 3]
            };
          }
          var rng;
          try {
            rng = range(start.node, start.offset, end.offset, end.node);
          } catch (e) {}
          if (rng) {
            if (!gecko && this.cm.state.focused) {
              sel.collapse(start.node, start.offset);
              if (!rng.collapsed) {
                sel.removeAllRanges();
                sel.addRange(rng);
              }
            } else {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
            if (old && sel.anchorNode == null) {
              sel.addRange(old);
            } else if (gecko) {
              this.startGracePeriod();
            }
          }
          this.rememberSelection();
        },
        startGracePeriod: function () {
          var this$1 = this;
          clearTimeout(this.gracePeriod);
          this.gracePeriod = setTimeout(function () {
            this$1.gracePeriod = false;
            if (this$1.selectionChanged()) {
              this$1.cm.operation(function () {
                return this$1.cm.curOp.selectionChanged = true;
              });
            }
          }, 20);
        },
        showMultipleSelections: function (info) {
          removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
          removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
        },
        rememberSelection: function () {
          var sel = window.getSelection();
          this.lastAnchorNode = sel.anchorNode;
          this.lastAnchorOffset = sel.anchorOffset;
          this.lastFocusNode = sel.focusNode;
          this.lastFocusOffset = sel.focusOffset;
        },
        selectionInEditor: function () {
          var sel = window.getSelection();
          if (!sel.rangeCount) {
            return false;
          }
          var node = sel.getRangeAt(0).commonAncestorContainer;
          return contains(this.div, node);
        },
        focus: function () {
          if (this.cm.options.readOnly != "nocursor") {
            if (!this.selectionInEditor()) {
              this.showSelection(this.prepareSelection(), true);
            }
            this.div.focus();
          }
        },
        blur: function () {
          this.div.blur();
        },
        getField: function () {
          return this.div;
        },
        supportsTouch: function () {
          return true;
        },
        receivedFocus: function () {
          var input = this;
          if (this.selectionInEditor()) {
            this.pollSelection();
          } else {
            runInOp(this.cm, function () {
              return input.cm.curOp.selectionChanged = true;
            });
          }
          function poll() {
            if (input.cm.state.focused) {
              input.pollSelection();
              input.polling.set(input.cm.options.pollInterval, poll);
            }
          }
          this.polling.set(this.cm.options.pollInterval, poll);
        },
        selectionChanged: function () {
          var sel = window.getSelection();
          return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
        },
        pollSelection: function () {
          if (!this.composing && this.readDOMTimeout == null && !this.gracePeriod && this.selectionChanged()) {
            var sel = window.getSelection(),
                cm = this.cm;
            this.rememberSelection();
            var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
            var head = domToPos(cm, sel.focusNode, sel.focusOffset);
            if (anchor && head) {
              runInOp(cm, function () {
                setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
                if (anchor.bad || head.bad) {
                  cm.curOp.selectionChanged = true;
                }
              });
            }
          }
        },
        pollContent: function () {
          if (this.readDOMTimeout != null) {
            clearTimeout(this.readDOMTimeout);
            this.readDOMTimeout = null;
          }
          var cm = this.cm,
              display = cm.display,
              sel = cm.doc.sel.primary();
          var from = sel.from(),
              to = sel.to();
          if (from.ch == 0 && from.line > cm.firstLine()) {
            from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
          }
          if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
            to = Pos(to.line + 1, 0);
          }
          if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
            return false;
          }
          var fromIndex, fromLine, fromNode;
          if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
            fromLine = lineNo(display.view[0].line);
            fromNode = display.view[0].node;
          } else {
            fromLine = lineNo(display.view[fromIndex].line);
            fromNode = display.view[fromIndex - 1].node.nextSibling;
          }
          var toIndex = findViewIndex(cm, to.line);
          var toLine, toNode;
          if (toIndex == display.view.length - 1) {
            toLine = display.viewTo - 1;
            toNode = display.lineDiv.lastChild;
          } else {
            toLine = lineNo(display.view[toIndex + 1].line) - 1;
            toNode = display.view[toIndex + 1].node.previousSibling;
          }
          if (!fromNode) {
            return false;
          }
          var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
          var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
          while (newText.length > 1 && oldText.length > 1) {
            if (lst(newText) == lst(oldText)) {
              newText.pop();
              oldText.pop();
              toLine--;
            } else if (newText[0] == oldText[0]) {
              newText.shift();
              oldText.shift();
              fromLine++;
            } else {
              break;
            }
          }
          var cutFront = 0,
              cutEnd = 0;
          var newTop = newText[0],
              oldTop = oldText[0],
              maxCutFront = Math.min(newTop.length, oldTop.length);
          while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
            ++cutFront;
          }
          var newBot = lst(newText),
              oldBot = lst(oldText);
          var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
          while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            ++cutEnd;
          }
          newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
          newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
          var chFrom = Pos(fromLine, cutFront);
          var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
          if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
            replaceRange(cm.doc, newText, chFrom, chTo, "+input");
            return true;
          }
        },
        ensurePolled: function () {
          this.forceCompositionEnd();
        },
        reset: function () {
          this.forceCompositionEnd();
        },
        forceCompositionEnd: function () {
          if (!this.composing) {
            return;
          }
          this.composing = null;
          if (!this.pollContent()) {
            regChange(this.cm);
          }
          this.div.blur();
          this.div.focus();
        },
        readFromDOMSoon: function () {
          var this$1 = this;
          if (this.readDOMTimeout != null) {
            return;
          }
          this.readDOMTimeout = setTimeout(function () {
            this$1.readDOMTimeout = null;
            if (this$1.composing) {
              return;
            }
            if (this$1.cm.isReadOnly() || !this$1.pollContent()) {
              runInOp(this$1.cm, function () {
                return regChange(this$1.cm);
              });
            }
          }, 80);
        },
        setUneditable: function (node) {
          node.contentEditable = "false";
        },
        onKeyPress: function (e) {
          e.preventDefault();
          if (!this.cm.isReadOnly()) {
            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
          }
        },
        readOnlyChanged: function (val) {
          this.div.contentEditable = String(val != "nocursor");
        },
        onContextMenu: nothing,
        resetPosition: nothing,
        needsContentAttribute: true
      }, ContentEditableInput.prototype);
      function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);
        if (!view || view.hidden) {
          return null;
        }
        var line = getLine(cm.doc, pos.line);
        var info = mapFromLineView(view, line, pos.line);
        var order = getOrder(line),
            side = "left";
        if (order) {
          var partPos = getBidiPartAt(order, pos.ch);
          side = partPos % 2 ? "right" : "left";
        }
        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
        result.offset = result.collapse == "right" ? result.end : result.start;
        return result;
      }
      function badPos(pos, bad) {
        if (bad) {
          pos.bad = true;
        }
        return pos;
      }
      function domTextBetween(cm, from, to, fromLine, toLine) {
        var text = "",
            closing = false,
            lineSep = cm.doc.lineSeparator();
        function recognizeMarker(id) {
          return function (marker) {
            return marker.id == id;
          };
        }
        function walk(node) {
          if (node.nodeType == 1) {
            var cmText = node.getAttribute("cm-text");
            if (cmText != null) {
              if (cmText == "") {
                text += node.textContent.replace(/\u200b/g, "");
              } else {
                text += cmText;
              }
              return;
            }
            var markerID = node.getAttribute("cm-marker"),
                range;
            if (markerID) {
              var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
              if (found.length && (range = found[0].find())) {
                text += getBetween(cm.doc, range.from, range.to).join(lineSep);
              }
              return;
            }
            if (node.getAttribute("contenteditable") == "false") {
              return;
            }
            for (var i = 0; i < node.childNodes.length; i++) {
              walk(node.childNodes[i]);
            }
            if (/^(pre|div|p)$/i.test(node.nodeName)) {
              closing = true;
            }
          } else if (node.nodeType == 3) {
            var val = node.nodeValue;
            if (!val) {
              return;
            }
            if (closing) {
              text += lineSep;
              closing = false;
            }
            text += val;
          }
        }
        for (;;) {
          walk(from);
          if (from == to) {
            break;
          }
          from = from.nextSibling;
        }
        return text;
      }
      function domToPos(cm, node, offset) {
        var lineNode;
        if (node == cm.display.lineDiv) {
          lineNode = cm.display.lineDiv.childNodes[offset];
          if (!lineNode) {
            return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
          }
          node = null;
          offset = 0;
        } else {
          for (lineNode = node;; lineNode = lineNode.parentNode) {
            if (!lineNode || lineNode == cm.display.lineDiv) {
              return null;
            }
            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
              break;
            }
          }
        }
        for (var i = 0; i < cm.display.view.length; i++) {
          var lineView = cm.display.view[i];
          if (lineView.node == lineNode) {
            return locateNodeInLineView(lineView, node, offset);
          }
        }
      }
      function locateNodeInLineView(lineView, node, offset) {
        var wrapper = lineView.text.firstChild,
            bad = false;
        if (!node || !contains(wrapper, node)) {
          return badPos(Pos(lineNo(lineView.line), 0), true);
        }
        if (node == wrapper) {
          bad = true;
          node = wrapper.childNodes[offset];
          offset = 0;
          if (!node) {
            var line = lineView.rest ? lst(lineView.rest) : lineView.line;
            return badPos(Pos(lineNo(line), line.text.length), bad);
          }
        }
        var textNode = node.nodeType == 3 ? node : null,
            topNode = node;
        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
          textNode = node.firstChild;
          if (offset) {
            offset = textNode.nodeValue.length;
          }
        }
        while (topNode.parentNode != wrapper) {
          topNode = topNode.parentNode;
        }
        var measure = lineView.measure,
            maps = measure.maps;
        function find(textNode, topNode, offset) {
          for (var i = -1; i < (maps ? maps.length : 0); i++) {
            var map = i < 0 ? measure.map : maps[i];
            for (var j = 0; j < map.length; j += 3) {
              var curNode = map[j + 2];
              if (curNode == textNode || curNode == topNode) {
                var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
                var ch = map[j] + offset;
                if (offset < 0 || curNode != textNode) {
                  ch = map[j + (offset ? 1 : 0)];
                }
                return Pos(line, ch);
              }
            }
          }
        }
        var found = find(textNode, topNode, offset);
        if (found) {
          return badPos(found, bad);
        }
        for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
          found = find(after, after.firstChild, 0);
          if (found) {
            return badPos(Pos(found.line, found.ch - dist), bad);
          } else {
            dist += after.textContent.length;
          }
        }
        for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
          found = find(before, before.firstChild, -1);
          if (found) {
            return badPos(Pos(found.line, found.ch + dist$1), bad);
          } else {
            dist$1 += before.textContent.length;
          }
        }
      }
      function TextareaInput(cm) {
        this.cm = cm;
        this.prevInput = "";
        this.pollingFast = false;
        this.polling = new Delayed();
        this.inaccurateSelection = false;
        this.hasSelection = false;
        this.composing = null;
      }
      TextareaInput.prototype = copyObj({
        init: function (display) {
          var this$1 = this;
          var input = this,
              cm = this.cm;
          var div = this.wrapper = hiddenTextarea();
          var te = this.textarea = div.firstChild;
          display.wrapper.insertBefore(div, display.wrapper.firstChild);
          if (ios) {
            te.style.width = "0px";
          }
          on(te, "input", function () {
            if (ie && ie_version >= 9 && this$1.hasSelection) {
              this$1.hasSelection = null;
            }
            input.poll();
          });
          on(te, "paste", function (e) {
            if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
              return;
            }
            cm.state.pasteIncoming = true;
            input.fastPoll();
          });
          function prepareCopyCut(e) {
            if (signalDOMEvent(cm, e)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({
                lineWise: false,
                text: cm.getSelections()
              });
              if (input.inaccurateSelection) {
                input.prevInput = "";
                input.inaccurateSelection = false;
                te.value = lastCopied.text.join("\n");
                selectInput(te);
              }
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({
                lineWise: true,
                text: ranges.text
              });
              if (e.type == "cut") {
                cm.setSelections(ranges.ranges, null, sel_dontScroll);
              } else {
                input.prevInput = "";
                te.value = ranges.text.join("\n");
                selectInput(te);
              }
            }
            if (e.type == "cut") {
              cm.state.cutIncoming = true;
            }
          }
          on(te, "cut", prepareCopyCut);
          on(te, "copy", prepareCopyCut);
          on(display.scroller, "paste", function (e) {
            if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
              return;
            }
            cm.state.pasteIncoming = true;
            input.focus();
          });
          on(display.lineSpace, "selectstart", function (e) {
            if (!eventInWidget(display, e)) {
              e_preventDefault(e);
            }
          });
          on(te, "compositionstart", function () {
            var start = cm.getCursor("from");
            if (input.composing) {
              input.composing.range.clear();
            }
            input.composing = {
              start: start,
              range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })
            };
          });
          on(te, "compositionend", function () {
            if (input.composing) {
              input.poll();
              input.composing.range.clear();
              input.composing = null;
            }
          });
        },
        prepareSelection: function () {
          var cm = this.cm,
              display = cm.display,
              doc = cm.doc;
          var result = prepareSelection(cm);
          if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
            var wrapOff = display.wrapper.getBoundingClientRect(),
                lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
          }
          return result;
        },
        showSelection: function (drawn) {
          var cm = this.cm,
              display = cm.display;
          removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
          removeChildrenAndAdd(display.selectionDiv, drawn.selection);
          if (drawn.teTop != null) {
            this.wrapper.style.top = drawn.teTop + "px";
            this.wrapper.style.left = drawn.teLeft + "px";
          }
        },
        reset: function (typing) {
          if (this.contextMenuPending) {
            return;
          }
          var minimal,
              selected,
              cm = this.cm,
              doc = cm.doc;
          if (cm.somethingSelected()) {
            this.prevInput = "";
            var range = doc.sel.primary();
            minimal = hasCopyEvent && (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
            var content = minimal ? "-" : selected || cm.getSelection();
            this.textarea.value = content;
            if (cm.state.focused) {
              selectInput(this.textarea);
            }
            if (ie && ie_version >= 9) {
              this.hasSelection = content;
            }
          } else if (!typing) {
            this.prevInput = this.textarea.value = "";
            if (ie && ie_version >= 9) {
              this.hasSelection = null;
            }
          }
          this.inaccurateSelection = minimal;
        },
        getField: function () {
          return this.textarea;
        },
        supportsTouch: function () {
          return false;
        },
        focus: function () {
          if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
            try {
              this.textarea.focus();
            } catch (e) {}
          }
        },
        blur: function () {
          this.textarea.blur();
        },
        resetPosition: function () {
          this.wrapper.style.top = this.wrapper.style.left = 0;
        },
        receivedFocus: function () {
          this.slowPoll();
        },
        slowPoll: function () {
          var this$1 = this;
          if (this.pollingFast) {
            return;
          }
          this.polling.set(this.cm.options.pollInterval, function () {
            this$1.poll();
            if (this$1.cm.state.focused) {
              this$1.slowPoll();
            }
          });
        },
        fastPoll: function () {
          var missed = false,
              input = this;
          input.pollingFast = true;
          function p() {
            var changed = input.poll();
            if (!changed && !missed) {
              missed = true;
              input.polling.set(60, p);
            } else {
              input.pollingFast = false;
              input.slowPoll();
            }
          }
          input.polling.set(20, p);
        },
        poll: function () {
          var this$1 = this;
          var cm = this.cm,
              input = this.textarea,
              prevInput = this.prevInput;
          if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
            return false;
          }
          var text = input.value;
          if (text == prevInput && !cm.somethingSelected()) {
            return false;
          }
          if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
            cm.display.input.reset();
            return false;
          }
          if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0);
            if (first == 0x200b && !prevInput) {
              prevInput = "\u200b";
            }
            if (first == 0x21da) {
              this.reset();
              return this.cm.execCommand("undo");
            }
          }
          var same = 0,
              l = Math.min(prevInput.length, text.length);
          while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
            ++same;
          }
          runInOp(cm, function () {
            applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);
            if (text.length > 1000 || text.indexOf("\n") > -1) {
              input.value = this$1.prevInput = "";
            } else {
              this$1.prevInput = text;
            }
            if (this$1.composing) {
              this$1.composing.range.clear();
              this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
            }
          });
          return true;
        },
        ensurePolled: function () {
          if (this.pollingFast && this.poll()) {
            this.pollingFast = false;
          }
        },
        onKeyPress: function () {
          if (ie && ie_version >= 9) {
            this.hasSelection = null;
          }
          this.fastPoll();
        },
        onContextMenu: function (e) {
          var input = this,
              cm = input.cm,
              display = cm.display,
              te = input.textarea;
          var pos = posFromMouse(cm, e),
              scrollPos = display.scroller.scrollTop;
          if (!pos || presto) {
            return;
          }
          var reset = cm.options.resetSelectionOnContextMenu;
          if (reset && cm.doc.sel.contains(pos) == -1) {
            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
          }
          var oldCSS = te.style.cssText,
              oldWrapperCSS = input.wrapper.style.cssText;
          input.wrapper.style.cssText = "position: absolute";
          var wrapperBox = input.wrapper.getBoundingClientRect();
          te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
          var oldScrollY;
          if (webkit) {
            oldScrollY = window.scrollY;
          }
          display.input.focus();
          if (webkit) {
            window.scrollTo(null, oldScrollY);
          }
          display.input.reset();
          if (!cm.somethingSelected()) {
            te.value = input.prevInput = " ";
          }
          input.contextMenuPending = true;
          display.selForContextMenu = cm.doc.sel;
          clearTimeout(display.detectingSelectAll);
          function prepareSelectAllHack() {
            if (te.selectionStart != null) {
              var selected = cm.somethingSelected();
              var extval = "\u200b" + (selected ? te.value : "");
              te.value = "\u21da";
              te.value = extval;
              input.prevInput = selected ? "" : "\u200b";
              te.selectionStart = 1;
              te.selectionEnd = extval.length;
              display.selForContextMenu = cm.doc.sel;
            }
          }
          function rehide() {
            input.contextMenuPending = false;
            input.wrapper.style.cssText = oldWrapperCSS;
            te.style.cssText = oldCSS;
            if (ie && ie_version < 9) {
              display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
            }
            if (te.selectionStart != null) {
              if (!ie || ie && ie_version < 9) {
                prepareSelectAllHack();
              }
              var i = 0,
                  poll = function () {
                if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200b") {
                  operation(cm, selectAll)(cm);
                } else if (i++ < 10) {
                  display.detectingSelectAll = setTimeout(poll, 500);
                } else {
                  display.input.reset();
                }
              };
              display.detectingSelectAll = setTimeout(poll, 200);
            }
          }
          if (ie && ie_version >= 9) {
            prepareSelectAllHack();
          }
          if (captureRightClick) {
            e_stop(e);
            var mouseup = function () {
              off(window, "mouseup", mouseup);
              setTimeout(rehide, 20);
            };
            on(window, "mouseup", mouseup);
          } else {
            setTimeout(rehide, 50);
          }
        },
        readOnlyChanged: function (val) {
          if (!val) {
            this.reset();
          }
        },
        setUneditable: nothing,
        needsContentAttribute: false
      }, TextareaInput.prototype);
      function fromTextArea(textarea, options) {
        options = options ? copyObj(options) : {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabIndex) {
          options.tabindex = textarea.tabIndex;
        }
        if (!options.placeholder && textarea.placeholder) {
          options.placeholder = textarea.placeholder;
        }
        if (options.autofocus == null) {
          var hasFocus = activeElt();
          options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }
        function save() {
          textarea.value = cm.getValue();
        }
        var realSubmit;
        if (textarea.form) {
          on(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone) {
            var form = textarea.form;
            realSubmit = form.submit;
            try {
              var wrappedSubmit = form.submit = function () {
                save();
                form.submit = realSubmit;
                form.submit();
                form.submit = wrappedSubmit;
              };
            } catch (e) {}
          }
        }
        options.finishInit = function (cm) {
          cm.save = save;
          cm.getTextArea = function () {
            return textarea;
          };
          cm.toTextArea = function () {
            cm.toTextArea = isNaN;
            save();
            textarea.parentNode.removeChild(cm.getWrapperElement());
            textarea.style.display = "";
            if (textarea.form) {
              off(textarea.form, "submit", save);
              if (typeof textarea.form.submit == "function") {
                textarea.form.submit = realSubmit;
              }
            }
          };
        };
        textarea.style.display = "none";
        var cm = CodeMirror(function (node) {
          return textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        return cm;
      }
      function addLegacyProps(CodeMirror) {
        CodeMirror.off = off;
        CodeMirror.on = on;
        CodeMirror.wheelEventPixels = wheelEventPixels;
        CodeMirror.Doc = Doc;
        CodeMirror.splitLines = splitLinesAuto;
        CodeMirror.countColumn = countColumn;
        CodeMirror.findColumn = findColumn;
        CodeMirror.isWordChar = isWordCharBasic;
        CodeMirror.Pass = Pass;
        CodeMirror.signal = signal;
        CodeMirror.Line = Line;
        CodeMirror.changeEnd = changeEnd;
        CodeMirror.scrollbarModel = scrollbarModel;
        CodeMirror.Pos = Pos;
        CodeMirror.cmpPos = cmp;
        CodeMirror.modes = modes;
        CodeMirror.mimeModes = mimeModes;
        CodeMirror.resolveMode = resolveMode;
        CodeMirror.getMode = getMode;
        CodeMirror.modeExtensions = modeExtensions;
        CodeMirror.extendMode = extendMode;
        CodeMirror.copyState = copyState;
        CodeMirror.startState = startState;
        CodeMirror.innerMode = innerMode;
        CodeMirror.commands = commands;
        CodeMirror.keyMap = keyMap;
        CodeMirror.keyName = keyName;
        CodeMirror.isModifierKey = isModifierKey;
        CodeMirror.lookupKey = lookupKey;
        CodeMirror.normalizeKeyMap = normalizeKeyMap;
        CodeMirror.StringStream = StringStream;
        CodeMirror.SharedTextMarker = SharedTextMarker;
        CodeMirror.TextMarker = TextMarker;
        CodeMirror.LineWidget = LineWidget;
        CodeMirror.e_preventDefault = e_preventDefault;
        CodeMirror.e_stopPropagation = e_stopPropagation;
        CodeMirror.e_stop = e_stop;
        CodeMirror.addClass = addClass;
        CodeMirror.contains = contains;
        CodeMirror.rmClass = rmClass;
        CodeMirror.keyNames = keyNames;
      }
      defineOptions(CodeMirror);
      addEditorMethods(CodeMirror);
      var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
      for (var prop in Doc.prototype) {
        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
          CodeMirror.prototype[prop] = function (method) {
            return function () {
              return method.apply(this.doc, arguments);
            };
          }(Doc.prototype[prop]);
        }
      }
      eventMixin(Doc);
      CodeMirror.inputStyles = {
        "textarea": TextareaInput,
        "contenteditable": ContentEditableInput
      };
      CodeMirror.defineMode = function (name) {
        if (!CodeMirror.defaults.mode && name != "null") {
          CodeMirror.defaults.mode = name;
        }
        defineMode.apply(this, arguments);
      };
      CodeMirror.defineMIME = defineMIME;
      CodeMirror.defineMode("null", function () {
        return { token: function (stream) {
            return stream.skipToEnd();
          } };
      });
      CodeMirror.defineMIME("text/plain", "null");
      CodeMirror.defineExtension = function (name, func) {
        CodeMirror.prototype[name] = func;
      };
      CodeMirror.defineDocExtension = function (name, func) {
        Doc.prototype[name] = func;
      };
      CodeMirror.fromTextArea = fromTextArea;
      addLegacyProps(CodeMirror);
      CodeMirror.version = "5.21.0";
      return CodeMirror;
    });
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
});
System.registerDynamic("npm:codemirror@5.21.0/mode/javascript/javascript.js", ["npm:codemirror@5.21.0/lib/codemirror.js"], true, function ($__require, exports, module) {
  /* */
  "format cjs";

  var global = this || self,
      GLOBAL = global;
  (function (mod) {
    if (typeof exports == "object" && typeof module == "object") mod($__require("npm:codemirror@5.21.0/lib/codemirror.js"));else if (typeof undefined == "function" && define.amd) define(["../../lib/codemirror"], mod);else mod(CodeMirror);
  })(function (CodeMirror) {
    "use strict";

    function expressionAllowed(stream, state, backUp) {
      return (/^(?:operator|sof|keyword c|case|new|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)))
      );
    }
    CodeMirror.defineMode("javascript", function (config, parserConfig) {
      var indentUnit = config.indentUnit;
      var statementIndent = parserConfig.statementIndent;
      var jsonldMode = parserConfig.jsonld;
      var jsonMode = parserConfig.json || jsonldMode;
      var isTS = parserConfig.typescript;
      var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
      var keywords = function () {
        function kw(type) {
          return {
            type: type,
            style: "keyword"
          };
        }
        var A = kw("keyword a"),
            B = kw("keyword b"),
            C = kw("keyword c");
        var operator = kw("operator"),
            atom = {
          type: "atom",
          style: "atom"
        };
        var jsKeywords = {
          "if": kw("if"),
          "while": A,
          "with": A,
          "else": B,
          "do": B,
          "try": B,
          "finally": B,
          "return": C,
          "break": C,
          "continue": C,
          "new": kw("new"),
          "delete": C,
          "throw": C,
          "debugger": C,
          "var": kw("var"),
          "const": kw("var"),
          "let": kw("var"),
          "function": kw("function"),
          "catch": kw("catch"),
          "for": kw("for"),
          "switch": kw("switch"),
          "case": kw("case"),
          "default": kw("default"),
          "in": operator,
          "typeof": operator,
          "instanceof": operator,
          "true": atom,
          "false": atom,
          "null": atom,
          "undefined": atom,
          "NaN": atom,
          "Infinity": atom,
          "this": kw("this"),
          "class": kw("class"),
          "super": kw("atom"),
          "yield": C,
          "export": kw("export"),
          "import": kw("import"),
          "extends": C,
          "await": C,
          "async": kw("async")
        };
        if (isTS) {
          var type = {
            type: "variable",
            style: "variable-3"
          };
          var tsKeywords = {
            "interface": kw("class"),
            "implements": C,
            "namespace": C,
            "module": kw("module"),
            "enum": kw("module"),
            "type": kw("type"),
            "public": kw("modifier"),
            "private": kw("modifier"),
            "protected": kw("modifier"),
            "abstract": kw("modifier"),
            "as": operator,
            "string": type,
            "number": type,
            "boolean": type,
            "any": type
          };
          for (var attr in tsKeywords) {
            jsKeywords[attr] = tsKeywords[attr];
          }
        }
        return jsKeywords;
      }();
      var isOperatorChar = /[+\-*&%=<>!?|~^]/;
      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
      function readRegexp(stream) {
        var escaped = false,
            next,
            inSet = false;
        while ((next = stream.next()) != null) {
          if (!escaped) {
            if (next == "/" && !inSet) return;
            if (next == "[") inSet = true;else if (inSet && next == "]") inSet = false;
          }
          escaped = !escaped && next == "\\";
        }
      }
      var type, content;
      function ret(tp, style, cont) {
        type = tp;
        content = cont;
        return style;
      }
      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
          return ret("number", "number");
        } else if (ch == "." && stream.match("..")) {
          return ret("spread", "meta");
        } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          return ret(ch);
        } else if (ch == "=" && stream.eat(">")) {
          return ret("=>", "operator");
        } else if (ch == "0" && stream.eat(/x/i)) {
          stream.eatWhile(/[\da-f]/i);
          return ret("number", "number");
        } else if (ch == "0" && stream.eat(/o/i)) {
          stream.eatWhile(/[0-7]/i);
          return ret("number", "number");
        } else if (ch == "0" && stream.eat(/b/i)) {
          stream.eatWhile(/[01]/i);
          return ret("number", "number");
        } else if (/\d/.test(ch)) {
          stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
          return ret("number", "number");
        } else if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          } else if (stream.eat("/")) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (expressionAllowed(stream, state, 1)) {
            readRegexp(stream);
            stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
            return ret("regexp", "string-2");
          } else {
            stream.eatWhile(isOperatorChar);
            return ret("operator", "operator", stream.current());
          }
        } else if (ch == "`") {
          state.tokenize = tokenQuasi;
          return tokenQuasi(stream, state);
        } else if (ch == "#") {
          stream.skipToEnd();
          return ret("error", "error");
        } else if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return ret("operator", "operator", stream.current());
        } else if (wordRE.test(ch)) {
          stream.eatWhile(wordRE);
          var word = stream.current(),
              known = keywords.propertyIsEnumerable(word) && keywords[word];
          return known && state.lastType != "." ? ret(known.type, known.style, word) : ret("variable", "variable", word);
        }
      }
      function tokenString(quote) {
        return function (stream, state) {
          var escaped = false,
              next;
          if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
            state.tokenize = tokenBase;
            return ret("jsonld-keyword", "meta");
          }
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) break;
            escaped = !escaped && next == "\\";
          }
          if (!escaped) state.tokenize = tokenBase;
          return ret("string", "string");
        };
      }
      function tokenComment(stream, state) {
        var maybeEnd = false,
            ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = ch == "*";
        }
        return ret("comment", "comment");
      }
      function tokenQuasi(stream, state) {
        var escaped = false,
            next;
        while ((next = stream.next()) != null) {
          if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
            state.tokenize = tokenBase;
            break;
          }
          escaped = !escaped && next == "\\";
        }
        return ret("quasi", "string-2", stream.current());
      }
      var brackets = "([{}])";
      function findFatArrow(stream, state) {
        if (state.fatArrowAt) state.fatArrowAt = null;
        var arrow = stream.string.indexOf("=>", stream.start);
        if (arrow < 0) return;
        if (isTS) {
          var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
          if (m) arrow = m.index;
        }
        var depth = 0,
            sawSomething = false;
        for (var pos = arrow - 1; pos >= 0; --pos) {
          var ch = stream.string.charAt(pos);
          var bracket = brackets.indexOf(ch);
          if (bracket >= 0 && bracket < 3) {
            if (!depth) {
              ++pos;
              break;
            }
            if (--depth == 0) {
              if (ch == "(") sawSomething = true;
              break;
            }
          } else if (bracket >= 3 && bracket < 6) {
            ++depth;
          } else if (wordRE.test(ch)) {
            sawSomething = true;
          } else if (/["'\/]/.test(ch)) {
            return;
          } else if (sawSomething && !depth) {
            ++pos;
            break;
          }
        }
        if (sawSomething && !depth) state.fatArrowAt = pos;
      }
      var atomicTypes = {
        "atom": true,
        "number": true,
        "variable": true,
        "string": true,
        "regexp": true,
        "this": true,
        "jsonld-keyword": true
      };
      function JSLexical(indented, column, type, align, prev, info) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.prev = prev;
        this.info = info;
        if (align != null) this.align = align;
      }
      function inScope(state, varname) {
        for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;
        for (var cx = state.context; cx; cx = cx.prev) {
          for (var v = cx.vars; v; v = v.next) if (v.name == varname) return true;
        }
      }
      function parseJS(state, style, type, content, stream) {
        var cc = state.cc;
        cx.state = state;
        cx.stream = stream;
        cx.marked = null, cx.cc = cc;
        cx.style = style;
        if (!state.lexical.hasOwnProperty("align")) state.lexical.align = true;
        while (true) {
          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
          if (combinator(type, content)) {
            while (cc.length && cc[cc.length - 1].lex) cc.pop()();
            if (cx.marked) return cx.marked;
            if (type == "variable" && inScope(state, content)) return "variable-2";
            return style;
          }
        }
      }
      var cx = {
        state: null,
        column: null,
        marked: null,
        cc: null
      };
      function pass() {
        for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
      }
      function cont() {
        pass.apply(null, arguments);
        return true;
      }
      function register(varname) {
        function inList(list) {
          for (var v = list; v; v = v.next) if (v.name == varname) return true;
          return false;
        }
        var state = cx.state;
        cx.marked = "def";
        if (state.context) {
          if (inList(state.localVars)) return;
          state.localVars = {
            name: varname,
            next: state.localVars
          };
        } else {
          if (inList(state.globalVars)) return;
          if (parserConfig.globalVars) state.globalVars = {
            name: varname,
            next: state.globalVars
          };
        }
      }
      var defaultVars = {
        name: "this",
        next: { name: "arguments" }
      };
      function pushcontext() {
        cx.state.context = {
          prev: cx.state.context,
          vars: cx.state.localVars
        };
        cx.state.localVars = defaultVars;
      }
      function popcontext() {
        cx.state.localVars = cx.state.context.vars;
        cx.state.context = cx.state.context.prev;
      }
      function pushlex(type, info) {
        var result = function () {
          var state = cx.state,
              indent = state.indented;
          if (state.lexical.type == "stat") indent = state.lexical.indented;else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev) indent = outer.indented;
          state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
        };
        result.lex = true;
        return result;
      }
      function poplex() {
        var state = cx.state;
        if (state.lexical.prev) {
          if (state.lexical.type == ")") state.indented = state.lexical.indented;
          state.lexical = state.lexical.prev;
        }
      }
      poplex.lex = true;
      function expect(wanted) {
        function exp(type) {
          if (type == wanted) return cont();else if (wanted == ";") return pass();else return cont(exp);
        }
        ;
        return exp;
      }
      function statement(type, value) {
        if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
        if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
        if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
        if (type == "{") return cont(pushlex("}"), block, poplex);
        if (type == ";") return cont();
        if (type == "if") {
          if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex) cx.state.cc.pop()();
          return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
        }
        if (type == "function") return cont(functiondef);
        if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
        if (type == "variable") return cont(pushlex("stat"), maybelabel);
        if (type == "switch") return cont(pushlex("form"), parenExpr, pushlex("}", "switch"), expect("{"), block, poplex, poplex);
        if (type == "case") return cont(expression, expect(":"));
        if (type == "default") return cont(expect(":"));
        if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"), statement, poplex, popcontext);
        if (type == "class") return cont(pushlex("form"), className, poplex);
        if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
        if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
        if (type == "module") return cont(pushlex("form"), pattern, pushlex("}"), expect("{"), block, poplex, poplex);
        if (type == "type") return cont(typeexpr, expect("operator"), typeexpr, expect(";"));
        if (type == "async") return cont(statement);
        return pass(pushlex("stat"), expression, expect(";"), poplex);
      }
      function expression(type) {
        return expressionInner(type, false);
      }
      function expressionNoComma(type) {
        return expressionInner(type, true);
      }
      function parenExpr(type) {
        if (type != "(") return pass();
        return cont(pushlex(")"), expression, expect(")"), poplex);
      }
      function expressionInner(type, noComma) {
        if (cx.state.fatArrowAt == cx.stream.start) {
          var body = noComma ? arrowBodyNoComma : arrowBody;
          if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
        }
        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
        if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
        if (type == "function") return cont(functiondef, maybeop);
        if (type == "class") return cont(pushlex("form"), classExpression, poplex);
        if (type == "keyword c" || type == "async") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
        if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
        if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
        if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
        if (type == "{") return contCommasep(objprop, "}", null, maybeop);
        if (type == "quasi") return pass(quasi, maybeop);
        if (type == "new") return cont(maybeTarget(noComma));
        return cont();
      }
      function maybeexpression(type) {
        if (type.match(/[;\}\)\],]/)) return pass();
        return pass(expression);
      }
      function maybeexpressionNoComma(type) {
        if (type.match(/[;\}\)\],]/)) return pass();
        return pass(expressionNoComma);
      }
      function maybeoperatorComma(type, value) {
        if (type == ",") return cont(expression);
        return maybeoperatorNoComma(type, value, false);
      }
      function maybeoperatorNoComma(type, value, noComma) {
        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
        var expr = noComma == false ? expression : expressionNoComma;
        if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
        if (type == "operator") {
          if (/\+\+|--/.test(value)) return cont(me);
          if (value == "?") return cont(expression, expect(":"), expr);
          return cont(expr);
        }
        if (type == "quasi") {
          return pass(quasi, me);
        }
        if (type == ";") return;
        if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
        if (type == ".") return cont(property, me);
        if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
      }
      function quasi(type, value) {
        if (type != "quasi") return pass();
        if (value.slice(value.length - 2) != "${") return cont(quasi);
        return cont(expression, continueQuasi);
      }
      function continueQuasi(type) {
        if (type == "}") {
          cx.marked = "string-2";
          cx.state.tokenize = tokenQuasi;
          return cont(quasi);
        }
      }
      function arrowBody(type) {
        findFatArrow(cx.stream, cx.state);
        return pass(type == "{" ? statement : expression);
      }
      function arrowBodyNoComma(type) {
        findFatArrow(cx.stream, cx.state);
        return pass(type == "{" ? statement : expressionNoComma);
      }
      function maybeTarget(noComma) {
        return function (type) {
          if (type == ".") return cont(noComma ? targetNoComma : target);else return pass(noComma ? expressionNoComma : expression);
        };
      }
      function target(_, value) {
        if (value == "target") {
          cx.marked = "keyword";
          return cont(maybeoperatorComma);
        }
      }
      function targetNoComma(_, value) {
        if (value == "target") {
          cx.marked = "keyword";
          return cont(maybeoperatorNoComma);
        }
      }
      function maybelabel(type) {
        if (type == ":") return cont(poplex, statement);
        return pass(maybeoperatorComma, expect(";"), poplex);
      }
      function property(type) {
        if (type == "variable") {
          cx.marked = "property";
          return cont();
        }
      }
      function objprop(type, value) {
        if (type == "async") {
          cx.marked = "property";
          return cont(objprop);
        } else if (type == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          if (value == "get" || value == "set") return cont(getterSetter);
          return cont(afterprop);
        } else if (type == "number" || type == "string") {
          cx.marked = jsonldMode ? "property" : cx.style + " property";
          return cont(afterprop);
        } else if (type == "jsonld-keyword") {
          return cont(afterprop);
        } else if (type == "modifier") {
          return cont(objprop);
        } else if (type == "[") {
          return cont(expression, expect("]"), afterprop);
        } else if (type == "spread") {
          return cont(expression);
        } else if (type == ":") {
          return pass(afterprop);
        }
      }
      function getterSetter(type) {
        if (type != "variable") return pass(afterprop);
        cx.marked = "property";
        return cont(functiondef);
      }
      function afterprop(type) {
        if (type == ":") return cont(expressionNoComma);
        if (type == "(") return pass(functiondef);
      }
      function commasep(what, end) {
        function proceed(type, value) {
          if (type == ",") {
            var lex = cx.state.lexical;
            if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
            return cont(function (type, value) {
              if (type == end || value == end) return pass();
              return pass(what);
            }, proceed);
          }
          if (type == end || value == end) return cont();
          return cont(expect(end));
        }
        return function (type, value) {
          if (type == end || value == end) return cont();
          return pass(what, proceed);
        };
      }
      function contCommasep(what, end, info) {
        for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i]);
        return cont(pushlex(end, info), commasep(what, end), poplex);
      }
      function block(type) {
        if (type == "}") return cont();
        return pass(statement, block);
      }
      function maybetype(type, value) {
        if (isTS) {
          if (type == ":") return cont(typeexpr);
          if (value == "?") return cont(maybetype);
        }
      }
      function typeexpr(type) {
        if (type == "variable") {
          cx.marked = "variable-3";
          return cont(afterType);
        }
        if (type == "{") return cont(commasep(typeprop, "}"));
        if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType);
      }
      function maybeReturnType(type) {
        if (type == "=>") return cont(typeexpr);
      }
      function typeprop(type) {
        if (type == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          return cont(typeprop);
        } else if (type == ":") {
          return cont(typeexpr);
        }
      }
      function typearg(type) {
        if (type == "variable") return cont(typearg);else if (type == ":") return cont(typeexpr);
      }
      function afterType(type, value) {
        if (value == "<") return cont(commasep(typeexpr, ">"), afterType);
        if (type == "[") return cont(expect("]"), afterType);
      }
      function vardef() {
        return pass(pattern, maybetype, maybeAssign, vardefCont);
      }
      function pattern(type, value) {
        if (type == "modifier") return cont(pattern);
        if (type == "variable") {
          register(value);
          return cont();
        }
        if (type == "spread") return cont(pattern);
        if (type == "[") return contCommasep(pattern, "]");
        if (type == "{") return contCommasep(proppattern, "}");
      }
      function proppattern(type, value) {
        if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
          register(value);
          return cont(maybeAssign);
        }
        if (type == "variable") cx.marked = "property";
        if (type == "spread") return cont(pattern);
        if (type == "}") return pass();
        return cont(expect(":"), pattern, maybeAssign);
      }
      function maybeAssign(_type, value) {
        if (value == "=") return cont(expressionNoComma);
      }
      function vardefCont(type) {
        if (type == ",") return cont(vardef);
      }
      function maybeelse(type, value) {
        if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
      }
      function forspec(type) {
        if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
      }
      function forspec1(type) {
        if (type == "var") return cont(vardef, expect(";"), forspec2);
        if (type == ";") return cont(forspec2);
        if (type == "variable") return cont(formaybeinof);
        return pass(expression, expect(";"), forspec2);
      }
      function formaybeinof(_type, value) {
        if (value == "in" || value == "of") {
          cx.marked = "keyword";
          return cont(expression);
        }
        return cont(maybeoperatorComma, forspec2);
      }
      function forspec2(type, value) {
        if (type == ";") return cont(forspec3);
        if (value == "in" || value == "of") {
          cx.marked = "keyword";
          return cont(expression);
        }
        return pass(expression, expect(";"), forspec3);
      }
      function forspec3(type) {
        if (type != ")") cont(expression);
      }
      function functiondef(type, value) {
        if (value == "*") {
          cx.marked = "keyword";
          return cont(functiondef);
        }
        if (type == "variable") {
          register(value);
          return cont(functiondef);
        }
        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, maybetype, statement, popcontext);
      }
      function funarg(type) {
        if (type == "spread") return cont(funarg);
        return pass(pattern, maybetype, maybeAssign);
      }
      function classExpression(type, value) {
        if (type == "variable") return className(type, value);
        return classNameAfter(type, value);
      }
      function className(type, value) {
        if (type == "variable") {
          register(value);
          return cont(classNameAfter);
        }
      }
      function classNameAfter(type, value) {
        if (value == "extends" || value == "implements") return cont(isTS ? typeexpr : expression, classNameAfter);
        if (type == "{") return cont(pushlex("}"), classBody, poplex);
      }
      function classBody(type, value) {
        if (type == "variable" || cx.style == "keyword") {
          if ((value == "static" || value == "get" || value == "set" || isTS && (value == "public" || value == "private" || value == "protected" || value == "readonly" || value == "abstract")) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
            cx.marked = "keyword";
            return cont(classBody);
          }
          cx.marked = "property";
          return cont(isTS ? classfield : functiondef, classBody);
        }
        if (value == "*") {
          cx.marked = "keyword";
          return cont(classBody);
        }
        if (type == ";") return cont(classBody);
        if (type == "}") return cont();
      }
      function classfield(type, value) {
        if (value == "?") return cont(classfield);
        if (type == ":") return cont(typeexpr, maybeAssign);
        return pass(functiondef);
      }
      function afterExport(_type, value) {
        if (value == "*") {
          cx.marked = "keyword";
          return cont(maybeFrom, expect(";"));
        }
        if (value == "default") {
          cx.marked = "keyword";
          return cont(expression, expect(";"));
        }
        return pass(statement);
      }
      function afterImport(type) {
        if (type == "string") return cont();
        return pass(importSpec, maybeFrom);
      }
      function importSpec(type, value) {
        if (type == "{") return contCommasep(importSpec, "}");
        if (type == "variable") register(value);
        if (value == "*") cx.marked = "keyword";
        return cont(maybeAs);
      }
      function maybeAs(_type, value) {
        if (value == "as") {
          cx.marked = "keyword";
          return cont(importSpec);
        }
      }
      function maybeFrom(_type, value) {
        if (value == "from") {
          cx.marked = "keyword";
          return cont(expression);
        }
      }
      function arrayLiteral(type) {
        if (type == "]") return cont();
        return pass(commasep(expressionNoComma, "]"));
      }
      function isContinuedStatement(state, textAfter) {
        return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
      }
      return {
        startState: function (basecolumn) {
          var state = {
            tokenize: tokenBase,
            lastType: "sof",
            cc: [],
            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
            localVars: parserConfig.localVars,
            context: parserConfig.localVars && { vars: parserConfig.localVars },
            indented: basecolumn || 0
          };
          if (parserConfig.globalVars && typeof parserConfig.globalVars == "object") state.globalVars = parserConfig.globalVars;
          return state;
        },
        token: function (stream, state) {
          if (stream.sol()) {
            if (!state.lexical.hasOwnProperty("align")) state.lexical.align = false;
            state.indented = stream.indentation();
            findFatArrow(stream, state);
          }
          if (state.tokenize != tokenComment && stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          if (type == "comment") return style;
          state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
          return parseJS(state, style, type, content, stream);
        },
        indent: function (state, textAfter) {
          if (state.tokenize == tokenComment) return CodeMirror.Pass;
          if (state.tokenize != tokenBase) return 0;
          var firstChar = textAfter && textAfter.charAt(0),
              lexical = state.lexical,
              top;
          if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
            var c = state.cc[i];
            if (c == poplex) lexical = lexical.prev;else if (c != maybeelse) break;
          }
          while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter))) lexical = lexical.prev;
          if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat") lexical = lexical.prev;
          var type = lexical.type,
              closing = firstChar == type;
          if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);else if (type == "form" && firstChar == "{") return lexical.indented;else if (type == "form") return lexical.indented + indentUnit;else if (type == "stat") return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);
        },
        electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
        blockCommentStart: jsonMode ? null : "/*",
        blockCommentEnd: jsonMode ? null : "*/",
        lineComment: jsonMode ? null : "//",
        fold: "brace",
        closeBrackets: "()[]{}''\"\"``",
        helperType: jsonMode ? "json" : "javascript",
        jsonldMode: jsonldMode,
        jsonMode: jsonMode,
        expressionAllowed: expressionAllowed,
        skipExpression: function (state) {
          var top = state.cc[state.cc.length - 1];
          if (top == expression || top == expressionNoComma) state.cc.pop();
        }
      };
    });
    CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
    CodeMirror.defineMIME("text/javascript", "javascript");
    CodeMirror.defineMIME("text/ecmascript", "javascript");
    CodeMirror.defineMIME("application/javascript", "javascript");
    CodeMirror.defineMIME("application/x-javascript", "javascript");
    CodeMirror.defineMIME("application/ecmascript", "javascript");
    CodeMirror.defineMIME("application/json", {
      name: "javascript",
      json: true
    });
    CodeMirror.defineMIME("application/x-json", {
      name: "javascript",
      json: true
    });
    CodeMirror.defineMIME("application/ld+json", {
      name: "javascript",
      jsonld: true
    });
    CodeMirror.defineMIME("text/typescript", {
      name: "javascript",
      typescript: true
    });
    CodeMirror.defineMIME("application/typescript", {
      name: "javascript",
      typescript: true
    });
  });
});
System.register('src/ast-builders.js', ['npm:babel-runtime@5.8.38/core-js/object/keys.js', 'npm:recast@0.11.18.js'], function (_export) {
    var _Object$keys, recast, b;

    function clearStmt() {
        // CLEAR();
        return b.expressionStatement(b.callExpression(b.identifier('CLEAR'), []));
    }

    function useStrictStmt() {
        // 'use strict';
        return b.expressionStatement(literal('use strict'));
    }

    function enterStmt(fnDecl) {
        var loc = literal(fnDecl.loc);
        var name = fnDecl.id && fnDecl.id.name || 'anonymous';
        // ENTER('name', name, loc)
        return b.expressionStatement(b.callExpression(b.identifier('ENTER'), [b.literal(name), name === 'anonymous' ? literal(null) : b.identifier(name), b.identifier('arguments'), b.identifier('this'), loc]));
    }

    function loopStmt(node) {
        var loc = literal(node.loc);
        // LOOP(loc)
        return b.expressionStatement(b.callExpression(b.identifier('LOOP'), [loc]));
    }

    function leaveStmt(node) {
        node = node || literal(undefined);
        var loc = node != null ? literal(node.loc) : null;
        // LEAVE(node, loc)
        return b.callExpression(b.identifier('LEAVE'), [node, loc]);
    }

    function throwStmt(node) {
        node = node || literal(undefined);
        var loc = node != null ? literal(node.loc) : null;
        // THROW(node, loc)
        return b.callExpression(b.identifier('THROW'), [node, loc]);
    }

    function catchStmt(node, fnNode) {
        var param = node.param;
        var nodeLoc = node != null ? literal(node.loc) : null;
        var fnLoc = fnNode != null ? literal(fnNode.loc) : null;
        // CATCH(nodeLoc, fnLoc)
        return b.expressionStatement(b.callExpression(b.identifier('CATCH'), [node.param, nodeLoc, fnLoc]));
    }

    function literal(item) {
        var ans = undefined;
        switch (typeof item) {
            case 'undefined':
                ans = b.identifier('undefined');
                break;
            case 'object':
                if (item === null) {
                    ans = b.literal(item);
                } else {
                    ans = objectLiteral(item);
                }
                break;
            case 'boolean':
            case 'number':
            case 'string':
                ans = b.literal(item);
                break;
            default:
                throw new Error('can\'t make ast for literal');
        }
        return ans;
    }

    function objectLiteral(object) {
        var properties = _Object$keys(object).map(function (key) {
            return b.property('init', b.identifier(key), literal(object[key]));
        });

        return b.objectExpression(properties);
    }
    return {
        setters: [function (_npmBabelRuntime5838CoreJsObjectKeysJs) {
            _Object$keys = _npmBabelRuntime5838CoreJsObjectKeysJs['default'];
        }, function (_npmRecast01118Js) {
            recast = _npmRecast01118Js['default'];
        }],
        execute: function () {
            'use strict';

            _export('clearStmt', clearStmt);

            _export('useStrictStmt', useStrictStmt);

            _export('enterStmt', enterStmt);

            _export('loopStmt', loopStmt);

            _export('leaveStmt', leaveStmt);

            _export('throwStmt', throwStmt);

            _export('catchStmt', catchStmt);

            _export('literal', literal);

            b = recast.types.builders;
        }
    };
});
System.register("src/instrument.js", ["npm:recast@0.11.18.js", "src/ast-builders.js"], function (_export) {
    "use strict";

    var recast, clearStmt, useStrictStmt, enterStmt, loopStmt, leaveStmt, throwStmt, catchStmt, b, visit, currentFunction;

    _export("default", instrument);

    function instrument(inputCode) {
        var instrumented = recast.print(transform(recast.parse(inputCode, {
            sourceFileName: 'input'
        })), {
            sourceMapName: 'map'
        });
        return instrumented;
    }

    function transform(ast) {
        visit(ast, {
            visitProgram: function visitProgram(path) {
                var node = path.node;
                node.body.unshift(clearStmt());
                node.body.unshift(useStrictStmt());
                this.traverse(path);
            },

            visitFunction: visitEnter,
            visitFunctionDeclaration: visitEnter,
            visitFunctionExpression: visitEnter,

            visitWhileStatement: visitLoop,
            visitDoWhileStatement: visitLoop,
            visitForStatement: visitLoop,
            visitForInStatement: visitLoop,

            visitReturnStatement: visitLeave,
            visitThrowStatement: visitThrow,

            visitCatchClause: visitCatchClause
        });

        return ast;
    }

    function visitEnter(path) {
        var node = path.node;
        var body = undefined;
        if (node.body instanceof Array) {
            body = path.get('body');
        } else if (node.body.constructor.name === 'BlockStatement') {
            body = path.get('body', 'body');
        }

        body.unshift(enterStmt(node));
        body.push(b.expressionStatement(leaveStmt()));

        var oldFn = currentFunction;
        currentFunction = node;

        this.traverse(path);

        currentFunction = oldFn;
    }

    function visitLoop(path) {
        var node = path.node;
        var body = undefined;
        if (node.body instanceof Array) {
            body = path.get('body');
        } else if (node.body.constructor.name === 'BlockStatement') {
            body = path.get('body', 'body');
        }

        body.unshift(loopStmt(node));
        this.traverse(path);
    }

    function visitLeave(path) {
        var node = path.node;
        node.argument = leaveStmt(node.argument);
        return this.traverse(path);
    }

    function visitThrow(path) {
        var node = path.node;
        node.argument = throwStmt(node.argument);
        return this.traverse(path);
    }

    function visitCatchClause(path) {
        var node = path.node;

        var body = undefined;
        if (node.body instanceof Array) {
            body = path.get('body');
        } else if (node.body.constructor.name === 'BlockStatement') {
            body = path.get('body', 'body');
        }

        body.unshift(catchStmt(node, currentFunction));

        return this.traverse(path);
    }
    return {
        setters: [function (_npmRecast01118Js) {
            recast = _npmRecast01118Js["default"];
        }, function (_srcAstBuildersJs) {
            clearStmt = _srcAstBuildersJs.clearStmt;
            useStrictStmt = _srcAstBuildersJs.useStrictStmt;
            enterStmt = _srcAstBuildersJs.enterStmt;
            loopStmt = _srcAstBuildersJs.loopStmt;
            leaveStmt = _srcAstBuildersJs.leaveStmt;
            throwStmt = _srcAstBuildersJs.throwStmt;
            catchStmt = _srcAstBuildersJs.catchStmt;
        }],
        execute: function () {
            b = recast.types.builders;
            visit = recast.types.visit;
            currentFunction = null;
        }
    };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.iter-detect.js', ['npm:core-js@1.2.7/library/modules/$.wks.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var ITERATOR = $__require('npm:core-js@1.2.7/library/modules/$.wks.js')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function () {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function () {
      throw 2;
    });
  } catch (e) {}
  module.exports = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function () {
        return { done: safe = true };
      };
      arr[ITERATOR] = function () {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/es6.array.from.js', ['npm:core-js@1.2.7/library/modules/$.ctx.js', 'npm:core-js@1.2.7/library/modules/$.export.js', 'npm:core-js@1.2.7/library/modules/$.to-object.js', 'npm:core-js@1.2.7/library/modules/$.iter-call.js', 'npm:core-js@1.2.7/library/modules/$.is-array-iter.js', 'npm:core-js@1.2.7/library/modules/$.to-length.js', 'npm:core-js@1.2.7/library/modules/core.get-iterator-method.js', 'npm:core-js@1.2.7/library/modules/$.iter-detect.js'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ctx = $__require('npm:core-js@1.2.7/library/modules/$.ctx.js'),
      $export = $__require('npm:core-js@1.2.7/library/modules/$.export.js'),
      toObject = $__require('npm:core-js@1.2.7/library/modules/$.to-object.js'),
      call = $__require('npm:core-js@1.2.7/library/modules/$.iter-call.js'),
      isArrayIter = $__require('npm:core-js@1.2.7/library/modules/$.is-array-iter.js'),
      toLength = $__require('npm:core-js@1.2.7/library/modules/$.to-length.js'),
      getIterFn = $__require('npm:core-js@1.2.7/library/modules/core.get-iterator-method.js');
  $export($export.S + $export.F * !$__require('npm:core-js@1.2.7/library/modules/$.iter-detect.js')(function (iter) {
    Array.from(iter);
  }), 'Array', { from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          $$ = arguments,
          $$len = $$.length,
          mapfn = $$len > 1 ? $$[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping) mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    } });
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/array/from.js', ['npm:core-js@1.2.7/library/modules/es6.string.iterator.js', 'npm:core-js@1.2.7/library/modules/es6.array.from.js', 'npm:core-js@1.2.7/library/modules/$.core.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('npm:core-js@1.2.7/library/modules/es6.string.iterator.js');
  $__require('npm:core-js@1.2.7/library/modules/es6.array.from.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.core.js').Array.from;
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/array/from.js", ["npm:core-js@1.2.7/library/fn/array/from.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/array/from.js"), __esModule: true };
});
System.registerDynamic("npm:babel-runtime@5.8.38/helpers/to-consumable-array.js", ["npm:babel-runtime@5.8.38/core-js/array/from.js"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Array$from = $__require("npm:babel-runtime@5.8.38/core-js/array/from.js")["default"];
  exports["default"] = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
      return arr2;
    } else {
      return _Array$from(arr);
    }
  };
  exports.__esModule = true;
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/es6.object.to-string.js", [], true, function ($__require, exports, module) {
  /* */
  "format cjs";

  var global = this || self,
      GLOBAL = global;
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.is-array.js', ['npm:core-js@1.2.7/library/modules/$.cof.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var cof = $__require('npm:core-js@1.2.7/library/modules/$.cof.js');
  module.exports = Array.isArray || function (arg) {
    return cof(arg) == 'Array';
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.array-species-create.js', ['npm:core-js@1.2.7/library/modules/$.is-object.js', 'npm:core-js@1.2.7/library/modules/$.is-array.js', 'npm:core-js@1.2.7/library/modules/$.wks.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('npm:core-js@1.2.7/library/modules/$.is-object.js'),
      isArray = $__require('npm:core-js@1.2.7/library/modules/$.is-array.js'),
      SPECIES = $__require('npm:core-js@1.2.7/library/modules/$.wks.js')('species');
  module.exports = function (original, length) {
    var C;
    if (isArray(original)) {
      C = original.constructor;
      if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
      if (isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = undefined;
      }
    }
    return new (C === undefined ? Array : C)(length);
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.array-methods.js', ['npm:core-js@1.2.7/library/modules/$.ctx.js', 'npm:core-js@1.2.7/library/modules/$.iobject.js', 'npm:core-js@1.2.7/library/modules/$.to-object.js', 'npm:core-js@1.2.7/library/modules/$.to-length.js', 'npm:core-js@1.2.7/library/modules/$.array-species-create.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var ctx = $__require('npm:core-js@1.2.7/library/modules/$.ctx.js'),
      IObject = $__require('npm:core-js@1.2.7/library/modules/$.iobject.js'),
      toObject = $__require('npm:core-js@1.2.7/library/modules/$.to-object.js'),
      toLength = $__require('npm:core-js@1.2.7/library/modules/$.to-length.js'),
      asc = $__require('npm:core-js@1.2.7/library/modules/$.array-species-create.js');
  module.exports = function (TYPE) {
    var IS_MAP = TYPE == 1,
        IS_FILTER = TYPE == 2,
        IS_SOME = TYPE == 3,
        IS_EVERY = TYPE == 4,
        IS_FIND_INDEX = TYPE == 6,
        NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function ($this, callbackfn, that) {
      var O = toObject($this),
          self = IObject(O),
          f = ctx(callbackfn, that, 3),
          length = toLength(self.length),
          index = 0,
          result = IS_MAP ? asc($this, length) : IS_FILTER ? asc($this, 0) : undefined,
          val,
          res;
      for (; length > index; index++) if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res;else if (res) switch (TYPE) {
            case 3:
              return true;
            case 5:
              return val;
            case 6:
              return index;
            case 2:
              result.push(val);
          } else if (IS_EVERY) return false;
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.collection-weak.js', ['npm:core-js@1.2.7/library/modules/$.hide.js', 'npm:core-js@1.2.7/library/modules/$.redefine-all.js', 'npm:core-js@1.2.7/library/modules/$.an-object.js', 'npm:core-js@1.2.7/library/modules/$.is-object.js', 'npm:core-js@1.2.7/library/modules/$.strict-new.js', 'npm:core-js@1.2.7/library/modules/$.for-of.js', 'npm:core-js@1.2.7/library/modules/$.array-methods.js', 'npm:core-js@1.2.7/library/modules/$.has.js', 'npm:core-js@1.2.7/library/modules/$.uid.js'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var hide = $__require('npm:core-js@1.2.7/library/modules/$.hide.js'),
      redefineAll = $__require('npm:core-js@1.2.7/library/modules/$.redefine-all.js'),
      anObject = $__require('npm:core-js@1.2.7/library/modules/$.an-object.js'),
      isObject = $__require('npm:core-js@1.2.7/library/modules/$.is-object.js'),
      strictNew = $__require('npm:core-js@1.2.7/library/modules/$.strict-new.js'),
      forOf = $__require('npm:core-js@1.2.7/library/modules/$.for-of.js'),
      createArrayMethod = $__require('npm:core-js@1.2.7/library/modules/$.array-methods.js'),
      $has = $__require('npm:core-js@1.2.7/library/modules/$.has.js'),
      WEAK = $__require('npm:core-js@1.2.7/library/modules/$.uid.js')('weak'),
      isExtensible = Object.isExtensible || isObject,
      arrayFind = createArrayMethod(5),
      arrayFindIndex = createArrayMethod(6),
      id = 0;
  var frozenStore = function (that) {
    return that._l || (that._l = new FrozenStore());
  };
  var FrozenStore = function () {
    this.a = [];
  };
  var findFrozen = function (store, key) {
    return arrayFind(store.a, function (it) {
      return it[0] === key;
    });
  };
  FrozenStore.prototype = {
    get: function (key) {
      var entry = findFrozen(this, key);
      if (entry) return entry[1];
    },
    has: function (key) {
      return !!findFrozen(this, key);
    },
    set: function (key, value) {
      var entry = findFrozen(this, key);
      if (entry) entry[1] = value;else this.a.push([key, value]);
    },
    'delete': function (key) {
      var index = arrayFindIndex(this.a, function (it) {
        return it[0] === key;
      });
      if (~index) this.a.splice(index, 1);
      return !!~index;
    }
  };
  module.exports = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        strictNew(that, C, NAME);
        that._i = id++;
        that._l = undefined;
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        'delete': function (key) {
          if (!isObject(key)) return false;
          if (!isExtensible(key)) return frozenStore(this)['delete'](key);
          return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
        },
        has: function has(key) {
          if (!isObject(key)) return false;
          if (!isExtensible(key)) return frozenStore(this).has(key);
          return $has(key, WEAK) && $has(key[WEAK], this._i);
        }
      });
      return C;
    },
    def: function (that, key, value) {
      if (!isExtensible(anObject(key))) {
        frozenStore(that).set(key, value);
      } else {
        $has(key, WEAK) || hide(key, WEAK, {});
        key[WEAK][that._i] = value;
      }
      return that;
    },
    frozenStore: frozenStore,
    WEAK: WEAK
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.redefine-all.js', ['npm:core-js@1.2.7/library/modules/$.redefine.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var redefine = $__require('npm:core-js@1.2.7/library/modules/$.redefine.js');
  module.exports = function (target, src) {
    for (var key in src) redefine(target, key, src[key]);
    return target;
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.iter-call.js', ['npm:core-js@1.2.7/library/modules/$.an-object.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var anObject = $__require('npm:core-js@1.2.7/library/modules/$.an-object.js');
  module.exports = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) anObject(ret.call(iterator));
      throw e;
    }
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.is-array-iter.js', ['npm:core-js@1.2.7/library/modules/$.iterators.js', 'npm:core-js@1.2.7/library/modules/$.wks.js'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var Iterators = $__require('npm:core-js@1.2.7/library/modules/$.iterators.js'),
        ITERATOR = $__require('npm:core-js@1.2.7/library/modules/$.wks.js')('iterator'),
        ArrayProto = Array.prototype;
    module.exports = function (it) {
        return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
    };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.to-length.js', ['npm:core-js@1.2.7/library/modules/$.to-integer.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toInteger = $__require('npm:core-js@1.2.7/library/modules/$.to-integer.js'),
      min = Math.min;
  module.exports = function (it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.for-of.js', ['npm:core-js@1.2.7/library/modules/$.ctx.js', 'npm:core-js@1.2.7/library/modules/$.iter-call.js', 'npm:core-js@1.2.7/library/modules/$.is-array-iter.js', 'npm:core-js@1.2.7/library/modules/$.an-object.js', 'npm:core-js@1.2.7/library/modules/$.to-length.js', 'npm:core-js@1.2.7/library/modules/core.get-iterator-method.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var ctx = $__require('npm:core-js@1.2.7/library/modules/$.ctx.js'),
      call = $__require('npm:core-js@1.2.7/library/modules/$.iter-call.js'),
      isArrayIter = $__require('npm:core-js@1.2.7/library/modules/$.is-array-iter.js'),
      anObject = $__require('npm:core-js@1.2.7/library/modules/$.an-object.js'),
      toLength = $__require('npm:core-js@1.2.7/library/modules/$.to-length.js'),
      getIterFn = $__require('npm:core-js@1.2.7/library/modules/core.get-iterator-method.js');
  module.exports = function (iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
      entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      call(iterator, f, step.value, entries);
    }
  };
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.strict-new.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it, Constructor, name) {
    if (!(it instanceof Constructor)) throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.collection.js', ['npm:core-js@1.2.7/library/modules/$.js', 'npm:core-js@1.2.7/library/modules/$.global.js', 'npm:core-js@1.2.7/library/modules/$.export.js', 'npm:core-js@1.2.7/library/modules/$.fails.js', 'npm:core-js@1.2.7/library/modules/$.hide.js', 'npm:core-js@1.2.7/library/modules/$.redefine-all.js', 'npm:core-js@1.2.7/library/modules/$.for-of.js', 'npm:core-js@1.2.7/library/modules/$.strict-new.js', 'npm:core-js@1.2.7/library/modules/$.is-object.js', 'npm:core-js@1.2.7/library/modules/$.set-to-string-tag.js', 'npm:core-js@1.2.7/library/modules/$.descriptors.js'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('npm:core-js@1.2.7/library/modules/$.js'),
      global = $__require('npm:core-js@1.2.7/library/modules/$.global.js'),
      $export = $__require('npm:core-js@1.2.7/library/modules/$.export.js'),
      fails = $__require('npm:core-js@1.2.7/library/modules/$.fails.js'),
      hide = $__require('npm:core-js@1.2.7/library/modules/$.hide.js'),
      redefineAll = $__require('npm:core-js@1.2.7/library/modules/$.redefine-all.js'),
      forOf = $__require('npm:core-js@1.2.7/library/modules/$.for-of.js'),
      strictNew = $__require('npm:core-js@1.2.7/library/modules/$.strict-new.js'),
      isObject = $__require('npm:core-js@1.2.7/library/modules/$.is-object.js'),
      setToStringTag = $__require('npm:core-js@1.2.7/library/modules/$.set-to-string-tag.js'),
      DESCRIPTORS = $__require('npm:core-js@1.2.7/library/modules/$.descriptors.js');
  module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
    } else {
      C = wrapper(function (target, iterable) {
        strictNew(target, C, NAME);
        target._c = new Base();
        if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
      });
      $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','), function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
          if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
          var result = this._c[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      });
      if ('size' in proto) $.setDesc(C.prototype, 'size', { get: function () {
          return this._c.size;
        } });
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F, O);
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
    return C;
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/es6.weak-map.js', ['npm:core-js@1.2.7/library/modules/$.js', 'npm:core-js@1.2.7/library/modules/$.redefine.js', 'npm:core-js@1.2.7/library/modules/$.collection-weak.js', 'npm:core-js@1.2.7/library/modules/$.is-object.js', 'npm:core-js@1.2.7/library/modules/$.has.js', 'npm:core-js@1.2.7/library/modules/$.collection.js'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('npm:core-js@1.2.7/library/modules/$.js'),
      redefine = $__require('npm:core-js@1.2.7/library/modules/$.redefine.js'),
      weak = $__require('npm:core-js@1.2.7/library/modules/$.collection-weak.js'),
      isObject = $__require('npm:core-js@1.2.7/library/modules/$.is-object.js'),
      has = $__require('npm:core-js@1.2.7/library/modules/$.has.js'),
      frozenStore = weak.frozenStore,
      WEAK = weak.WEAK,
      isExtensible = Object.isExtensible || isObject,
      tmp = {};
  var $WeakMap = $__require('npm:core-js@1.2.7/library/modules/$.collection.js')('WeakMap', function (get) {
    return function WeakMap() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      if (isObject(key)) {
        if (!isExtensible(key)) return frozenStore(this).get(key);
        if (has(key, WEAK)) return key[WEAK][this._i];
      }
    },
    set: function set(key, value) {
      return weak.def(this, key, value);
    }
  }, weak, true, true);
  if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
    $.each.call(['delete', 'has', 'get', 'set'], function (key) {
      var proto = $WeakMap.prototype,
          method = proto[key];
      redefine(proto, key, function (a, b) {
        if (isObject(a) && !isExtensible(a)) {
          var result = frozenStore(this)[key](a, b);
          return key == 'set' ? this : result;
        }
        return method.call(this, a, b);
      });
    });
  }
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/weak-map.js', ['npm:core-js@1.2.7/library/modules/es6.object.to-string.js', 'npm:core-js@1.2.7/library/modules/web.dom.iterable.js', 'npm:core-js@1.2.7/library/modules/es6.weak-map.js', 'npm:core-js@1.2.7/library/modules/$.core.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('npm:core-js@1.2.7/library/modules/es6.object.to-string.js');
  $__require('npm:core-js@1.2.7/library/modules/web.dom.iterable.js');
  $__require('npm:core-js@1.2.7/library/modules/es6.weak-map.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.core.js').WeakMap;
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/weak-map.js", ["npm:core-js@1.2.7/library/fn/weak-map.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/weak-map.js"), __esModule: true };
});
System.registerDynamic('npm:d3@4.4.0/build/d3.js', ['github:jspm/nodelibs-buffer@0.1.0.js', 'github:jspm/nodelibs-process@0.1.2.js'], true, function ($__require, exports, module) {
  /* */
  "format cjs";

  var global = this || self,
      GLOBAL = global;
  (function (Buffer, process) {
    (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof undefined === 'function' && define.amd ? define(['exports'], factory) : factory(global.d3 = global.d3 || {});
    })(this, function (exports) {
      'use strict';

      var version = "4.4.0";
      var ascending = function (a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      };
      var bisector = function (compare) {
        if (compare.length === 1) compare = ascendingComparator(compare);
        return {
          left: function (a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
            }
            return lo;
          },
          right: function (a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
            }
            return lo;
          }
        };
      };
      function ascendingComparator(f) {
        return function (d, x) {
          return ascending(f(d), x);
        };
      }
      var ascendingBisect = bisector(ascending);
      var bisectRight = ascendingBisect.right;
      var bisectLeft = ascendingBisect.left;
      var descending = function (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
      };
      var number = function (x) {
        return x === null ? NaN : +x;
      };
      var variance = function (array, f) {
        var n = array.length,
            m = 0,
            a,
            d,
            s = 0,
            i = -1,
            j = 0;
        if (f == null) {
          while (++i < n) {
            if (!isNaN(a = number(array[i]))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        } else {
          while (++i < n) {
            if (!isNaN(a = number(f(array[i], i, array)))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        }
        if (j > 1) return s / (j - 1);
      };
      var deviation = function (array, f) {
        var v = variance(array, f);
        return v ? Math.sqrt(v) : v;
      };
      var extent = function (array, f) {
        var i = -1,
            n = array.length,
            a,
            b,
            c;
        if (f == null) {
          while (++i < n) if ((b = array[i]) != null && b >= b) {
            a = c = b;
            break;
          }
          while (++i < n) if ((b = array[i]) != null) {
            if (a > b) a = b;
            if (c < b) c = b;
          }
        } else {
          while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) {
            a = c = b;
            break;
          }
          while (++i < n) if ((b = f(array[i], i, array)) != null) {
            if (a > b) a = b;
            if (c < b) c = b;
          }
        }
        return [a, c];
      };
      var array = Array.prototype;
      var slice = array.slice;
      var map = array.map;
      var constant$1 = function (x) {
        return function () {
          return x;
        };
      };
      var identity = function (x) {
        return x;
      };
      var range = function (start, stop, step) {
        start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
        var i = -1,
            n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
            range = new Array(n);
        while (++i < n) {
          range[i] = start + i * step;
        }
        return range;
      };
      var e10 = Math.sqrt(50);
      var e5 = Math.sqrt(10);
      var e2 = Math.sqrt(2);
      var ticks = function (start, stop, count) {
        var step = tickStep(start, stop, count);
        return range(Math.ceil(start / step) * step, Math.floor(stop / step) * step + step / 2, step);
      };
      function tickStep(start, stop, count) {
        var step0 = Math.abs(stop - start) / Math.max(0, count),
            step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
            error = step0 / step1;
        if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
        return stop < start ? -step1 : step1;
      }
      var sturges = function (values) {
        return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
      };
      var histogram = function () {
        var value = identity,
            domain = extent,
            threshold = sturges;
        function histogram(data) {
          var i,
              n = data.length,
              x,
              values = new Array(n);
          for (i = 0; i < n; ++i) {
            values[i] = value(data[i], i, data);
          }
          var xz = domain(values),
              x0 = xz[0],
              x1 = xz[1],
              tz = threshold(values, x0, x1);
          if (!Array.isArray(tz)) tz = ticks(x0, x1, tz);
          var m = tz.length;
          while (tz[0] <= x0) tz.shift(), --m;
          while (tz[m - 1] >= x1) tz.pop(), --m;
          var bins = new Array(m + 1),
              bin;
          for (i = 0; i <= m; ++i) {
            bin = bins[i] = [];
            bin.x0 = i > 0 ? tz[i - 1] : x0;
            bin.x1 = i < m ? tz[i] : x1;
          }
          for (i = 0; i < n; ++i) {
            x = values[i];
            if (x0 <= x && x <= x1) {
              bins[bisectRight(tz, x, 0, m)].push(data[i]);
            }
          }
          return bins;
        }
        histogram.value = function (_) {
          return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(_), histogram) : value;
        };
        histogram.domain = function (_) {
          return arguments.length ? (domain = typeof _ === "function" ? _ : constant$1([_[0], _[1]]), histogram) : domain;
        };
        histogram.thresholds = function (_) {
          return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$1(slice.call(_)) : constant$1(_), histogram) : threshold;
        };
        return histogram;
      };
      var threshold = function (array, p, f) {
        if (f == null) f = number;
        if (!(n = array.length)) return;
        if ((p = +p) <= 0 || n < 2) return +f(array[0], 0, array);
        if (p >= 1) return +f(array[n - 1], n - 1, array);
        var n,
            h = (n - 1) * p,
            i = Math.floor(h),
            a = +f(array[i], i, array),
            b = +f(array[i + 1], i + 1, array);
        return a + (b - a) * (h - i);
      };
      var freedmanDiaconis = function (values, min, max) {
        values = map.call(values, number).sort(ascending);
        return Math.ceil((max - min) / (2 * (threshold(values, 0.75) - threshold(values, 0.25)) * Math.pow(values.length, -1 / 3)));
      };
      var scott = function (values, min, max) {
        return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
      };
      var max = function (array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (f == null) {
          while (++i < n) if ((b = array[i]) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = array[i]) != null && b > a) a = b;
        } else {
          while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = f(array[i], i, array)) != null && b > a) a = b;
        }
        return a;
      };
      var mean = function (array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1,
            j = n;
        if (f == null) {
          while (++i < n) if (!isNaN(a = number(array[i]))) s += a;else --j;
        } else {
          while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) s += a;else --j;
        }
        if (j) return s / j;
      };
      var median = function (array, f) {
        var numbers = [],
            n = array.length,
            a,
            i = -1;
        if (f == null) {
          while (++i < n) if (!isNaN(a = number(array[i]))) numbers.push(a);
        } else {
          while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) numbers.push(a);
        }
        return threshold(numbers.sort(ascending), 0.5);
      };
      var merge = function (arrays) {
        var n = arrays.length,
            m,
            i = -1,
            j = 0,
            merged,
            array;
        while (++i < n) j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
          array = arrays[n];
          m = array.length;
          while (--m >= 0) {
            merged[--j] = array[m];
          }
        }
        return merged;
      };
      var min = function (array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (f == null) {
          while (++i < n) if ((b = array[i]) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = array[i]) != null && a > b) a = b;
        } else {
          while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = f(array[i], i, array)) != null && a > b) a = b;
        }
        return a;
      };
      var pairs = function (array) {
        var i = 0,
            n = array.length - 1,
            p = array[0],
            pairs = new Array(n < 0 ? 0 : n);
        while (i < n) pairs[i] = [p, p = array[++i]];
        return pairs;
      };
      var permute = function (array, indexes) {
        var i = indexes.length,
            permutes = new Array(i);
        while (i--) permutes[i] = array[indexes[i]];
        return permutes;
      };
      var scan = function (array, compare) {
        if (!(n = array.length)) return;
        var i = 0,
            n,
            j = 0,
            xi,
            xj = array[j];
        if (!compare) compare = ascending;
        while (++i < n) if (compare(xi = array[i], xj) < 0 || compare(xj, xj) !== 0) xj = xi, j = i;
        if (compare(xj, xj) === 0) return j;
      };
      var shuffle = function (array, i0, i1) {
        var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
            t,
            i;
        while (m) {
          i = Math.random() * m-- | 0;
          t = array[m + i0];
          array[m + i0] = array[i + i0];
          array[i + i0] = t;
        }
        return array;
      };
      var sum = function (array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1;
        if (f == null) {
          while (++i < n) if (a = +array[i]) s += a;
        } else {
          while (++i < n) if (a = +f(array[i], i, array)) s += a;
        }
        return s;
      };
      var transpose = function (matrix) {
        if (!(n = matrix.length)) return [];
        for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
          for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
            row[j] = matrix[j][i];
          }
        }
        return transpose;
      };
      function length(d) {
        return d.length;
      }
      var zip = function () {
        return transpose(arguments);
      };
      var prefix = "$";
      function Map() {}
      Map.prototype = map$1.prototype = {
        constructor: Map,
        has: function (key) {
          return prefix + key in this;
        },
        get: function (key) {
          return this[prefix + key];
        },
        set: function (key, value) {
          this[prefix + key] = value;
          return this;
        },
        remove: function (key) {
          var property = prefix + key;
          return property in this && delete this[property];
        },
        clear: function () {
          for (var property in this) if (property[0] === prefix) delete this[property];
        },
        keys: function () {
          var keys = [];
          for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
          return keys;
        },
        values: function () {
          var values = [];
          for (var property in this) if (property[0] === prefix) values.push(this[property]);
          return values;
        },
        entries: function () {
          var entries = [];
          for (var property in this) if (property[0] === prefix) entries.push({
            key: property.slice(1),
            value: this[property]
          });
          return entries;
        },
        size: function () {
          var size = 0;
          for (var property in this) if (property[0] === prefix) ++size;
          return size;
        },
        empty: function () {
          for (var property in this) if (property[0] === prefix) return false;
          return true;
        },
        each: function (f) {
          for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
        }
      };
      function map$1(object, f) {
        var map = new Map();
        if (object instanceof Map) object.each(function (value, key) {
          map.set(key, value);
        });else if (Array.isArray(object)) {
          var i = -1,
              n = object.length,
              o;
          if (f == null) while (++i < n) map.set(i, object[i]);else while (++i < n) map.set(f(o = object[i], i, object), o);
        } else if (object) for (var key in object) map.set(key, object[key]);
        return map;
      }
      var nest = function () {
        var keys = [],
            sortKeys = [],
            sortValues,
            rollup,
            nest;
        function apply(array, depth, createResult, setResult) {
          if (depth >= keys.length) return rollup != null ? rollup(array) : sortValues != null ? array.sort(sortValues) : array;
          var i = -1,
              n = array.length,
              key = keys[depth++],
              keyValue,
              value,
              valuesByKey = map$1(),
              values,
              result = createResult();
          while (++i < n) {
            if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
              values.push(value);
            } else {
              valuesByKey.set(keyValue, [value]);
            }
          }
          valuesByKey.each(function (values, key) {
            setResult(result, key, apply(values, depth, createResult, setResult));
          });
          return result;
        }
        function entries(map, depth) {
          if (++depth > keys.length) return map;
          var array,
              sortKey = sortKeys[depth - 1];
          if (rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
            array.push({
              key: k,
              values: entries(v, depth)
            });
          });
          return sortKey != null ? array.sort(function (a, b) {
            return sortKey(a.key, b.key);
          }) : array;
        }
        return nest = {
          object: function (array) {
            return apply(array, 0, createObject, setObject);
          },
          map: function (array) {
            return apply(array, 0, createMap, setMap);
          },
          entries: function (array) {
            return entries(apply(array, 0, createMap, setMap), 0);
          },
          key: function (d) {
            keys.push(d);
            return nest;
          },
          sortKeys: function (order) {
            sortKeys[keys.length - 1] = order;
            return nest;
          },
          sortValues: function (order) {
            sortValues = order;
            return nest;
          },
          rollup: function (f) {
            rollup = f;
            return nest;
          }
        };
      };
      function createObject() {
        return {};
      }
      function setObject(object, key, value) {
        object[key] = value;
      }
      function createMap() {
        return map$1();
      }
      function setMap(map, key, value) {
        map.set(key, value);
      }
      function Set() {}
      var proto = map$1.prototype;
      Set.prototype = set.prototype = {
        constructor: Set,
        has: proto.has,
        add: function (value) {
          value += "";
          this[prefix + value] = value;
          return this;
        },
        remove: proto.remove,
        clear: proto.clear,
        values: proto.keys,
        size: proto.size,
        empty: proto.empty,
        each: proto.each
      };
      function set(object, f) {
        var set = new Set();
        if (object instanceof Set) object.each(function (value) {
          set.add(value);
        });else if (object) {
          var i = -1,
              n = object.length;
          if (f == null) while (++i < n) set.add(object[i]);else while (++i < n) set.add(f(object[i], i, object));
        }
        return set;
      }
      var keys = function (map) {
        var keys = [];
        for (var key in map) keys.push(key);
        return keys;
      };
      var values = function (map) {
        var values = [];
        for (var key in map) values.push(map[key]);
        return values;
      };
      var entries = function (map) {
        var entries = [];
        for (var key in map) entries.push({
          key: key,
          value: map[key]
        });
        return entries;
      };
      var uniform = function (min, max) {
        min = min == null ? 0 : +min;
        max = max == null ? 1 : +max;
        if (arguments.length === 1) max = min, min = 0;else max -= min;
        return function () {
          return Math.random() * max + min;
        };
      };
      var normal = function (mu, sigma) {
        var x, r;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function () {
          var y;
          if (x != null) y = x, x = null;else do {
            x = Math.random() * 2 - 1;
            y = Math.random() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);
          return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
        };
      };
      var logNormal = function () {
        var randomNormal = normal.apply(this, arguments);
        return function () {
          return Math.exp(randomNormal());
        };
      };
      var irwinHall = function (n) {
        return function () {
          for (var sum = 0, i = 0; i < n; ++i) sum += Math.random();
          return sum;
        };
      };
      var bates = function (n) {
        var randomIrwinHall = irwinHall(n);
        return function () {
          return randomIrwinHall() / n;
        };
      };
      var exponential = function (lambda) {
        return function () {
          return -Math.log(1 - Math.random()) / lambda;
        };
      };
      function linear(t) {
        return +t;
      }
      function quadIn(t) {
        return t * t;
      }
      function quadOut(t) {
        return t * (2 - t);
      }
      function quadInOut(t) {
        return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
      }
      function cubicIn(t) {
        return t * t * t;
      }
      function cubicOut(t) {
        return --t * t * t + 1;
      }
      function cubicInOut(t) {
        return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
      }
      var exponent = 3;
      var polyIn = function custom(e) {
        e = +e;
        function polyIn(t) {
          return Math.pow(t, e);
        }
        polyIn.exponent = custom;
        return polyIn;
      }(exponent);
      var polyOut = function custom(e) {
        e = +e;
        function polyOut(t) {
          return 1 - Math.pow(1 - t, e);
        }
        polyOut.exponent = custom;
        return polyOut;
      }(exponent);
      var polyInOut = function custom(e) {
        e = +e;
        function polyInOut(t) {
          return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
        }
        polyInOut.exponent = custom;
        return polyInOut;
      }(exponent);
      var pi = Math.PI;
      var halfPi = pi / 2;
      function sinIn(t) {
        return 1 - Math.cos(t * halfPi);
      }
      function sinOut(t) {
        return Math.sin(t * halfPi);
      }
      function sinInOut(t) {
        return (1 - Math.cos(pi * t)) / 2;
      }
      function expIn(t) {
        return Math.pow(2, 10 * t - 10);
      }
      function expOut(t) {
        return 1 - Math.pow(2, -10 * t);
      }
      function expInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
      }
      function circleIn(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
      function circleOut(t) {
        return Math.sqrt(1 - --t * t);
      }
      function circleInOut(t) {
        return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
      }
      var b1 = 4 / 11;
      var b2 = 6 / 11;
      var b3 = 8 / 11;
      var b4 = 3 / 4;
      var b5 = 9 / 11;
      var b6 = 10 / 11;
      var b7 = 15 / 16;
      var b8 = 21 / 22;
      var b9 = 63 / 64;
      var b0 = 1 / b1 / b1;
      function bounceIn(t) {
        return 1 - bounceOut(1 - t);
      }
      function bounceOut(t) {
        return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
      }
      function bounceInOut(t) {
        return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
      }
      var overshoot = 1.70158;
      var backIn = function custom(s) {
        s = +s;
        function backIn(t) {
          return t * t * ((s + 1) * t - s);
        }
        backIn.overshoot = custom;
        return backIn;
      }(overshoot);
      var backOut = function custom(s) {
        s = +s;
        function backOut(t) {
          return --t * t * ((s + 1) * t + s) + 1;
        }
        backOut.overshoot = custom;
        return backOut;
      }(overshoot);
      var backInOut = function custom(s) {
        s = +s;
        function backInOut(t) {
          return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
        }
        backInOut.overshoot = custom;
        return backInOut;
      }(overshoot);
      var tau = 2 * Math.PI;
      var amplitude = 1;
      var period = 0.3;
      var elasticIn = function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
        function elasticIn(t) {
          return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
        }
        elasticIn.amplitude = function (a) {
          return custom(a, p * tau);
        };
        elasticIn.period = function (p) {
          return custom(a, p);
        };
        return elasticIn;
      }(amplitude, period);
      var elasticOut = function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
        function elasticOut(t) {
          return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
        }
        elasticOut.amplitude = function (a) {
          return custom(a, p * tau);
        };
        elasticOut.period = function (p) {
          return custom(a, p);
        };
        return elasticOut;
      }(amplitude, period);
      var elasticInOut = function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
        function elasticInOut(t) {
          return ((t = t * 2 - 1) < 0 ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p) : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
        }
        elasticInOut.amplitude = function (a) {
          return custom(a, p * tau);
        };
        elasticInOut.period = function (p) {
          return custom(a, p);
        };
        return elasticInOut;
      }(amplitude, period);
      var area = function (polygon) {
        var i = -1,
            n = polygon.length,
            a,
            b = polygon[n - 1],
            area = 0;
        while (++i < n) {
          a = b;
          b = polygon[i];
          area += a[1] * b[0] - a[0] * b[1];
        }
        return area / 2;
      };
      var centroid = function (polygon) {
        var i = -1,
            n = polygon.length,
            x = 0,
            y = 0,
            a,
            b = polygon[n - 1],
            c,
            k = 0;
        while (++i < n) {
          a = b;
          b = polygon[i];
          k += c = a[0] * b[1] - b[0] * a[1];
          x += (a[0] + b[0]) * c;
          y += (a[1] + b[1]) * c;
        }
        return k *= 3, [x / k, y / k];
      };
      var cross = function (a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
      };
      function lexicographicOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
      }
      function computeUpperHullIndexes(points) {
        var n = points.length,
            indexes = [0, 1],
            size = 2;
        for (var i = 2; i < n; ++i) {
          while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
          indexes[size++] = i;
        }
        return indexes.slice(0, size);
      }
      var hull = function (points) {
        if ((n = points.length) < 3) return null;
        var i,
            n,
            sortedPoints = new Array(n),
            flippedPoints = new Array(n);
        for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
        sortedPoints.sort(lexicographicOrder);
        for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
        var upperIndexes = computeUpperHullIndexes(sortedPoints),
            lowerIndexes = computeUpperHullIndexes(flippedPoints);
        var skipLeft = lowerIndexes[0] === upperIndexes[0],
            skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
            hull = [];
        for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
        for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);
        return hull;
      };
      var contains = function (polygon, point) {
        var n = polygon.length,
            p = polygon[n - 1],
            x = point[0],
            y = point[1],
            x0 = p[0],
            y0 = p[1],
            x1,
            y1,
            inside = false;
        for (var i = 0; i < n; ++i) {
          p = polygon[i], x1 = p[0], y1 = p[1];
          if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) inside = !inside;
          x0 = x1, y0 = y1;
        }
        return inside;
      };
      var length$1 = function (polygon) {
        var i = -1,
            n = polygon.length,
            b = polygon[n - 1],
            xa,
            ya,
            xb = b[0],
            yb = b[1],
            perimeter = 0;
        while (++i < n) {
          xa = xb;
          ya = yb;
          b = polygon[i];
          xb = b[0];
          yb = b[1];
          xa -= xb;
          ya -= yb;
          perimeter += Math.sqrt(xa * xa + ya * ya);
        }
        return perimeter;
      };
      var pi$1 = Math.PI;
      var tau$1 = 2 * pi$1;
      var epsilon = 1e-6;
      var tauEpsilon = tau$1 - epsilon;
      function Path() {
        this._x0 = this._y0 = this._x1 = this._y1 = null;
        this._ = "";
      }
      function path() {
        return new Path();
      }
      Path.prototype = path.prototype = {
        constructor: Path,
        moveTo: function (x, y) {
          this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
        },
        closePath: function () {
          if (this._x1 !== null) {
            this._x1 = this._x0, this._y1 = this._y0;
            this._ += "Z";
          }
        },
        lineTo: function (x, y) {
          this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        quadraticCurveTo: function (x1, y1, x, y) {
          this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        bezierCurveTo: function (x1, y1, x2, y2, x, y) {
          this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        arcTo: function (x1, y1, x2, y2, r) {
          x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
          var x0 = this._x1,
              y0 = this._y1,
              x21 = x2 - x1,
              y21 = y2 - y1,
              x01 = x0 - x1,
              y01 = y0 - y1,
              l01_2 = x01 * x01 + y01 * y01;
          if (r < 0) throw new Error("negative radius: " + r);
          if (this._x1 === null) {
            this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
          } else if (!(l01_2 > epsilon)) {} else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
            this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
          } else {
            var x20 = x2 - x0,
                y20 = y2 - y0,
                l21_2 = x21 * x21 + y21 * y21,
                l20_2 = x20 * x20 + y20 * y20,
                l21 = Math.sqrt(l21_2),
                l01 = Math.sqrt(l01_2),
                l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
                t01 = l / l01,
                t21 = l / l21;
            if (Math.abs(t01 - 1) > epsilon) {
              this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
            }
            this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
          }
        },
        arc: function (x, y, r, a0, a1, ccw) {
          x = +x, y = +y, r = +r;
          var dx = r * Math.cos(a0),
              dy = r * Math.sin(a0),
              x0 = x + dx,
              y0 = y + dy,
              cw = 1 ^ ccw,
              da = ccw ? a0 - a1 : a1 - a0;
          if (r < 0) throw new Error("negative radius: " + r);
          if (this._x1 === null) {
            this._ += "M" + x0 + "," + y0;
          } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
            this._ += "L" + x0 + "," + y0;
          }
          if (!r) return;
          if (da > tauEpsilon) {
            this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
          } else {
            if (da < 0) da = da % tau$1 + tau$1;
            this._ += "A" + r + "," + r + ",0," + +(da >= pi$1) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
          }
        },
        rect: function (x, y, w, h) {
          this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
        },
        toString: function () {
          return this._;
        }
      };
      var tree_add = function (d) {
        var x = +this._x.call(null, d),
            y = +this._y.call(null, d);
        return add(this.cover(x, y), x, y, d);
      };
      function add(tree, x, y, d) {
        if (isNaN(x) || isNaN(y)) return tree;
        var parent,
            node = tree._root,
            leaf = { data: d },
            x0 = tree._x0,
            y0 = tree._y0,
            x1 = tree._x1,
            y1 = tree._y1,
            xm,
            ym,
            xp,
            yp,
            right,
            bottom,
            i,
            j;
        if (!node) return tree._root = leaf, tree;
        while (node.length) {
          if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
          if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
          if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
        }
        xp = +tree._x.call(null, node.data);
        yp = +tree._y.call(null, node.data);
        if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
        do {
          parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
          if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
          if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
        } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
        return parent[j] = node, parent[i] = leaf, tree;
      }
      function addAll(data) {
        var d,
            i,
            n = data.length,
            x,
            y,
            xz = new Array(n),
            yz = new Array(n),
            x0 = Infinity,
            y0 = Infinity,
            x1 = -Infinity,
            y1 = -Infinity;
        for (i = 0; i < n; ++i) {
          if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
          xz[i] = x;
          yz[i] = y;
          if (x < x0) x0 = x;
          if (x > x1) x1 = x;
          if (y < y0) y0 = y;
          if (y > y1) y1 = y;
        }
        if (x1 < x0) x0 = this._x0, x1 = this._x1;
        if (y1 < y0) y0 = this._y0, y1 = this._y1;
        this.cover(x0, y0).cover(x1, y1);
        for (i = 0; i < n; ++i) {
          add(this, xz[i], yz[i], data[i]);
        }
        return this;
      }
      var tree_cover = function (x, y) {
        if (isNaN(x = +x) || isNaN(y = +y)) return this;
        var x0 = this._x0,
            y0 = this._y0,
            x1 = this._x1,
            y1 = this._y1;
        if (isNaN(x0)) {
          x1 = (x0 = Math.floor(x)) + 1;
          y1 = (y0 = Math.floor(y)) + 1;
        } else if (x0 > x || x > x1 || y0 > y || y > y1) {
          var z = x1 - x0,
              node = this._root,
              parent,
              i;
          switch (i = (y < (y0 + y1) / 2) << 1 | x < (x0 + x1) / 2) {
            case 0:
              {
                do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1));
                break;
              }
            case 1:
              {
                do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1));
                break;
              }
            case 2:
              {
                do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y));
                break;
              }
            case 3:
              {
                do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y));
                break;
              }
          }
          if (this._root && this._root.length) this._root = node;
        } else return this;
        this._x0 = x0;
        this._y0 = y0;
        this._x1 = x1;
        this._y1 = y1;
        return this;
      };
      var tree_data = function () {
        var data = [];
        this.visit(function (node) {
          if (!node.length) do data.push(node.data); while (node = node.next);
        });
        return data;
      };
      var tree_extent = function (_) {
        return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
      };
      var Quad = function (node, x0, y0, x1, y1) {
        this.node = node;
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
      };
      var tree_find = function (x, y, radius) {
        var data,
            x0 = this._x0,
            y0 = this._y0,
            x1,
            y1,
            x2,
            y2,
            x3 = this._x1,
            y3 = this._y1,
            quads = [],
            node = this._root,
            q,
            i;
        if (node) quads.push(new Quad(node, x0, y0, x3, y3));
        if (radius == null) radius = Infinity;else {
          x0 = x - radius, y0 = y - radius;
          x3 = x + radius, y3 = y + radius;
          radius *= radius;
        }
        while (q = quads.pop()) {
          if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x2 = q.x1) < x0 || (y2 = q.y1) < y0) continue;
          if (node.length) {
            var xm = (x1 + x2) / 2,
                ym = (y1 + y2) / 2;
            quads.push(new Quad(node[3], xm, ym, x2, y2), new Quad(node[2], x1, ym, xm, y2), new Quad(node[1], xm, y1, x2, ym), new Quad(node[0], x1, y1, xm, ym));
            if (i = (y >= ym) << 1 | x >= xm) {
              q = quads[quads.length - 1];
              quads[quads.length - 1] = quads[quads.length - 1 - i];
              quads[quads.length - 1 - i] = q;
            }
          } else {
            var dx = x - +this._x.call(null, node.data),
                dy = y - +this._y.call(null, node.data),
                d2 = dx * dx + dy * dy;
            if (d2 < radius) {
              var d = Math.sqrt(radius = d2);
              x0 = x - d, y0 = y - d;
              x3 = x + d, y3 = y + d;
              data = node.data;
            }
          }
        }
        return data;
      };
      var tree_remove = function (d) {
        if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this;
        var parent,
            node = this._root,
            retainer,
            previous,
            next,
            x0 = this._x0,
            y0 = this._y0,
            x1 = this._x1,
            y1 = this._y1,
            x,
            y,
            xm,
            ym,
            right,
            bottom,
            i,
            j;
        if (!node) return this;
        if (node.length) while (true) {
          if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
          if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
          if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
          if (!node.length) break;
          if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
        }
        while (node.data !== d) if (!(previous = node, node = node.next)) return this;
        if (next = node.next) delete node.next;
        if (previous) return next ? previous.next = next : delete previous.next, this;
        if (!parent) return this._root = next, this;
        next ? parent[i] = next : delete parent[i];
        if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
          if (retainer) retainer[j] = node;else this._root = node;
        }
        return this;
      };
      function removeAll(data) {
        for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
        return this;
      }
      var tree_root = function () {
        return this._root;
      };
      var tree_size = function () {
        var size = 0;
        this.visit(function (node) {
          if (!node.length) do ++size; while (node = node.next);
        });
        return size;
      };
      var tree_visit = function (callback) {
        var quads = [],
            q,
            node = this._root,
            child,
            x0,
            y0,
            x1,
            y1;
        if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
        while (q = quads.pop()) {
          if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
            var xm = (x0 + x1) / 2,
                ym = (y0 + y1) / 2;
            if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
            if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
            if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
            if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          }
        }
        return this;
      };
      var tree_visitAfter = function (callback) {
        var quads = [],
            next = [],
            q;
        if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
        while (q = quads.pop()) {
          var node = q.node;
          if (node.length) {
            var child,
                x0 = q.x0,
                y0 = q.y0,
                x1 = q.x1,
                y1 = q.y1,
                xm = (x0 + x1) / 2,
                ym = (y0 + y1) / 2;
            if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
            if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
            if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
            if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          }
          next.push(q);
        }
        while (q = next.pop()) {
          callback(q.node, q.x0, q.y0, q.x1, q.y1);
        }
        return this;
      };
      function defaultX(d) {
        return d[0];
      }
      var tree_x = function (_) {
        return arguments.length ? (this._x = _, this) : this._x;
      };
      function defaultY(d) {
        return d[1];
      }
      var tree_y = function (_) {
        return arguments.length ? (this._y = _, this) : this._y;
      };
      function quadtree(nodes, x, y) {
        var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
        return nodes == null ? tree : tree.addAll(nodes);
      }
      function Quadtree(x, y, x0, y0, x1, y1) {
        this._x = x;
        this._y = y;
        this._x0 = x0;
        this._y0 = y0;
        this._x1 = x1;
        this._y1 = y1;
        this._root = undefined;
      }
      function leaf_copy(leaf) {
        var copy = { data: leaf.data },
            next = copy;
        while (leaf = leaf.next) next = next.next = { data: leaf.data };
        return copy;
      }
      var treeProto = quadtree.prototype = Quadtree.prototype;
      treeProto.copy = function () {
        var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
            node = this._root,
            nodes,
            child;
        if (!node) return copy;
        if (!node.length) return copy._root = leaf_copy(node), copy;
        nodes = [{
          source: node,
          target: copy._root = new Array(4)
        }];
        while (node = nodes.pop()) {
          for (var i = 0; i < 4; ++i) {
            if (child = node.source[i]) {
              if (child.length) nodes.push({
                source: child,
                target: node.target[i] = new Array(4)
              });else node.target[i] = leaf_copy(child);
            }
          }
        }
        return copy;
      };
      treeProto.add = tree_add;
      treeProto.addAll = addAll;
      treeProto.cover = tree_cover;
      treeProto.data = tree_data;
      treeProto.extent = tree_extent;
      treeProto.find = tree_find;
      treeProto.remove = tree_remove;
      treeProto.removeAll = removeAll;
      treeProto.root = tree_root;
      treeProto.size = tree_size;
      treeProto.visit = tree_visit;
      treeProto.visitAfter = tree_visitAfter;
      treeProto.x = tree_x;
      treeProto.y = tree_y;
      var slice$1 = [].slice;
      var noabort = {};
      function Queue(size) {
        if (!(size >= 1)) throw new Error();
        this._size = size;
        this._call = this._error = null;
        this._tasks = [];
        this._data = [];
        this._waiting = this._active = this._ended = this._start = 0;
      }
      Queue.prototype = queue.prototype = {
        constructor: Queue,
        defer: function (callback) {
          if (typeof callback !== "function" || this._call) throw new Error();
          if (this._error != null) return this;
          var t = slice$1.call(arguments, 1);
          t.push(callback);
          ++this._waiting, this._tasks.push(t);
          poke(this);
          return this;
        },
        abort: function () {
          if (this._error == null) abort(this, new Error("abort"));
          return this;
        },
        await: function (callback) {
          if (typeof callback !== "function" || this._call) throw new Error();
          this._call = function (error, results) {
            callback.apply(null, [error].concat(results));
          };
          maybeNotify(this);
          return this;
        },
        awaitAll: function (callback) {
          if (typeof callback !== "function" || this._call) throw new Error();
          this._call = callback;
          maybeNotify(this);
          return this;
        }
      };
      function poke(q) {
        if (!q._start) {
          try {
            start(q);
          } catch (e) {
            if (q._tasks[q._ended + q._active - 1]) abort(q, e);else if (!q._data) throw e;
          }
        }
      }
      function start(q) {
        while (q._start = q._waiting && q._active < q._size) {
          var i = q._ended + q._active,
              t = q._tasks[i],
              j = t.length - 1,
              c = t[j];
          t[j] = end(q, i);
          --q._waiting, ++q._active;
          t = c.apply(null, t);
          if (!q._tasks[i]) continue;
          q._tasks[i] = t || noabort;
        }
      }
      function end(q, i) {
        return function (e, r) {
          if (!q._tasks[i]) return;
          --q._active, ++q._ended;
          q._tasks[i] = null;
          if (q._error != null) return;
          if (e != null) {
            abort(q, e);
          } else {
            q._data[i] = r;
            if (q._waiting) poke(q);else maybeNotify(q);
          }
        };
      }
      function abort(q, e) {
        var i = q._tasks.length,
            t;
        q._error = e;
        q._data = undefined;
        q._waiting = NaN;
        while (--i >= 0) {
          if (t = q._tasks[i]) {
            q._tasks[i] = null;
            if (t.abort) {
              try {
                t.abort();
              } catch (e) {}
            }
          }
        }
        q._active = NaN;
        maybeNotify(q);
      }
      function maybeNotify(q) {
        if (!q._active && q._call) {
          var d = q._data;
          q._data = undefined;
          q._call(q._error, d);
        }
      }
      function queue(concurrency) {
        return new Queue(arguments.length ? +concurrency : Infinity);
      }
      var constant$2 = function (x) {
        return function constant() {
          return x;
        };
      };
      var epsilon$1 = 1e-12;
      var pi$2 = Math.PI;
      var halfPi$1 = pi$2 / 2;
      var tau$2 = 2 * pi$2;
      function arcInnerRadius(d) {
        return d.innerRadius;
      }
      function arcOuterRadius(d) {
        return d.outerRadius;
      }
      function arcStartAngle(d) {
        return d.startAngle;
      }
      function arcEndAngle(d) {
        return d.endAngle;
      }
      function arcPadAngle(d) {
        return d && d.padAngle;
      }
      function asin(x) {
        return x >= 1 ? halfPi$1 : x <= -1 ? -halfPi$1 : Math.asin(x);
      }
      function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
        var x10 = x1 - x0,
            y10 = y1 - y0,
            x32 = x3 - x2,
            y32 = y3 - y2,
            t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
        return [x0 + t * x10, y0 + t * y10];
      }
      function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
        var x01 = x0 - x1,
            y01 = y0 - y1,
            lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
            ox = lo * y01,
            oy = -lo * x01,
            x11 = x0 + ox,
            y11 = y0 + oy,
            x10 = x1 + ox,
            y10 = y1 + oy,
            x00 = (x11 + x10) / 2,
            y00 = (y11 + y10) / 2,
            dx = x10 - x11,
            dy = y10 - y11,
            d2 = dx * dx + dy * dy,
            r = r1 - rc,
            D = x11 * y10 - x10 * y11,
            d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),
            cx0 = (D * dy - dx * d) / d2,
            cy0 = (-D * dx - dy * d) / d2,
            cx1 = (D * dy + dx * d) / d2,
            cy1 = (-D * dx + dy * d) / d2,
            dx0 = cx0 - x00,
            dy0 = cy0 - y00,
            dx1 = cx1 - x00,
            dy1 = cy1 - y00;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
        return {
          cx: cx0,
          cy: cy0,
          x01: -ox,
          y01: -oy,
          x11: cx0 * (r1 / r - 1),
          y11: cy0 * (r1 / r - 1)
        };
      }
      var arc = function () {
        var innerRadius = arcInnerRadius,
            outerRadius = arcOuterRadius,
            cornerRadius = constant$2(0),
            padRadius = null,
            startAngle = arcStartAngle,
            endAngle = arcEndAngle,
            padAngle = arcPadAngle,
            context = null;
        function arc() {
          var buffer,
              r,
              r0 = +innerRadius.apply(this, arguments),
              r1 = +outerRadius.apply(this, arguments),
              a0 = startAngle.apply(this, arguments) - halfPi$1,
              a1 = endAngle.apply(this, arguments) - halfPi$1,
              da = Math.abs(a1 - a0),
              cw = a1 > a0;
          if (!context) context = buffer = path();
          if (r1 < r0) r = r1, r1 = r0, r0 = r;
          if (!(r1 > epsilon$1)) context.moveTo(0, 0);else if (da > tau$2 - epsilon$1) {
            context.moveTo(r1 * Math.cos(a0), r1 * Math.sin(a0));
            context.arc(0, 0, r1, a0, a1, !cw);
            if (r0 > epsilon$1) {
              context.moveTo(r0 * Math.cos(a1), r0 * Math.sin(a1));
              context.arc(0, 0, r0, a1, a0, cw);
            }
          } else {
            var a01 = a0,
                a11 = a1,
                a00 = a0,
                a10 = a1,
                da0 = da,
                da1 = da,
                ap = padAngle.apply(this, arguments) / 2,
                rp = ap > epsilon$1 && (padRadius ? +padRadius.apply(this, arguments) : Math.sqrt(r0 * r0 + r1 * r1)),
                rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
                rc0 = rc,
                rc1 = rc,
                t0,
                t1;
            if (rp > epsilon$1) {
              var p0 = asin(rp / r0 * Math.sin(ap)),
                  p1 = asin(rp / r1 * Math.sin(ap));
              if ((da0 -= p0 * 2) > epsilon$1) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;else da0 = 0, a00 = a10 = (a0 + a1) / 2;
              if ((da1 -= p1 * 2) > epsilon$1) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;else da1 = 0, a01 = a11 = (a0 + a1) / 2;
            }
            var x01 = r1 * Math.cos(a01),
                y01 = r1 * Math.sin(a01),
                x10 = r0 * Math.cos(a10),
                y10 = r0 * Math.sin(a10);
            if (rc > epsilon$1) {
              var x11 = r1 * Math.cos(a11),
                  y11 = r1 * Math.sin(a11),
                  x00 = r0 * Math.cos(a00),
                  y00 = r0 * Math.sin(a00);
              if (da < pi$2) {
                var oc = da0 > epsilon$1 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
                    ax = x01 - oc[0],
                    ay = y01 - oc[1],
                    bx = x11 - oc[0],
                    by = y11 - oc[1],
                    kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
                    lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
              }
            }
            if (!(da1 > epsilon$1)) context.moveTo(x01, y01);else if (rc1 > epsilon$1) {
              t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
              t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
              context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
              if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);else {
                context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
                context.arc(0, 0, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                context.arc(t1.cx, t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
              }
            } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
            if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);else if (rc0 > epsilon$1) {
              t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
              t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
              context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
              if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);else {
                context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
                context.arc(0, 0, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                context.arc(t1.cx, t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
              }
            } else context.arc(0, 0, r0, a10, a00, cw);
          }
          context.closePath();
          if (buffer) return context = null, buffer + "" || null;
        }
        arc.centroid = function () {
          var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
              a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$2 / 2;
          return [Math.cos(a) * r, Math.sin(a) * r];
        };
        arc.innerRadius = function (_) {
          return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$2(+_), arc) : innerRadius;
        };
        arc.outerRadius = function (_) {
          return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$2(+_), arc) : outerRadius;
        };
        arc.cornerRadius = function (_) {
          return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$2(+_), arc) : cornerRadius;
        };
        arc.padRadius = function (_) {
          return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), arc) : padRadius;
        };
        arc.startAngle = function (_) {
          return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), arc) : startAngle;
        };
        arc.endAngle = function (_) {
          return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), arc) : endAngle;
        };
        arc.padAngle = function (_) {
          return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$2(+_), arc) : padAngle;
        };
        arc.context = function (_) {
          return arguments.length ? (context = _ == null ? null : _, arc) : context;
        };
        return arc;
      };
      function Linear(context) {
        this._context = context;
      }
      Linear.prototype = {
        areaStart: function () {
          this._line = 0;
        },
        areaEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._point = 0;
        },
        lineEnd: function () {
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
          this._line = 1 - this._line;
        },
        point: function (x, y) {
          x = +x, y = +y;
          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break;
            case 1:
              this._point = 2;
            default:
              this._context.lineTo(x, y);
              break;
          }
        }
      };
      var curveLinear = function (context) {
        return new Linear(context);
      };
      function x(p) {
        return p[0];
      }
      function y(p) {
        return p[1];
      }
      var line = function () {
        var x$$1 = x,
            y$$1 = y,
            defined = constant$2(true),
            context = null,
            curve = curveLinear,
            output = null;
        function line(data) {
          var i,
              n = data.length,
              d,
              defined0 = false,
              buffer;
          if (context == null) output = curve(buffer = path());
          for (i = 0; i <= n; ++i) {
            if (!(i < n && defined(d = data[i], i, data)) === defined0) {
              if (defined0 = !defined0) output.lineStart();else output.lineEnd();
            }
            if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
          }
          if (buffer) return output = null, buffer + "" || null;
        }
        line.x = function (_) {
          return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$2(+_), line) : x$$1;
        };
        line.y = function (_) {
          return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$2(+_), line) : y$$1;
        };
        line.defined = function (_) {
          return arguments.length ? (defined = typeof _ === "function" ? _ : constant$2(!!_), line) : defined;
        };
        line.curve = function (_) {
          return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
        };
        line.context = function (_) {
          return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
        };
        return line;
      };
      var area$1 = function () {
        var x0 = x,
            x1 = null,
            y0 = constant$2(0),
            y1 = y,
            defined = constant$2(true),
            context = null,
            curve = curveLinear,
            output = null;
        function area(data) {
          var i,
              j,
              k,
              n = data.length,
              d,
              defined0 = false,
              buffer,
              x0z = new Array(n),
              y0z = new Array(n);
          if (context == null) output = curve(buffer = path());
          for (i = 0; i <= n; ++i) {
            if (!(i < n && defined(d = data[i], i, data)) === defined0) {
              if (defined0 = !defined0) {
                j = i;
                output.areaStart();
                output.lineStart();
              } else {
                output.lineEnd();
                output.lineStart();
                for (k = i - 1; k >= j; --k) {
                  output.point(x0z[k], y0z[k]);
                }
                output.lineEnd();
                output.areaEnd();
              }
            }
            if (defined0) {
              x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
              output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
            }
          }
          if (buffer) return output = null, buffer + "" || null;
        }
        function arealine() {
          return line().defined(defined).curve(curve).context(context);
        }
        area.x = function (_) {
          return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), x1 = null, area) : x0;
        };
        area.x0 = function (_) {
          return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), area) : x0;
        };
        area.x1 = function (_) {
          return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area) : x1;
        };
        area.y = function (_) {
          return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), y1 = null, area) : y0;
        };
        area.y0 = function (_) {
          return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), area) : y0;
        };
        area.y1 = function (_) {
          return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area) : y1;
        };
        area.lineX0 = area.lineY0 = function () {
          return arealine().x(x0).y(y0);
        };
        area.lineY1 = function () {
          return arealine().x(x0).y(y1);
        };
        area.lineX1 = function () {
          return arealine().x(x1).y(y0);
        };
        area.defined = function (_) {
          return arguments.length ? (defined = typeof _ === "function" ? _ : constant$2(!!_), area) : defined;
        };
        area.curve = function (_) {
          return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
        };
        area.context = function (_) {
          return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
        };
        return area;
      };
      var descending$1 = function (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
      };
      var identity$1 = function (d) {
        return d;
      };
      var pie = function () {
        var value = identity$1,
            sortValues = descending$1,
            sort = null,
            startAngle = constant$2(0),
            endAngle = constant$2(tau$2),
            padAngle = constant$2(0);
        function pie(data) {
          var i,
              n = data.length,
              j,
              k,
              sum = 0,
              index = new Array(n),
              arcs = new Array(n),
              a0 = +startAngle.apply(this, arguments),
              da = Math.min(tau$2, Math.max(-tau$2, endAngle.apply(this, arguments) - a0)),
              a1,
              p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
              pa = p * (da < 0 ? -1 : 1),
              v;
          for (i = 0; i < n; ++i) {
            if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
              sum += v;
            }
          }
          if (sortValues != null) index.sort(function (i, j) {
            return sortValues(arcs[i], arcs[j]);
          });else if (sort != null) index.sort(function (i, j) {
            return sort(data[i], data[j]);
          });
          for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
            j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
              data: data[j],
              index: i,
              value: v,
              startAngle: a0,
              endAngle: a1,
              padAngle: p
            };
          }
          return arcs;
        }
        pie.value = function (_) {
          return arguments.length ? (value = typeof _ === "function" ? _ : constant$2(+_), pie) : value;
        };
        pie.sortValues = function (_) {
          return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
        };
        pie.sort = function (_) {
          return arguments.length ? (sort = _, sortValues = null, pie) : sort;
        };
        pie.startAngle = function (_) {
          return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), pie) : startAngle;
        };
        pie.endAngle = function (_) {
          return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), pie) : endAngle;
        };
        pie.padAngle = function (_) {
          return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$2(+_), pie) : padAngle;
        };
        return pie;
      };
      var curveRadialLinear = curveRadial(curveLinear);
      function Radial(curve) {
        this._curve = curve;
      }
      Radial.prototype = {
        areaStart: function () {
          this._curve.areaStart();
        },
        areaEnd: function () {
          this._curve.areaEnd();
        },
        lineStart: function () {
          this._curve.lineStart();
        },
        lineEnd: function () {
          this._curve.lineEnd();
        },
        point: function (a, r) {
          this._curve.point(r * Math.sin(a), r * -Math.cos(a));
        }
      };
      function curveRadial(curve) {
        function radial(context) {
          return new Radial(curve(context));
        }
        radial._curve = curve;
        return radial;
      }
      function radialLine(l) {
        var c = l.curve;
        l.angle = l.x, delete l.x;
        l.radius = l.y, delete l.y;
        l.curve = function (_) {
          return arguments.length ? c(curveRadial(_)) : c()._curve;
        };
        return l;
      }
      var radialLine$1 = function () {
        return radialLine(line().curve(curveRadialLinear));
      };
      var radialArea = function () {
        var a = area$1().curve(curveRadialLinear),
            c = a.curve,
            x0 = a.lineX0,
            x1 = a.lineX1,
            y0 = a.lineY0,
            y1 = a.lineY1;
        a.angle = a.x, delete a.x;
        a.startAngle = a.x0, delete a.x0;
        a.endAngle = a.x1, delete a.x1;
        a.radius = a.y, delete a.y;
        a.innerRadius = a.y0, delete a.y0;
        a.outerRadius = a.y1, delete a.y1;
        a.lineStartAngle = function () {
          return radialLine(x0());
        }, delete a.lineX0;
        a.lineEndAngle = function () {
          return radialLine(x1());
        }, delete a.lineX1;
        a.lineInnerRadius = function () {
          return radialLine(y0());
        }, delete a.lineY0;
        a.lineOuterRadius = function () {
          return radialLine(y1());
        }, delete a.lineY1;
        a.curve = function (_) {
          return arguments.length ? c(curveRadial(_)) : c()._curve;
        };
        return a;
      };
      var circle = { draw: function (context, size) {
          var r = Math.sqrt(size / pi$2);
          context.moveTo(r, 0);
          context.arc(0, 0, r, 0, tau$2);
        } };
      var cross$1 = { draw: function (context, size) {
          var r = Math.sqrt(size / 5) / 2;
          context.moveTo(-3 * r, -r);
          context.lineTo(-r, -r);
          context.lineTo(-r, -3 * r);
          context.lineTo(r, -3 * r);
          context.lineTo(r, -r);
          context.lineTo(3 * r, -r);
          context.lineTo(3 * r, r);
          context.lineTo(r, r);
          context.lineTo(r, 3 * r);
          context.lineTo(-r, 3 * r);
          context.lineTo(-r, r);
          context.lineTo(-3 * r, r);
          context.closePath();
        } };
      var tan30 = Math.sqrt(1 / 3);
      var tan30_2 = tan30 * 2;
      var diamond = { draw: function (context, size) {
          var y = Math.sqrt(size / tan30_2),
              x = y * tan30;
          context.moveTo(0, -y);
          context.lineTo(x, 0);
          context.lineTo(0, y);
          context.lineTo(-x, 0);
          context.closePath();
        } };
      var ka = 0.89081309152928522810;
      var kr = Math.sin(pi$2 / 10) / Math.sin(7 * pi$2 / 10);
      var kx = Math.sin(tau$2 / 10) * kr;
      var ky = -Math.cos(tau$2 / 10) * kr;
      var star = { draw: function (context, size) {
          var r = Math.sqrt(size * ka),
              x = kx * r,
              y = ky * r;
          context.moveTo(0, -r);
          context.lineTo(x, y);
          for (var i = 1; i < 5; ++i) {
            var a = tau$2 * i / 5,
                c = Math.cos(a),
                s = Math.sin(a);
            context.lineTo(s * r, -c * r);
            context.lineTo(c * x - s * y, s * x + c * y);
          }
          context.closePath();
        } };
      var square = { draw: function (context, size) {
          var w = Math.sqrt(size),
              x = -w / 2;
          context.rect(x, x, w, w);
        } };
      var sqrt3 = Math.sqrt(3);
      var triangle = { draw: function (context, size) {
          var y = -Math.sqrt(size / (sqrt3 * 3));
          context.moveTo(0, y * 2);
          context.lineTo(-sqrt3 * y, -y);
          context.lineTo(sqrt3 * y, -y);
          context.closePath();
        } };
      var c = -0.5;
      var s = Math.sqrt(3) / 2;
      var k = 1 / Math.sqrt(12);
      var a = (k / 2 + 1) * 3;
      var wye = { draw: function (context, size) {
          var r = Math.sqrt(size / a),
              x0 = r / 2,
              y0 = r * k,
              x1 = x0,
              y1 = r * k + r,
              x2 = -x1,
              y2 = y1;
          context.moveTo(x0, y0);
          context.lineTo(x1, y1);
          context.lineTo(x2, y2);
          context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
          context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
          context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
          context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
          context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
          context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
          context.closePath();
        } };
      var symbols = [circle, cross$1, diamond, square, star, triangle, wye];
      var symbol = function () {
        var type = constant$2(circle),
            size = constant$2(64),
            context = null;
        function symbol() {
          var buffer;
          if (!context) context = buffer = path();
          type.apply(this, arguments).draw(context, +size.apply(this, arguments));
          if (buffer) return context = null, buffer + "" || null;
        }
        symbol.type = function (_) {
          return arguments.length ? (type = typeof _ === "function" ? _ : constant$2(_), symbol) : type;
        };
        symbol.size = function (_) {
          return arguments.length ? (size = typeof _ === "function" ? _ : constant$2(+_), symbol) : size;
        };
        symbol.context = function (_) {
          return arguments.length ? (context = _ == null ? null : _, symbol) : context;
        };
        return symbol;
      };
      var noop = function () {};
      function point(that, x, y) {
        that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
      }
      function Basis(context) {
        this._context = context;
      }
      Basis.prototype = {
        areaStart: function () {
          this._line = 0;
        },
        areaEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._x0 = this._x1 = this._y0 = this._y1 = NaN;
          this._point = 0;
        },
        lineEnd: function () {
          switch (this._point) {
            case 3:
              point(this, this._x1, this._y1);
            case 2:
              this._context.lineTo(this._x1, this._y1);
              break;
          }
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
          this._line = 1 - this._line;
        },
        point: function (x, y) {
          x = +x, y = +y;
          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3;
              this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
            default:
              point(this, x, y);
              break;
          }
          this._x0 = this._x1, this._x1 = x;
          this._y0 = this._y1, this._y1 = y;
        }
      };
      var basis = function (context) {
        return new Basis(context);
      };
      function BasisClosed(context) {
        this._context = context;
      }
      BasisClosed.prototype = {
        areaStart: noop,
        areaEnd: noop,
        lineStart: function () {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
          this._point = 0;
        },
        lineEnd: function () {
          switch (this._point) {
            case 1:
              {
                this._context.moveTo(this._x2, this._y2);
                this._context.closePath();
                break;
              }
            case 2:
              {
                this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
                this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
                this._context.closePath();
                break;
              }
            case 3:
              {
                this.point(this._x2, this._y2);
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                break;
              }
          }
        },
        point: function (x, y) {
          x = +x, y = +y;
          switch (this._point) {
            case 0:
              this._point = 1;
              this._x2 = x, this._y2 = y;
              break;
            case 1:
              this._point = 2;
              this._x3 = x, this._y3 = y;
              break;
            case 2:
              this._point = 3;
              this._x4 = x, this._y4 = y;
              this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);
              break;
            default:
              point(this, x, y);
              break;
          }
          this._x0 = this._x1, this._x1 = x;
          this._y0 = this._y1, this._y1 = y;
        }
      };
      var basisClosed = function (context) {
        return new BasisClosed(context);
      };
      function BasisOpen(context) {
        this._context = context;
      }
      BasisOpen.prototype = {
        areaStart: function () {
          this._line = 0;
        },
        areaEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._x0 = this._x1 = this._y0 = this._y1 = NaN;
          this._point = 0;
        },
        lineEnd: function () {
          if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
          this._line = 1 - this._line;
        },
        point: function (x, y) {
          x = +x, y = +y;
          switch (this._point) {
            case 0:
              this._point = 1;
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3;
              var x0 = (this._x0 + 4 * this._x1 + x) / 6,
                  y0 = (this._y0 + 4 * this._y1 + y) / 6;
              this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
              break;
            case 3:
              this._point = 4;
            default:
              point(this, x, y);
              break;
          }
          this._x0 = this._x1, this._x1 = x;
          this._y0 = this._y1, this._y1 = y;
        }
      };
      var basisOpen = function (context) {
        return new BasisOpen(context);
      };
      function Bundle(context, beta) {
        this._basis = new Basis(context);
        this._beta = beta;
      }
      Bundle.prototype = {
        lineStart: function () {
          this._x = [];
          this._y = [];
          this._basis.lineStart();
        },
        lineEnd: function () {
          var x = this._x,
              y = this._y,
              j = x.length - 1;
          if (j > 0) {
            var x0 = x[0],
                y0 = y[0],
                dx = x[j] - x0,
                dy = y[j] - y0,
                i = -1,
                t;
            while (++i <= j) {
              t = i / j;
              this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
            }
          }
          this._x = this._y = null;
          this._basis.lineEnd();
        },
        point: function (x, y) {
          this._x.push(+x);
          this._y.push(+y);
        }
      };
      var bundle = function custom(beta) {
        function bundle(context) {
          return beta === 1 ? new Basis(context) : new Bundle(context, beta);
        }
        bundle.beta = function (beta) {
          return custom(+beta);
        };
        return bundle;
      }(0.85);
      function point$1(that, x, y) {
        that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
      }
      function Cardinal(context, tension) {
        this._context = context;
        this._k = (1 - tension) / 6;
      }
      Cardinal.prototype = {
        areaStart: function () {
          this._line = 0;
        },
        areaEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
          this._point = 0;
        },
        lineEnd: function () {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2);
              break;
            case 3:
              point$1(this, this._x1, this._y1);
              break;
          }
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
          this._line = 1 - this._line;
        },
        point: function (x, y) {
          x = +x, y = +y;
          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break;
            case 1:
              this._point = 2;
              this._x1 = x, this._y1 = y;
              break;
            case 2:
              this._point = 3;
            default:
              point$1(this, x, y);
              break;
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
      };
      var cardinal = function custom(tension) {
        function cardinal(context) {
          return new Cardinal(context, tension);
        }
        cardinal.tension = function (tension) {
          return custom(+tension);
        };
        return cardinal;
      }(0);
      function CardinalClosed(context, tension) {
        this._context = context;
        this._k = (1 - tension) / 6;
      }
      CardinalClosed.prototype = {
        areaStart: noop,
        areaEnd: noop,
        lineStart: function () {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
          this._point = 0;
        },
        lineEnd: function () {
          switch (this._point) {
            case 1:
              {
                this._context.moveTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
            case 2:
              {
                this._context.lineTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
            case 3:
              {
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                this.point(this._x5, this._y5);
                break;
              }
          }
        },
        point: function (x, y) {
          x = +x, y = +y;
          switch (this._point) {
            case 0:
              this._point = 1;
              this._x3 = x, this._y3 = y;
              break;
            case 1:
              this._point = 2;
              this._context.moveTo(this._x4 = x, this._y4 = y);
              break;
            case 2:
              this._point = 3;
              this._x5 = x, this._y5 = y;
              break;
            default:
              point$1(this, x, y);
              break;
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
      };
      var cardinalClosed = function custom(tension) {
        function cardinal(context) {
          return new CardinalClosed(context, tension);
        }
        cardinal.tension = function (tension) {
          return custom(+tension);
        };
        return cardinal;
      }(0);
      function CardinalOpen(context, tension) {
        this._context = context;
        this._k = (1 - tension) / 6;
      }
      CardinalOpen.prototype = {
        areaStart: function () {
          this._line = 0;
        },
        areaEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
          this._point = 0;
        },
        lineEnd: function () {
          if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
          this._line = 1 - this._line;
        },
        point: function (x, y) {
          x = +x, y = +y;
          switch (this._point) {
            case 0:
              this._point = 1;
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3;
              this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
              break;
            case 3:
              this._point = 4;
            default:
              point$1(this, x, y);
              break;
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
      };
      var cardinalOpen = function custom(tension) {
        function cardinal(context) {
          return new CardinalOpen(context, tension);
        }
        cardinal.tension = function (tension) {
          return custom(+tension);
        };
        return cardinal;
      }(0);
      function point$2(that, x, y) {
        var x1 = that._x1,
            y1 = that._y1,
            x2 = that._x2,
            y2 = that._y2;
        if (that._l01_a > epsilon$1) {
          var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
              n = 3 * that._l01_a * (that._l01_a + that._l12_a);
          x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
          y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
        }
        if (that._l23_a > epsilon$1) {
          var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
              m = 3 * that._l23_a * (that._l23_a + that._l12_a);
          x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
          y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
        }
        that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
      }
      function CatmullRom(context, alpha) {
        this._context = context;
        this._alpha = alpha;
      }
      CatmullRom.prototype = {
        areaStart: function () {
          this._line = 0;
        },
        areaEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
          this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
        },
        lineEnd: function () {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2);
              break;
            case 3:
              this.point(this._x2, this._y2);
              break;
          }
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
          this._line = 1 - this._line;
        },
        point: function (x, y) {
          x = +x, y = +y;
          if (this._point) {
            var x23 = this._x2 - x,
                y23 = this._y2 - y;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
          }
          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3;
            default:
              point$2(this, x, y);
              break;
          }
          this._l01_a = this._l12_a, this._l12_a = this._l23_a;
          this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
      };
      var catmullRom = function custom(alpha) {
        function catmullRom(context) {
          return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
        }
        catmullRom.alpha = function (alpha) {
          return custom(+alpha);
        };
        return catmullRom;
      }(0.5);
      function CatmullRomClosed(context, alpha) {
        this._context = context;
        this._alpha = alpha;
      }
      CatmullRomClosed.prototype = {
        areaStart: noop,
        areaEnd: noop,
        lineStart: function () {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
          this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
        },
        lineEnd: function () {
          switch (this._point) {
            case 1:
              {
                this._context.moveTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
            case 2:
              {
                this._context.lineTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
            case 3:
              {
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                this.point(this._x5, this._y5);
                break;
              }
          }
        },
        point: function (x, y) {
          x = +x, y = +y;
          if (this._point) {
            var x23 = this._x2 - x,
                y23 = this._y2 - y;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
          }
          switch (this._point) {
            case 0:
              this._point = 1;
              this._x3 = x, this._y3 = y;
              break;
            case 1:
              this._point = 2;
              this._context.moveTo(this._x4 = x, this._y4 = y);
              break;
            case 2:
              this._point = 3;
              this._x5 = x, this._y5 = y;
              break;
            default:
              point$2(this, x, y);
              break;
          }
          this._l01_a = this._l12_a, this._l12_a = this._l23_a;
          this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
      };
      var catmullRomClosed = function custom(alpha) {
        function catmullRom(context) {
          return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
        }
        catmullRom.alpha = function (alpha) {
          return custom(+alpha);
        };
        return catmullRom;
      }(0.5);
      function CatmullRomOpen(context, alpha) {
        this._context = context;
        this._alpha = alpha;
      }
      CatmullRomOpen.prototype = {
        areaStart: function () {
          this._line = 0;
        },
        areaEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
          this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
        },
        lineEnd: function () {
          if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
          this._line = 1 - this._line;
        },
        point: function (x, y) {
          x = +x, y = +y;
          if (this._point) {
            var x23 = this._x2 - x,
                y23 = this._y2 - y;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
          }
          switch (this._point) {
            case 0:
              this._point = 1;
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3;
              this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
              break;
            case 3:
              this._point = 4;
            default:
              point$2(this, x, y);
              break;
          }
          this._l01_a = this._l12_a, this._l12_a = this._l23_a;
          this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
      };
      var catmullRomOpen = function custom(alpha) {
        function catmullRom(context) {
          return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
        }
        catmullRom.alpha = function (alpha) {
          return custom(+alpha);
        };
        return catmullRom;
      }(0.5);
      function LinearClosed(context) {
        this._context = context;
      }
      LinearClosed.prototype = {
        areaStart: noop,
        areaEnd: noop,
        lineStart: function () {
          this._point = 0;
        },
        lineEnd: function () {
          if (this._point) this._context.closePath();
        },
        point: function (x, y) {
          x = +x, y = +y;
          if (this._point) this._context.lineTo(x, y);else this._point = 1, this._context.moveTo(x, y);
        }
      };
      var linearClosed = function (context) {
        return new LinearClosed(context);
      };
      function sign(x) {
        return x < 0 ? -1 : 1;
      }
      function slope3(that, x2, y2) {
        var h0 = that._x1 - that._x0,
            h1 = x2 - that._x1,
            s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
            s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
            p = (s0 * h1 + s1 * h0) / (h0 + h1);
        return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
      }
      function slope2(that, t) {
        var h = that._x1 - that._x0;
        return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
      }
      function point$3(that, t0, t1) {
        var x0 = that._x0,
            y0 = that._y0,
            x1 = that._x1,
            y1 = that._y1,
            dx = (x1 - x0) / 3;
        that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
      }
      function MonotoneX(context) {
        this._context = context;
      }
      MonotoneX.prototype = {
        areaStart: function () {
          this._line = 0;
        },
        areaEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
          this._point = 0;
        },
        lineEnd: function () {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x1, this._y1);
              break;
            case 3:
              point$3(this, this._t0, slope2(this, this._t0));
              break;
          }
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
          this._line = 1 - this._line;
        },
        point: function (x, y) {
          var t1 = NaN;
          x = +x, y = +y;
          if (x === this._x1 && y === this._y1) return;
          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3;
              point$3(this, slope2(this, t1 = slope3(this, x, y)), t1);
              break;
            default:
              point$3(this, this._t0, t1 = slope3(this, x, y));
              break;
          }
          this._x0 = this._x1, this._x1 = x;
          this._y0 = this._y1, this._y1 = y;
          this._t0 = t1;
        }
      };
      function MonotoneY(context) {
        this._context = new ReflectContext(context);
      }
      (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {
        MonotoneX.prototype.point.call(this, y, x);
      };
      function ReflectContext(context) {
        this._context = context;
      }
      ReflectContext.prototype = {
        moveTo: function (x, y) {
          this._context.moveTo(y, x);
        },
        closePath: function () {
          this._context.closePath();
        },
        lineTo: function (x, y) {
          this._context.lineTo(y, x);
        },
        bezierCurveTo: function (x1, y1, x2, y2, x, y) {
          this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
        }
      };
      function monotoneX(context) {
        return new MonotoneX(context);
      }
      function monotoneY(context) {
        return new MonotoneY(context);
      }
      function Natural(context) {
        this._context = context;
      }
      Natural.prototype = {
        areaStart: function () {
          this._line = 0;
        },
        areaEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._x = [];
          this._y = [];
        },
        lineEnd: function () {
          var x = this._x,
              y = this._y,
              n = x.length;
          if (n) {
            this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
            if (n === 2) {
              this._context.lineTo(x[1], y[1]);
            } else {
              var px = controlPoints(x),
                  py = controlPoints(y);
              for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
                this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
              }
            }
          }
          if (this._line || this._line !== 0 && n === 1) this._context.closePath();
          this._line = 1 - this._line;
          this._x = this._y = null;
        },
        point: function (x, y) {
          this._x.push(+x);
          this._y.push(+y);
        }
      };
      function controlPoints(x) {
        var i,
            n = x.length - 1,
            m,
            a = new Array(n),
            b = new Array(n),
            r = new Array(n);
        a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
        for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
        a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
        for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
        a[n - 1] = r[n - 1] / b[n - 1];
        for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
        b[n - 1] = (x[n] + a[n - 1]) / 2;
        for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
        return [a, b];
      }
      var natural = function (context) {
        return new Natural(context);
      };
      function Step(context, t) {
        this._context = context;
        this._t = t;
      }
      Step.prototype = {
        areaStart: function () {
          this._line = 0;
        },
        areaEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._x = this._y = NaN;
          this._point = 0;
        },
        lineEnd: function () {
          if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
          if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
        },
        point: function (x, y) {
          x = +x, y = +y;
          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break;
            case 1:
              this._point = 2;
            default:
              {
                if (this._t <= 0) {
                  this._context.lineTo(this._x, y);
                  this._context.lineTo(x, y);
                } else {
                  var x1 = this._x * (1 - this._t) + x * this._t;
                  this._context.lineTo(x1, this._y);
                  this._context.lineTo(x1, y);
                }
                break;
              }
          }
          this._x = x, this._y = y;
        }
      };
      var step = function (context) {
        return new Step(context, 0.5);
      };
      function stepBefore(context) {
        return new Step(context, 0);
      }
      function stepAfter(context) {
        return new Step(context, 1);
      }
      var slice$2 = Array.prototype.slice;
      var none = function (series, order) {
        if (!((n = series.length) > 1)) return;
        for (var i = 1, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
          s0 = s1, s1 = series[order[i]];
          for (var j = 0; j < m; ++j) {
            s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
          }
        }
      };
      var none$1 = function (series) {
        var n = series.length,
            o = new Array(n);
        while (--n >= 0) o[n] = n;
        return o;
      };
      function stackValue(d, key) {
        return d[key];
      }
      var stack = function () {
        var keys = constant$2([]),
            order = none$1,
            offset = none,
            value = stackValue;
        function stack(data) {
          var kz = keys.apply(this, arguments),
              i,
              m = data.length,
              n = kz.length,
              sz = new Array(n),
              oz;
          for (i = 0; i < n; ++i) {
            for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
              si[j] = sij = [0, +value(data[j], ki, j, data)];
              sij.data = data[j];
            }
            si.key = ki;
          }
          for (i = 0, oz = order(sz); i < n; ++i) {
            sz[oz[i]].index = i;
          }
          offset(sz, oz);
          return sz;
        }
        stack.keys = function (_) {
          return arguments.length ? (keys = typeof _ === "function" ? _ : constant$2(slice$2.call(_)), stack) : keys;
        };
        stack.value = function (_) {
          return arguments.length ? (value = typeof _ === "function" ? _ : constant$2(+_), stack) : value;
        };
        stack.order = function (_) {
          return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant$2(slice$2.call(_)), stack) : order;
        };
        stack.offset = function (_) {
          return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
        };
        return stack;
      };
      var expand = function (series, order) {
        if (!((n = series.length) > 0)) return;
        for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
          for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
          if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
        }
        none(series, order);
      };
      var silhouette = function (series, order) {
        if (!((n = series.length) > 0)) return;
        for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
          for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
          s0[j][1] += s0[j][0] = -y / 2;
        }
        none(series, order);
      };
      var wiggle = function (series, order) {
        if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
        for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
          for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
            var si = series[order[i]],
                sij0 = si[j][1] || 0,
                sij1 = si[j - 1][1] || 0,
                s3 = (sij0 - sij1) / 2;
            for (var k = 0; k < i; ++k) {
              var sk = series[order[k]],
                  skj0 = sk[j][1] || 0,
                  skj1 = sk[j - 1][1] || 0;
              s3 += skj0 - skj1;
            }
            s1 += sij0, s2 += s3 * sij0;
          }
          s0[j - 1][1] += s0[j - 1][0] = y;
          if (s1) y -= s2 / s1;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        none(series, order);
      };
      var ascending$1 = function (series) {
        var sums = series.map(sum$1);
        return none$1(series).sort(function (a, b) {
          return sums[a] - sums[b];
        });
      };
      function sum$1(series) {
        var s = 0,
            i = -1,
            n = series.length,
            v;
        while (++i < n) if (v = +series[i][1]) s += v;
        return s;
      }
      var descending$2 = function (series) {
        return ascending$1(series).reverse();
      };
      var insideOut = function (series) {
        var n = series.length,
            i,
            j,
            sums = series.map(sum$1),
            order = none$1(series).sort(function (a, b) {
          return sums[b] - sums[a];
        }),
            top = 0,
            bottom = 0,
            tops = [],
            bottoms = [];
        for (i = 0; i < n; ++i) {
          j = order[i];
          if (top < bottom) {
            top += sums[j];
            tops.push(j);
          } else {
            bottom += sums[j];
            bottoms.push(j);
          }
        }
        return bottoms.reverse().concat(tops);
      };
      var reverse = function (series) {
        return none$1(series).reverse();
      };
      var define = function (constructor, factory, prototype) {
        constructor.prototype = factory.prototype = prototype;
        prototype.constructor = constructor;
      };
      function extend(parent, definition) {
        var prototype = Object.create(parent.prototype);
        for (var key in definition) prototype[key] = definition[key];
        return prototype;
      }
      function Color() {}
      var darker = 0.7;
      var brighter = 1 / darker;
      var reI = "\\s*([+-]?\\d+)\\s*";
      var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
      var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
      var reHex3 = /^#([0-9a-f]{3})$/;
      var reHex6 = /^#([0-9a-f]{6})$/;
      var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
      var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
      var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
      var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
      var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
      var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
      var named = {
        aliceblue: 0xf0f8ff,
        antiquewhite: 0xfaebd7,
        aqua: 0x00ffff,
        aquamarine: 0x7fffd4,
        azure: 0xf0ffff,
        beige: 0xf5f5dc,
        bisque: 0xffe4c4,
        black: 0x000000,
        blanchedalmond: 0xffebcd,
        blue: 0x0000ff,
        blueviolet: 0x8a2be2,
        brown: 0xa52a2a,
        burlywood: 0xdeb887,
        cadetblue: 0x5f9ea0,
        chartreuse: 0x7fff00,
        chocolate: 0xd2691e,
        coral: 0xff7f50,
        cornflowerblue: 0x6495ed,
        cornsilk: 0xfff8dc,
        crimson: 0xdc143c,
        cyan: 0x00ffff,
        darkblue: 0x00008b,
        darkcyan: 0x008b8b,
        darkgoldenrod: 0xb8860b,
        darkgray: 0xa9a9a9,
        darkgreen: 0x006400,
        darkgrey: 0xa9a9a9,
        darkkhaki: 0xbdb76b,
        darkmagenta: 0x8b008b,
        darkolivegreen: 0x556b2f,
        darkorange: 0xff8c00,
        darkorchid: 0x9932cc,
        darkred: 0x8b0000,
        darksalmon: 0xe9967a,
        darkseagreen: 0x8fbc8f,
        darkslateblue: 0x483d8b,
        darkslategray: 0x2f4f4f,
        darkslategrey: 0x2f4f4f,
        darkturquoise: 0x00ced1,
        darkviolet: 0x9400d3,
        deeppink: 0xff1493,
        deepskyblue: 0x00bfff,
        dimgray: 0x696969,
        dimgrey: 0x696969,
        dodgerblue: 0x1e90ff,
        firebrick: 0xb22222,
        floralwhite: 0xfffaf0,
        forestgreen: 0x228b22,
        fuchsia: 0xff00ff,
        gainsboro: 0xdcdcdc,
        ghostwhite: 0xf8f8ff,
        gold: 0xffd700,
        goldenrod: 0xdaa520,
        gray: 0x808080,
        green: 0x008000,
        greenyellow: 0xadff2f,
        grey: 0x808080,
        honeydew: 0xf0fff0,
        hotpink: 0xff69b4,
        indianred: 0xcd5c5c,
        indigo: 0x4b0082,
        ivory: 0xfffff0,
        khaki: 0xf0e68c,
        lavender: 0xe6e6fa,
        lavenderblush: 0xfff0f5,
        lawngreen: 0x7cfc00,
        lemonchiffon: 0xfffacd,
        lightblue: 0xadd8e6,
        lightcoral: 0xf08080,
        lightcyan: 0xe0ffff,
        lightgoldenrodyellow: 0xfafad2,
        lightgray: 0xd3d3d3,
        lightgreen: 0x90ee90,
        lightgrey: 0xd3d3d3,
        lightpink: 0xffb6c1,
        lightsalmon: 0xffa07a,
        lightseagreen: 0x20b2aa,
        lightskyblue: 0x87cefa,
        lightslategray: 0x778899,
        lightslategrey: 0x778899,
        lightsteelblue: 0xb0c4de,
        lightyellow: 0xffffe0,
        lime: 0x00ff00,
        limegreen: 0x32cd32,
        linen: 0xfaf0e6,
        magenta: 0xff00ff,
        maroon: 0x800000,
        mediumaquamarine: 0x66cdaa,
        mediumblue: 0x0000cd,
        mediumorchid: 0xba55d3,
        mediumpurple: 0x9370db,
        mediumseagreen: 0x3cb371,
        mediumslateblue: 0x7b68ee,
        mediumspringgreen: 0x00fa9a,
        mediumturquoise: 0x48d1cc,
        mediumvioletred: 0xc71585,
        midnightblue: 0x191970,
        mintcream: 0xf5fffa,
        mistyrose: 0xffe4e1,
        moccasin: 0xffe4b5,
        navajowhite: 0xffdead,
        navy: 0x000080,
        oldlace: 0xfdf5e6,
        olive: 0x808000,
        olivedrab: 0x6b8e23,
        orange: 0xffa500,
        orangered: 0xff4500,
        orchid: 0xda70d6,
        palegoldenrod: 0xeee8aa,
        palegreen: 0x98fb98,
        paleturquoise: 0xafeeee,
        palevioletred: 0xdb7093,
        papayawhip: 0xffefd5,
        peachpuff: 0xffdab9,
        peru: 0xcd853f,
        pink: 0xffc0cb,
        plum: 0xdda0dd,
        powderblue: 0xb0e0e6,
        purple: 0x800080,
        rebeccapurple: 0x663399,
        red: 0xff0000,
        rosybrown: 0xbc8f8f,
        royalblue: 0x4169e1,
        saddlebrown: 0x8b4513,
        salmon: 0xfa8072,
        sandybrown: 0xf4a460,
        seagreen: 0x2e8b57,
        seashell: 0xfff5ee,
        sienna: 0xa0522d,
        silver: 0xc0c0c0,
        skyblue: 0x87ceeb,
        slateblue: 0x6a5acd,
        slategray: 0x708090,
        slategrey: 0x708090,
        snow: 0xfffafa,
        springgreen: 0x00ff7f,
        steelblue: 0x4682b4,
        tan: 0xd2b48c,
        teal: 0x008080,
        thistle: 0xd8bfd8,
        tomato: 0xff6347,
        turquoise: 0x40e0d0,
        violet: 0xee82ee,
        wheat: 0xf5deb3,
        white: 0xffffff,
        whitesmoke: 0xf5f5f5,
        yellow: 0xffff00,
        yellowgreen: 0x9acd32
      };
      define(Color, color, {
        displayable: function () {
          return this.rgb().displayable();
        },
        toString: function () {
          return this.rgb() + "";
        }
      });
      function color(format) {
        var m;
        format = (format + "").trim().toLowerCase();
        return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb(m >> 8 & 0xf | m >> 4 & 0x0f0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1)) : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
      }
      function rgbn(n) {
        return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
      }
      function rgba(r, g, b, a) {
        if (a <= 0) r = g = b = NaN;
        return new Rgb(r, g, b, a);
      }
      function rgbConvert(o) {
        if (!(o instanceof Color)) o = color(o);
        if (!o) return new Rgb();
        o = o.rgb();
        return new Rgb(o.r, o.g, o.b, o.opacity);
      }
      function rgb(r, g, b, opacity) {
        return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
      }
      function Rgb(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
      }
      define(Rgb, rgb, extend(Color, {
        brighter: function (k) {
          k = k == null ? brighter : Math.pow(brighter, k);
          return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        darker: function (k) {
          k = k == null ? darker : Math.pow(darker, k);
          return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        rgb: function () {
          return this;
        },
        displayable: function () {
          return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
        },
        toString: function () {
          var a = this.opacity;
          a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
          return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
        }
      }));
      function hsla(h, s, l, a) {
        if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
        return new Hsl(h, s, l, a);
      }
      function hslConvert(o) {
        if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color)) o = color(o);
        if (!o) return new Hsl();
        if (o instanceof Hsl) return o;
        o = o.rgb();
        var r = o.r / 255,
            g = o.g / 255,
            b = o.b / 255,
            min = Math.min(r, g, b),
            max = Math.max(r, g, b),
            h = NaN,
            s = max - min,
            l = (max + min) / 2;
        if (s) {
          if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
          s /= l < 0.5 ? max + min : 2 - max - min;
          h *= 60;
        } else {
          s = l > 0 && l < 1 ? 0 : h;
        }
        return new Hsl(h, s, l, o.opacity);
      }
      function hsl(h, s, l, opacity) {
        return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
      }
      function Hsl(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
      }
      define(Hsl, hsl, extend(Color, {
        brighter: function (k) {
          k = k == null ? brighter : Math.pow(brighter, k);
          return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
          k = k == null ? darker : Math.pow(darker, k);
          return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
          var h = this.h % 360 + (this.h < 0) * 360,
              s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
              l = this.l,
              m2 = l + (l < 0.5 ? l : 1 - l) * s,
              m1 = 2 * l - m2;
          return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
        },
        displayable: function () {
          return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
        }
      }));
      function hsl2rgb(h, m1, m2) {
        return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
      }
      var deg2rad = Math.PI / 180;
      var rad2deg = 180 / Math.PI;
      var Kn = 18;
      var Xn = 0.950470;
      var Yn = 1;
      var Zn = 1.088830;
      var t0 = 4 / 29;
      var t1 = 6 / 29;
      var t2 = 3 * t1 * t1;
      var t3 = t1 * t1 * t1;
      function labConvert(o) {
        if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
        if (o instanceof Hcl) {
          var h = o.h * deg2rad;
          return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
        }
        if (!(o instanceof Rgb)) o = rgbConvert(o);
        var b = rgb2xyz(o.r),
            a = rgb2xyz(o.g),
            l = rgb2xyz(o.b),
            x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
            y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
            z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
        return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
      }
      function lab(l, a, b, opacity) {
        return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
      }
      function Lab(l, a, b, opacity) {
        this.l = +l;
        this.a = +a;
        this.b = +b;
        this.opacity = +opacity;
      }
      define(Lab, lab, extend(Color, {
        brighter: function (k) {
          return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        darker: function (k) {
          return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        rgb: function () {
          var y = (this.l + 16) / 116,
              x = isNaN(this.a) ? y : y + this.a / 500,
              z = isNaN(this.b) ? y : y - this.b / 200;
          y = Yn * lab2xyz(y);
          x = Xn * lab2xyz(x);
          z = Zn * lab2xyz(z);
          return new Rgb(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), this.opacity);
        }
      }));
      function xyz2lab(t) {
        return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
      }
      function lab2xyz(t) {
        return t > t1 ? t * t * t : t2 * (t - t0);
      }
      function xyz2rgb(x) {
        return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
      }
      function rgb2xyz(x) {
        return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
      }
      function hclConvert(o) {
        if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
        if (!(o instanceof Lab)) o = labConvert(o);
        var h = Math.atan2(o.b, o.a) * rad2deg;
        return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
      }
      function hcl(h, c, l, opacity) {
        return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
      }
      function Hcl(h, c, l, opacity) {
        this.h = +h;
        this.c = +c;
        this.l = +l;
        this.opacity = +opacity;
      }
      define(Hcl, hcl, extend(Color, {
        brighter: function (k) {
          return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
        },
        darker: function (k) {
          return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
        },
        rgb: function () {
          return labConvert(this).rgb();
        }
      }));
      var A = -0.14861;
      var B = +1.78277;
      var C = -0.29227;
      var D = -0.90649;
      var E = +1.97294;
      var ED = E * D;
      var EB = E * B;
      var BC_DA = B * C - D * A;
      function cubehelixConvert(o) {
        if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Rgb)) o = rgbConvert(o);
        var r = o.r / 255,
            g = o.g / 255,
            b = o.b / 255,
            l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
            bl = b - l,
            k = (E * (g - l) - C * bl) / D,
            s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
            h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
        return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
      }
      function cubehelix(h, s, l, opacity) {
        return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
      }
      function Cubehelix(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
      }
      define(Cubehelix, cubehelix, extend(Color, {
        brighter: function (k) {
          k = k == null ? brighter : Math.pow(brighter, k);
          return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
          k = k == null ? darker : Math.pow(darker, k);
          return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
          var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
              l = +this.l,
              a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
              cosh = Math.cos(h),
              sinh = Math.sin(h);
          return new Rgb(255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
        }
      }));
      function basis$1(t1, v0, v1, v2, v3) {
        var t2 = t1 * t1,
            t3 = t2 * t1;
        return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
      }
      var basis$2 = function (values) {
        var n = values.length - 1;
        return function (t) {
          var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
              v1 = values[i],
              v2 = values[i + 1],
              v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
              v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
          return basis$1((t - i / n) * n, v0, v1, v2, v3);
        };
      };
      var basisClosed$1 = function (values) {
        var n = values.length;
        return function (t) {
          var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
              v0 = values[(i + n - 1) % n],
              v1 = values[i % n],
              v2 = values[(i + 1) % n],
              v3 = values[(i + 2) % n];
          return basis$1((t - i / n) * n, v0, v1, v2, v3);
        };
      };
      var constant$3 = function (x) {
        return function () {
          return x;
        };
      };
      function linear$1(a, d) {
        return function (t) {
          return a + t * d;
        };
      }
      function exponential$1(a, b, y) {
        return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
          return Math.pow(a + t * b, y);
        };
      }
      function hue(a, b) {
        var d = b - a;
        return d ? linear$1(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
      }
      function gamma(y) {
        return (y = +y) === 1 ? nogamma : function (a, b) {
          return b - a ? exponential$1(a, b, y) : constant$3(isNaN(a) ? b : a);
        };
      }
      function nogamma(a, b) {
        var d = b - a;
        return d ? linear$1(a, d) : constant$3(isNaN(a) ? b : a);
      }
      var interpolateRgb = function rgbGamma(y) {
        var color$$1 = gamma(y);
        function rgb$$1(start, end) {
          var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),
              g = color$$1(start.g, end.g),
              b = color$$1(start.b, end.b),
              opacity = color$$1(start.opacity, end.opacity);
          return function (t) {
            start.r = r(t);
            start.g = g(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
          };
        }
        rgb$$1.gamma = rgbGamma;
        return rgb$$1;
      }(1);
      function rgbSpline(spline) {
        return function (colors) {
          var n = colors.length,
              r = new Array(n),
              g = new Array(n),
              b = new Array(n),
              i,
              color$$1;
          for (i = 0; i < n; ++i) {
            color$$1 = rgb(colors[i]);
            r[i] = color$$1.r || 0;
            g[i] = color$$1.g || 0;
            b[i] = color$$1.b || 0;
          }
          r = spline(r);
          g = spline(g);
          b = spline(b);
          color$$1.opacity = 1;
          return function (t) {
            color$$1.r = r(t);
            color$$1.g = g(t);
            color$$1.b = b(t);
            return color$$1 + "";
          };
        };
      }
      var rgbBasis = rgbSpline(basis$2);
      var rgbBasisClosed = rgbSpline(basisClosed$1);
      var array$1 = function (a, b) {
        var nb = b ? b.length : 0,
            na = a ? Math.min(nb, a.length) : 0,
            x = new Array(nb),
            c = new Array(nb),
            i;
        for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);
        for (; i < nb; ++i) c[i] = b[i];
        return function (t) {
          for (i = 0; i < na; ++i) c[i] = x[i](t);
          return c;
        };
      };
      var date = function (a, b) {
        var d = new Date();
        return a = +a, b -= a, function (t) {
          return d.setTime(a + b * t), d;
        };
      };
      var interpolateNumber = function (a, b) {
        return a = +a, b -= a, function (t) {
          return a + b * t;
        };
      };
      var object = function (a, b) {
        var i = {},
            c = {},
            k;
        if (a === null || typeof a !== "object") a = {};
        if (b === null || typeof b !== "object") b = {};
        for (k in b) {
          if (k in a) {
            i[k] = interpolate(a[k], b[k]);
          } else {
            c[k] = b[k];
          }
        }
        return function (t) {
          for (k in i) c[k] = i[k](t);
          return c;
        };
      };
      var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
      var reB = new RegExp(reA.source, "g");
      function zero(b) {
        return function () {
          return b;
        };
      }
      function one(b) {
        return function (t) {
          return b(t) + "";
        };
      }
      var interpolateString = function (a, b) {
        var bi = reA.lastIndex = reB.lastIndex = 0,
            am,
            bm,
            bs,
            i = -1,
            s = [],
            q = [];
        a = a + "", b = b + "";
        while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
          if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s[i]) s[i] += bs;else s[++i] = bs;
          }
          if ((am = am[0]) === (bm = bm[0])) {
            if (s[i]) s[i] += bm;else s[++i] = bm;
          } else {
            s[++i] = null;
            q.push({
              i: i,
              x: interpolateNumber(am, bm)
            });
          }
          bi = reB.lastIndex;
        }
        if (bi < b.length) {
          bs = b.slice(bi);
          if (s[i]) s[i] += bs;else s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
      };
      var interpolate = function (a, b) {
        var t = typeof b,
            c;
        return b == null || t === "boolean" ? constant$3(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date : Array.isArray(b) ? array$1 : isNaN(b) ? object : interpolateNumber)(a, b);
      };
      var interpolateRound = function (a, b) {
        return a = +a, b -= a, function (t) {
          return Math.round(a + b * t);
        };
      };
      var degrees = 180 / Math.PI;
      var identity$2 = {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        skewX: 0,
        scaleX: 1,
        scaleY: 1
      };
      var decompose = function (a, b, c, d, e, f) {
        var scaleX, scaleY, skewX;
        if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
        if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
        if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
        if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
        return {
          translateX: e,
          translateY: f,
          rotate: Math.atan2(b, a) * degrees,
          skewX: Math.atan(skewX) * degrees,
          scaleX: scaleX,
          scaleY: scaleY
        };
      };
      var cssNode;
      var cssRoot;
      var cssView;
      var svgNode;
      function parseCss(value) {
        if (value === "none") return identity$2;
        if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
        cssNode.style.transform = value;
        value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
        cssRoot.removeChild(cssNode);
        value = value.slice(7, -1).split(",");
        return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
      }
      function parseSvg(value) {
        if (value == null) return identity$2;
        if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svgNode.setAttribute("transform", value);
        if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
        value = value.matrix;
        return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
      }
      function interpolateTransform(parse, pxComma, pxParen, degParen) {
        function pop(s) {
          return s.length ? s.pop() + " " : "";
        }
        function translate(xa, ya, xb, yb, s, q) {
          if (xa !== xb || ya !== yb) {
            var i = s.push("translate(", null, pxComma, null, pxParen);
            q.push({
              i: i - 4,
              x: interpolateNumber(xa, xb)
            }, {
              i: i - 2,
              x: interpolateNumber(ya, yb)
            });
          } else if (xb || yb) {
            s.push("translate(" + xb + pxComma + yb + pxParen);
          }
        }
        function rotate(a, b, s, q) {
          if (a !== b) {
            if (a - b > 180) b += 360;else if (b - a > 180) a += 360;
            q.push({
              i: s.push(pop(s) + "rotate(", null, degParen) - 2,
              x: interpolateNumber(a, b)
            });
          } else if (b) {
            s.push(pop(s) + "rotate(" + b + degParen);
          }
        }
        function skewX(a, b, s, q) {
          if (a !== b) {
            q.push({
              i: s.push(pop(s) + "skewX(", null, degParen) - 2,
              x: interpolateNumber(a, b)
            });
          } else if (b) {
            s.push(pop(s) + "skewX(" + b + degParen);
          }
        }
        function scale(xa, ya, xb, yb, s, q) {
          if (xa !== xb || ya !== yb) {
            var i = s.push(pop(s) + "scale(", null, ",", null, ")");
            q.push({
              i: i - 4,
              x: interpolateNumber(xa, xb)
            }, {
              i: i - 2,
              x: interpolateNumber(ya, yb)
            });
          } else if (xb !== 1 || yb !== 1) {
            s.push(pop(s) + "scale(" + xb + "," + yb + ")");
          }
        }
        return function (a, b) {
          var s = [],
              q = [];
          a = parse(a), b = parse(b);
          translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
          rotate(a.rotate, b.rotate, s, q);
          skewX(a.skewX, b.skewX, s, q);
          scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
          a = b = null;
          return function (t) {
            var i = -1,
                n = q.length,
                o;
            while (++i < n) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          };
        };
      }
      var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
      var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
      var rho = Math.SQRT2;
      var rho2 = 2;
      var rho4 = 4;
      var epsilon2 = 1e-12;
      function cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
      }
      function sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
      }
      function tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
      }
      var interpolateZoom = function (p0, p1) {
        var ux0 = p0[0],
            uy0 = p0[1],
            w0 = p0[2],
            ux1 = p1[0],
            uy1 = p1[1],
            w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;
        if (d2 < epsilon2) {
          S = Math.log(w1 / w0) / rho;
          i = function (t) {
            return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
          };
        } else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
              b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function (t) {
            var s = t * S,
                coshr0 = cosh(r0),
                u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
          };
        }
        i.duration = S * 1000;
        return i;
      };
      function hsl$1(hue$$1) {
        return function (start, end) {
          var h = hue$$1((start = hsl(start)).h, (end = hsl(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function (t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(t);
            start.opacity = opacity(t);
            return start + "";
          };
        };
      }
      var hsl$2 = hsl$1(hue);
      var hslLong = hsl$1(nogamma);
      function lab$1(start, end) {
        var l = nogamma((start = lab(start)).l, (end = lab(end)).l),
            a = nogamma(start.a, end.a),
            b = nogamma(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function (t) {
          start.l = l(t);
          start.a = a(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
      function hcl$1(hue$$1) {
        return function (start, end) {
          var h = hue$$1((start = hcl(start)).h, (end = hcl(end)).h),
              c = nogamma(start.c, end.c),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function (t) {
            start.h = h(t);
            start.c = c(t);
            start.l = l(t);
            start.opacity = opacity(t);
            return start + "";
          };
        };
      }
      var hcl$2 = hcl$1(hue);
      var hclLong = hcl$1(nogamma);
      function cubehelix$1(hue$$1) {
        return function cubehelixGamma(y) {
          y = +y;
          function cubehelix$$1(start, end) {
            var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),
                s = nogamma(start.s, end.s),
                l = nogamma(start.l, end.l),
                opacity = nogamma(start.opacity, end.opacity);
            return function (t) {
              start.h = h(t);
              start.s = s(t);
              start.l = l(Math.pow(t, y));
              start.opacity = opacity(t);
              return start + "";
            };
          }
          cubehelix$$1.gamma = cubehelixGamma;
          return cubehelix$$1;
        }(1);
      }
      var cubehelix$2 = cubehelix$1(hue);
      var cubehelixLong = cubehelix$1(nogamma);
      var quantize = function (interpolator, n) {
        var samples = new Array(n);
        for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
        return samples;
      };
      var noop$1 = { value: function () {} };
      function dispatch() {
        for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
          if (!(t = arguments[i] + "") || t in _) throw new Error("illegal type: " + t);
          _[t] = [];
        }
        return new Dispatch(_);
      }
      function Dispatch(_) {
        this._ = _;
      }
      function parseTypenames(typenames, types) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
          var name = "",
              i = t.indexOf(".");
          if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
          if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
          return {
            type: t,
            name: name
          };
        });
      }
      Dispatch.prototype = dispatch.prototype = {
        constructor: Dispatch,
        on: function (typename, callback) {
          var _ = this._,
              T = parseTypenames(typename + "", _),
              t,
              i = -1,
              n = T.length;
          if (arguments.length < 2) {
            while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
            return;
          }
          if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
          while (++i < n) {
            if (t = (typename = T[i]).type) _[t] = set$2(_[t], typename.name, callback);else if (callback == null) for (t in _) _[t] = set$2(_[t], typename.name, null);
          }
          return this;
        },
        copy: function () {
          var copy = {},
              _ = this._;
          for (var t in _) copy[t] = _[t].slice();
          return new Dispatch(copy);
        },
        call: function (type, that) {
          if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
          if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
          for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
        },
        apply: function (type, that, args) {
          if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
          for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
        }
      };
      function get(type, name) {
        for (var i = 0, n = type.length, c; i < n; ++i) {
          if ((c = type[i]).name === name) {
            return c.value;
          }
        }
      }
      function set$2(type, name, callback) {
        for (var i = 0, n = type.length; i < n; ++i) {
          if (type[i].name === name) {
            type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
            break;
          }
        }
        if (callback != null) type.push({
          name: name,
          value: callback
        });
        return type;
      }
      function objectConverter(columns) {
        return new Function("d", "return {" + columns.map(function (name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
      }
      function customConverter(columns, f) {
        var object = objectConverter(columns);
        return function (row, i) {
          return f(object(row), i, columns);
        };
      }
      function inferColumns(rows) {
        var columnSet = Object.create(null),
            columns = [];
        rows.forEach(function (row) {
          for (var column in row) {
            if (!(column in columnSet)) {
              columns.push(columnSet[column] = column);
            }
          }
        });
        return columns;
      }
      var dsv = function (delimiter) {
        var reFormat = new RegExp("[\"" + delimiter + "\n]"),
            delimiterCode = delimiter.charCodeAt(0);
        function parse(text, f) {
          var convert,
              columns,
              rows = parseRows(text, function (row, i) {
            if (convert) return convert(row, i - 1);
            columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
          });
          rows.columns = columns;
          return rows;
        }
        function parseRows(text, f) {
          var EOL = {},
              EOF = {},
              rows = [],
              N = text.length,
              I = 0,
              n = 0,
              t,
              eol;
          function token() {
            if (I >= N) return EOF;
            if (eol) return eol = false, EOL;
            var j = I,
                c;
            if (text.charCodeAt(j) === 34) {
              var i = j;
              while (i++ < N) {
                if (text.charCodeAt(i) === 34) {
                  if (text.charCodeAt(i + 1) !== 34) break;
                  ++i;
                }
              }
              I = i + 2;
              c = text.charCodeAt(i + 1);
              if (c === 13) {
                eol = true;
                if (text.charCodeAt(i + 2) === 10) ++I;
              } else if (c === 10) {
                eol = true;
              }
              return text.slice(j + 1, i).replace(/""/g, "\"");
            }
            while (I < N) {
              var k = 1;
              c = text.charCodeAt(I++);
              if (c === 10) eol = true;else if (c === 13) {
                eol = true;
                if (text.charCodeAt(I) === 10) ++I, ++k;
              } else if (c !== delimiterCode) continue;
              return text.slice(j, I - k);
            }
            return text.slice(j);
          }
          while ((t = token()) !== EOF) {
            var a = [];
            while (t !== EOL && t !== EOF) {
              a.push(t);
              t = token();
            }
            if (f && (a = f(a, n++)) == null) continue;
            rows.push(a);
          }
          return rows;
        }
        function format(rows, columns) {
          if (columns == null) columns = inferColumns(rows);
          return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
            return columns.map(function (column) {
              return formatValue(row[column]);
            }).join(delimiter);
          })).join("\n");
        }
        function formatRows(rows) {
          return rows.map(formatRow).join("\n");
        }
        function formatRow(row) {
          return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
          return text == null ? "" : reFormat.test(text += "") ? "\"" + text.replace(/\"/g, "\"\"") + "\"" : text;
        }
        return {
          parse: parse,
          parseRows: parseRows,
          format: format,
          formatRows: formatRows
        };
      };
      var csv = dsv(",");
      var csvParse = csv.parse;
      var csvParseRows = csv.parseRows;
      var csvFormat = csv.format;
      var csvFormatRows = csv.formatRows;
      var tsv = dsv("\t");
      var tsvParse = tsv.parse;
      var tsvParseRows = tsv.parseRows;
      var tsvFormat = tsv.format;
      var tsvFormatRows = tsv.formatRows;
      var request = function (url, callback) {
        var request,
            event = dispatch("beforesend", "progress", "load", "error"),
            mimeType,
            headers = map$1(),
            xhr = new XMLHttpRequest(),
            user = null,
            password = null,
            response,
            responseType,
            timeout = 0;
        if (typeof XDomainRequest !== "undefined" && !("withCredentials" in xhr) && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest();
        "onload" in xhr ? xhr.onload = xhr.onerror = xhr.ontimeout = respond : xhr.onreadystatechange = function (o) {
          xhr.readyState > 3 && respond(o);
        };
        function respond(o) {
          var status = xhr.status,
              result;
          if (!status && hasResponse(xhr) || status >= 200 && status < 300 || status === 304) {
            if (response) {
              try {
                result = response.call(request, xhr);
              } catch (e) {
                event.call("error", request, e);
                return;
              }
            } else {
              result = xhr;
            }
            event.call("load", request, result);
          } else {
            event.call("error", request, o);
          }
        }
        xhr.onprogress = function (e) {
          event.call("progress", request, e);
        };
        request = {
          header: function (name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) return headers.get(name);
            if (value == null) headers.remove(name);else headers.set(name, value + "");
            return request;
          },
          mimeType: function (value) {
            if (!arguments.length) return mimeType;
            mimeType = value == null ? null : value + "";
            return request;
          },
          responseType: function (value) {
            if (!arguments.length) return responseType;
            responseType = value;
            return request;
          },
          timeout: function (value) {
            if (!arguments.length) return timeout;
            timeout = +value;
            return request;
          },
          user: function (value) {
            return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
          },
          password: function (value) {
            return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
          },
          response: function (value) {
            response = value;
            return request;
          },
          get: function (data, callback) {
            return request.send("GET", data, callback);
          },
          post: function (data, callback) {
            return request.send("POST", data, callback);
          },
          send: function (method, data, callback) {
            xhr.open(method, url, true, user, password);
            if (mimeType != null && !headers.has("accept")) headers.set("accept", mimeType + ",*/*");
            if (xhr.setRequestHeader) headers.each(function (value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);
            if (responseType != null) xhr.responseType = responseType;
            if (timeout > 0) xhr.timeout = timeout;
            if (callback == null && typeof data === "function") callback = data, data = null;
            if (callback != null && callback.length === 1) callback = fixCallback(callback);
            if (callback != null) request.on("error", callback).on("load", function (xhr) {
              callback(null, xhr);
            });
            event.call("beforesend", request, xhr);
            xhr.send(data == null ? null : data);
            return request;
          },
          abort: function () {
            xhr.abort();
            return request;
          },
          on: function () {
            var value = event.on.apply(event, arguments);
            return value === event ? request : value;
          }
        };
        if (callback != null) {
          if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
          return request.get(callback);
        }
        return request;
      };
      function fixCallback(callback) {
        return function (error, xhr) {
          callback(error == null ? xhr : null);
        };
      }
      function hasResponse(xhr) {
        var type = xhr.responseType;
        return type && type !== "text" ? xhr.response : xhr.responseText;
      }
      var type = function (defaultMimeType, response) {
        return function (url, callback) {
          var r = request(url).mimeType(defaultMimeType).response(response);
          if (callback != null) {
            if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
            return r.get(callback);
          }
          return r;
        };
      };
      var html = type("text/html", function (xhr) {
        return document.createRange().createContextualFragment(xhr.responseText);
      });
      var json = type("application/json", function (xhr) {
        return JSON.parse(xhr.responseText);
      });
      var text = type("text/plain", function (xhr) {
        return xhr.responseText;
      });
      var xml = type("application/xml", function (xhr) {
        var xml = xhr.responseXML;
        if (!xml) throw new Error("parse error");
        return xml;
      });
      var dsv$1 = function (defaultMimeType, parse) {
        return function (url, row, callback) {
          if (arguments.length < 3) callback = row, row = null;
          var r = request(url).mimeType(defaultMimeType);
          r.row = function (_) {
            return arguments.length ? r.response(responseOf(parse, row = _)) : row;
          };
          r.row(row);
          return callback ? r.get(callback) : r;
        };
      };
      function responseOf(parse, row) {
        return function (request$$1) {
          return parse(request$$1.responseText, row);
        };
      }
      var csv$1 = dsv$1("text/csv", csvParse);
      var tsv$1 = dsv$1("text/tab-separated-values", tsvParse);
      var frame = 0;
      var timeout = 0;
      var interval = 0;
      var pokeDelay = 1000;
      var taskHead;
      var taskTail;
      var clockLast = 0;
      var clockNow = 0;
      var clockSkew = 0;
      var clock = typeof performance === "object" && performance.now ? performance : Date;
      var setFrame = typeof requestAnimationFrame === "function" ? requestAnimationFrame : function (f) {
        setTimeout(f, 17);
      };
      function now() {
        return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
      }
      function clearNow() {
        clockNow = 0;
      }
      function Timer() {
        this._call = this._time = this._next = null;
      }
      Timer.prototype = timer.prototype = {
        constructor: Timer,
        restart: function (callback, delay, time) {
          if (typeof callback !== "function") throw new TypeError("callback is not a function");
          time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
          if (!this._next && taskTail !== this) {
            if (taskTail) taskTail._next = this;else taskHead = this;
            taskTail = this;
          }
          this._call = callback;
          this._time = time;
          sleep();
        },
        stop: function () {
          if (this._call) {
            this._call = null;
            this._time = Infinity;
            sleep();
          }
        }
      };
      function timer(callback, delay, time) {
        var t = new Timer();
        t.restart(callback, delay, time);
        return t;
      }
      function timerFlush() {
        now();
        ++frame;
        var t = taskHead,
            e;
        while (t) {
          if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
          t = t._next;
        }
        --frame;
      }
      function wake() {
        clockNow = (clockLast = clock.now()) + clockSkew;
        frame = timeout = 0;
        try {
          timerFlush();
        } finally {
          frame = 0;
          nap();
          clockNow = 0;
        }
      }
      function poke$1() {
        var now = clock.now(),
            delay = now - clockLast;
        if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
      }
      function nap() {
        var t0,
            t1 = taskHead,
            t2,
            time = Infinity;
        while (t1) {
          if (t1._call) {
            if (time > t1._time) time = t1._time;
            t0 = t1, t1 = t1._next;
          } else {
            t2 = t1._next, t1._next = null;
            t1 = t0 ? t0._next = t2 : taskHead = t2;
          }
        }
        taskTail = t0;
        sleep(time);
      }
      function sleep(time) {
        if (frame) return;
        if (timeout) timeout = clearTimeout(timeout);
        var delay = time - clockNow;
        if (delay > 24) {
          if (time < Infinity) timeout = setTimeout(wake, delay);
          if (interval) interval = clearInterval(interval);
        } else {
          if (!interval) interval = setInterval(poke$1, pokeDelay);
          frame = 1, setFrame(wake);
        }
      }
      var timeout$1 = function (callback, delay, time) {
        var t = new Timer();
        delay = delay == null ? 0 : +delay;
        t.restart(function (elapsed) {
          t.stop();
          callback(elapsed + delay);
        }, delay, time);
        return t;
      };
      var interval$1 = function (callback, delay, time) {
        var t = new Timer(),
            total = delay;
        if (delay == null) return t.restart(callback, delay, time), t;
        delay = +delay, time = time == null ? now() : +time;
        t.restart(function tick(elapsed) {
          elapsed += total;
          t.restart(tick, total += delay, time);
          callback(elapsed);
        }, delay, time);
        return t;
      };
      var t0$1 = new Date();
      var t1$1 = new Date();
      function newInterval(floori, offseti, count, field) {
        function interval(date) {
          return floori(date = new Date(+date)), date;
        }
        interval.floor = interval;
        interval.ceil = function (date) {
          return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
        };
        interval.round = function (date) {
          var d0 = interval(date),
              d1 = interval.ceil(date);
          return date - d0 < d1 - date ? d0 : d1;
        };
        interval.offset = function (date, step) {
          return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
        };
        interval.range = function (start, stop, step) {
          var range = [];
          start = interval.ceil(start);
          step = step == null ? 1 : Math.floor(step);
          if (!(start < stop) || !(step > 0)) return range;
          do range.push(new Date(+start)); while ((offseti(start, step), floori(start), start < stop));
          return range;
        };
        interval.filter = function (test) {
          return newInterval(function (date) {
            if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
          }, function (date, step) {
            if (date >= date) while (--step >= 0) while (offseti(date, 1), !test(date)) {}
          });
        };
        if (count) {
          interval.count = function (start, end) {
            t0$1.setTime(+start), t1$1.setTime(+end);
            floori(t0$1), floori(t1$1);
            return Math.floor(count(t0$1, t1$1));
          };
          interval.every = function (step) {
            step = Math.floor(step);
            return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
              return field(d) % step === 0;
            } : function (d) {
              return interval.count(0, d) % step === 0;
            });
          };
        }
        return interval;
      }
      var millisecond = newInterval(function () {}, function (date, step) {
        date.setTime(+date + step);
      }, function (start, end) {
        return end - start;
      });
      millisecond.every = function (k) {
        k = Math.floor(k);
        if (!isFinite(k) || !(k > 0)) return null;
        if (!(k > 1)) return millisecond;
        return newInterval(function (date) {
          date.setTime(Math.floor(date / k) * k);
        }, function (date, step) {
          date.setTime(+date + step * k);
        }, function (start, end) {
          return (end - start) / k;
        });
      };
      var milliseconds = millisecond.range;
      var durationSecond = 1e3;
      var durationMinute = 6e4;
      var durationHour = 36e5;
      var durationDay = 864e5;
      var durationWeek = 6048e5;
      var second = newInterval(function (date) {
        date.setTime(Math.floor(date / durationSecond) * durationSecond);
      }, function (date, step) {
        date.setTime(+date + step * durationSecond);
      }, function (start, end) {
        return (end - start) / durationSecond;
      }, function (date) {
        return date.getUTCSeconds();
      });
      var seconds = second.range;
      var minute = newInterval(function (date) {
        date.setTime(Math.floor(date / durationMinute) * durationMinute);
      }, function (date, step) {
        date.setTime(+date + step * durationMinute);
      }, function (start, end) {
        return (end - start) / durationMinute;
      }, function (date) {
        return date.getMinutes();
      });
      var minutes = minute.range;
      var hour = newInterval(function (date) {
        var offset = date.getTimezoneOffset() * durationMinute % durationHour;
        if (offset < 0) offset += durationHour;
        date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
      }, function (date, step) {
        date.setTime(+date + step * durationHour);
      }, function (start, end) {
        return (end - start) / durationHour;
      }, function (date) {
        return date.getHours();
      });
      var hours = hour.range;
      var day = newInterval(function (date) {
        date.setHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setDate(date.getDate() + step);
      }, function (start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
      }, function (date) {
        return date.getDate() - 1;
      });
      var days = day.range;
      function weekday(i) {
        return newInterval(function (date) {
          date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
          date.setHours(0, 0, 0, 0);
        }, function (date, step) {
          date.setDate(date.getDate() + step * 7);
        }, function (start, end) {
          return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
        });
      }
      var sunday = weekday(0);
      var monday = weekday(1);
      var tuesday = weekday(2);
      var wednesday = weekday(3);
      var thursday = weekday(4);
      var friday = weekday(5);
      var saturday = weekday(6);
      var sundays = sunday.range;
      var mondays = monday.range;
      var tuesdays = tuesday.range;
      var wednesdays = wednesday.range;
      var thursdays = thursday.range;
      var fridays = friday.range;
      var saturdays = saturday.range;
      var month = newInterval(function (date) {
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setMonth(date.getMonth() + step);
      }, function (start, end) {
        return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
      }, function (date) {
        return date.getMonth();
      });
      var months = month.range;
      var year = newInterval(function (date) {
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setFullYear(date.getFullYear() + step);
      }, function (start, end) {
        return end.getFullYear() - start.getFullYear();
      }, function (date) {
        return date.getFullYear();
      });
      year.every = function (k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
          date.setFullYear(Math.floor(date.getFullYear() / k) * k);
          date.setMonth(0, 1);
          date.setHours(0, 0, 0, 0);
        }, function (date, step) {
          date.setFullYear(date.getFullYear() + step * k);
        });
      };
      var years = year.range;
      var utcMinute = newInterval(function (date) {
        date.setUTCSeconds(0, 0);
      }, function (date, step) {
        date.setTime(+date + step * durationMinute);
      }, function (start, end) {
        return (end - start) / durationMinute;
      }, function (date) {
        return date.getUTCMinutes();
      });
      var utcMinutes = utcMinute.range;
      var utcHour = newInterval(function (date) {
        date.setUTCMinutes(0, 0, 0);
      }, function (date, step) {
        date.setTime(+date + step * durationHour);
      }, function (start, end) {
        return (end - start) / durationHour;
      }, function (date) {
        return date.getUTCHours();
      });
      var utcHours = utcHour.range;
      var utcDay = newInterval(function (date) {
        date.setUTCHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setUTCDate(date.getUTCDate() + step);
      }, function (start, end) {
        return (end - start) / durationDay;
      }, function (date) {
        return date.getUTCDate() - 1;
      });
      var utcDays = utcDay.range;
      function utcWeekday(i) {
        return newInterval(function (date) {
          date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
          date.setUTCHours(0, 0, 0, 0);
        }, function (date, step) {
          date.setUTCDate(date.getUTCDate() + step * 7);
        }, function (start, end) {
          return (end - start) / durationWeek;
        });
      }
      var utcSunday = utcWeekday(0);
      var utcMonday = utcWeekday(1);
      var utcTuesday = utcWeekday(2);
      var utcWednesday = utcWeekday(3);
      var utcThursday = utcWeekday(4);
      var utcFriday = utcWeekday(5);
      var utcSaturday = utcWeekday(6);
      var utcSundays = utcSunday.range;
      var utcMondays = utcMonday.range;
      var utcTuesdays = utcTuesday.range;
      var utcWednesdays = utcWednesday.range;
      var utcThursdays = utcThursday.range;
      var utcFridays = utcFriday.range;
      var utcSaturdays = utcSaturday.range;
      var utcMonth = newInterval(function (date) {
        date.setUTCDate(1);
        date.setUTCHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setUTCMonth(date.getUTCMonth() + step);
      }, function (start, end) {
        return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
      }, function (date) {
        return date.getUTCMonth();
      });
      var utcMonths = utcMonth.range;
      var utcYear = newInterval(function (date) {
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step);
      }, function (start, end) {
        return end.getUTCFullYear() - start.getUTCFullYear();
      }, function (date) {
        return date.getUTCFullYear();
      });
      utcYear.every = function (k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
          date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
          date.setUTCMonth(0, 1);
          date.setUTCHours(0, 0, 0, 0);
        }, function (date, step) {
          date.setUTCFullYear(date.getUTCFullYear() + step * k);
        });
      };
      var utcYears = utcYear.range;
      var formatDecimal = function (x, p) {
        if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null;
        var i,
            coefficient = x.slice(0, i);
        return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
      };
      var exponent$1 = function (x) {
        return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
      };
      var formatGroup = function (grouping, thousands) {
        return function (value, width) {
          var i = value.length,
              t = [],
              j = 0,
              g = grouping[0],
              length = 0;
          while (i > 0 && g > 0) {
            if (length + g + 1 > width) g = Math.max(1, width - length);
            t.push(value.substring(i -= g, i + g));
            if ((length += g + 1) > width) break;
            g = grouping[j = (j + 1) % grouping.length];
          }
          return t.reverse().join(thousands);
        };
      };
      var formatDefault = function (x, p) {
        x = x.toPrecision(p);
        out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
          switch (x[i]) {
            case ".":
              i0 = i1 = i;
              break;
            case "0":
              if (i0 === 0) i0 = i;
              i1 = i;
              break;
            case "e":
              break out;
            default:
              if (i0 > 0) i0 = 0;
              break;
          }
        }
        return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
      };
      var prefixExponent;
      var formatPrefixAuto = function (x, p) {
        var d = formatDecimal(x, p);
        if (!d) return x + "";
        var coefficient = d[0],
            exponent = d[1],
            i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
            n = coefficient.length;
        return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0];
      };
      var formatRounded = function (x, p) {
        var d = formatDecimal(x, p);
        if (!d) return x + "";
        var coefficient = d[0],
            exponent = d[1];
        return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
      };
      var formatTypes = {
        "": formatDefault,
        "%": function (x, p) {
          return (x * 100).toFixed(p);
        },
        "b": function (x) {
          return Math.round(x).toString(2);
        },
        "c": function (x) {
          return x + "";
        },
        "d": function (x) {
          return Math.round(x).toString(10);
        },
        "e": function (x, p) {
          return x.toExponential(p);
        },
        "f": function (x, p) {
          return x.toFixed(p);
        },
        "g": function (x, p) {
          return x.toPrecision(p);
        },
        "o": function (x) {
          return Math.round(x).toString(8);
        },
        "p": function (x, p) {
          return formatRounded(x * 100, p);
        },
        "r": formatRounded,
        "s": formatPrefixAuto,
        "X": function (x) {
          return Math.round(x).toString(16).toUpperCase();
        },
        "x": function (x) {
          return Math.round(x).toString(16);
        }
      };
      var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;
      var formatSpecifier = function (specifier) {
        return new FormatSpecifier(specifier);
      };
      function FormatSpecifier(specifier) {
        if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
        var match,
            fill = match[1] || " ",
            align = match[2] || ">",
            sign = match[3] || "-",
            symbol = match[4] || "",
            zero = !!match[5],
            width = match[6] && +match[6],
            comma = !!match[7],
            precision = match[8] && +match[8].slice(1),
            type = match[9] || "";
        if (type === "n") comma = true, type = "g";else if (!formatTypes[type]) type = "";
        if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
        this.fill = fill;
        this.align = align;
        this.sign = sign;
        this.symbol = symbol;
        this.zero = zero;
        this.width = width;
        this.comma = comma;
        this.precision = precision;
        this.type = type;
      }
      FormatSpecifier.prototype.toString = function () {
        return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + this.type;
      };
      var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
      function identity$3(x) {
        return x;
      }
      var formatLocale = function (locale) {
        var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,
            currency = locale.currency,
            decimal = locale.decimal;
        function newFormat(specifier) {
          specifier = formatSpecifier(specifier);
          var fill = specifier.fill,
              align = specifier.align,
              sign = specifier.sign,
              symbol = specifier.symbol,
              zero = specifier.zero,
              width = specifier.width,
              comma = specifier.comma,
              precision = specifier.precision,
              type = specifier.type;
          var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
              suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";
          var formatType = formatTypes[type],
              maybeSuffix = !type || /[defgprs%]/.test(type);
          precision = precision == null ? type ? 6 : 12 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
          function format(value) {
            var valuePrefix = prefix,
                valueSuffix = suffix,
                i,
                n,
                c;
            if (type === "c") {
              valueSuffix = formatType(value) + valueSuffix;
              value = "";
            } else {
              value = +value;
              var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);
              value = formatType(value, precision);
              if (valueNegative) {
                i = -1, n = value.length;
                valueNegative = false;
                while (++i < n) {
                  if (c = value.charCodeAt(i), 48 < c && c < 58 || type === "x" && 96 < c && c < 103 || type === "X" && 64 < c && c < 71) {
                    valueNegative = true;
                    break;
                  }
                }
              }
              valuePrefix = (valueNegative ? sign === "(" ? sign : "-" : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
              valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");
              if (maybeSuffix) {
                i = -1, n = value.length;
                while (++i < n) {
                  if (c = value.charCodeAt(i), 48 > c || c > 57) {
                    valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                    value = value.slice(0, i);
                    break;
                  }
                }
              }
            }
            if (comma && !zero) value = group(value, Infinity);
            var length = valuePrefix.length + value.length + valueSuffix.length,
                padding = length < width ? new Array(width - length + 1).join(fill) : "";
            if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
            switch (align) {
              case "<":
                return valuePrefix + value + valueSuffix + padding;
              case "=":
                return valuePrefix + padding + value + valueSuffix;
              case "^":
                return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
            }
            return padding + valuePrefix + value + valueSuffix;
          }
          format.toString = function () {
            return specifier + "";
          };
          return format;
        }
        function formatPrefix(specifier, value) {
          var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
              e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
              k = Math.pow(10, -e),
              prefix = prefixes[8 + e / 3];
          return function (value) {
            return f(k * value) + prefix;
          };
        }
        return {
          format: newFormat,
          formatPrefix: formatPrefix
        };
      };
      var locale$1;
      defaultLocale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""]
      });
      function defaultLocale(definition) {
        locale$1 = formatLocale(definition);
        exports.format = locale$1.format;
        exports.formatPrefix = locale$1.formatPrefix;
        return locale$1;
      }
      var precisionFixed = function (step) {
        return Math.max(0, -exponent$1(Math.abs(step)));
      };
      var precisionPrefix = function (step, value) {
        return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
      };
      var precisionRound = function (step, max) {
        step = Math.abs(step), max = Math.abs(max) - step;
        return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
      };
      function localDate(d) {
        if (0 <= d.y && d.y < 100) {
          var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
          date.setFullYear(d.y);
          return date;
        }
        return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
      }
      function utcDate(d) {
        if (0 <= d.y && d.y < 100) {
          var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
          date.setUTCFullYear(d.y);
          return date;
        }
        return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
      }
      function newYear(y) {
        return {
          y: y,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0
        };
      }
      function formatLocale$1(locale) {
        var locale_dateTime = locale.dateTime,
            locale_date = locale.date,
            locale_time = locale.time,
            locale_periods = locale.periods,
            locale_weekdays = locale.days,
            locale_shortWeekdays = locale.shortDays,
            locale_months = locale.months,
            locale_shortMonths = locale.shortMonths;
        var periodRe = formatRe(locale_periods),
            periodLookup = formatLookup(locale_periods),
            weekdayRe = formatRe(locale_weekdays),
            weekdayLookup = formatLookup(locale_weekdays),
            shortWeekdayRe = formatRe(locale_shortWeekdays),
            shortWeekdayLookup = formatLookup(locale_shortWeekdays),
            monthRe = formatRe(locale_months),
            monthLookup = formatLookup(locale_months),
            shortMonthRe = formatRe(locale_shortMonths),
            shortMonthLookup = formatLookup(locale_shortMonths);
        var formats = {
          "a": formatShortWeekday,
          "A": formatWeekday,
          "b": formatShortMonth,
          "B": formatMonth,
          "c": null,
          "d": formatDayOfMonth,
          "e": formatDayOfMonth,
          "H": formatHour24,
          "I": formatHour12,
          "j": formatDayOfYear,
          "L": formatMilliseconds,
          "m": formatMonthNumber,
          "M": formatMinutes,
          "p": formatPeriod,
          "S": formatSeconds,
          "U": formatWeekNumberSunday,
          "w": formatWeekdayNumber,
          "W": formatWeekNumberMonday,
          "x": null,
          "X": null,
          "y": formatYear,
          "Y": formatFullYear,
          "Z": formatZone,
          "%": formatLiteralPercent
        };
        var utcFormats = {
          "a": formatUTCShortWeekday,
          "A": formatUTCWeekday,
          "b": formatUTCShortMonth,
          "B": formatUTCMonth,
          "c": null,
          "d": formatUTCDayOfMonth,
          "e": formatUTCDayOfMonth,
          "H": formatUTCHour24,
          "I": formatUTCHour12,
          "j": formatUTCDayOfYear,
          "L": formatUTCMilliseconds,
          "m": formatUTCMonthNumber,
          "M": formatUTCMinutes,
          "p": formatUTCPeriod,
          "S": formatUTCSeconds,
          "U": formatUTCWeekNumberSunday,
          "w": formatUTCWeekdayNumber,
          "W": formatUTCWeekNumberMonday,
          "x": null,
          "X": null,
          "y": formatUTCYear,
          "Y": formatUTCFullYear,
          "Z": formatUTCZone,
          "%": formatLiteralPercent
        };
        var parses = {
          "a": parseShortWeekday,
          "A": parseWeekday,
          "b": parseShortMonth,
          "B": parseMonth,
          "c": parseLocaleDateTime,
          "d": parseDayOfMonth,
          "e": parseDayOfMonth,
          "H": parseHour24,
          "I": parseHour24,
          "j": parseDayOfYear,
          "L": parseMilliseconds,
          "m": parseMonthNumber,
          "M": parseMinutes,
          "p": parsePeriod,
          "S": parseSeconds,
          "U": parseWeekNumberSunday,
          "w": parseWeekdayNumber,
          "W": parseWeekNumberMonday,
          "x": parseLocaleDate,
          "X": parseLocaleTime,
          "y": parseYear,
          "Y": parseFullYear,
          "Z": parseZone,
          "%": parseLiteralPercent
        };
        formats.x = newFormat(locale_date, formats);
        formats.X = newFormat(locale_time, formats);
        formats.c = newFormat(locale_dateTime, formats);
        utcFormats.x = newFormat(locale_date, utcFormats);
        utcFormats.X = newFormat(locale_time, utcFormats);
        utcFormats.c = newFormat(locale_dateTime, utcFormats);
        function newFormat(specifier, formats) {
          return function (date) {
            var string = [],
                i = -1,
                j = 0,
                n = specifier.length,
                c,
                pad,
                format;
            if (!(date instanceof Date)) date = new Date(+date);
            while (++i < n) {
              if (specifier.charCodeAt(i) === 37) {
                string.push(specifier.slice(j, i));
                if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
                if (format = formats[c]) c = format(date, pad);
                string.push(c);
                j = i + 1;
              }
            }
            string.push(specifier.slice(j, i));
            return string.join("");
          };
        }
        function newParse(specifier, newDate) {
          return function (string) {
            var d = newYear(1900),
                i = parseSpecifier(d, specifier, string += "", 0);
            if (i != string.length) return null;
            if ("p" in d) d.H = d.H % 12 + d.p * 12;
            if ("W" in d || "U" in d) {
              if (!("w" in d)) d.w = "W" in d ? 1 : 0;
              var day$$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
              d.m = 0;
              d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;
            }
            if ("Z" in d) {
              d.H += d.Z / 100 | 0;
              d.M += d.Z % 100;
              return utcDate(d);
            }
            return newDate(d);
          };
        }
        function parseSpecifier(d, specifier, string, j) {
          var i = 0,
              n = specifier.length,
              m = string.length,
              c,
              parse;
          while (i < n) {
            if (j >= m) return -1;
            c = specifier.charCodeAt(i++);
            if (c === 37) {
              c = specifier.charAt(i++);
              parse = parses[c in pads ? specifier.charAt(i++) : c];
              if (!parse || (j = parse(d, string, j)) < 0) return -1;
            } else if (c != string.charCodeAt(j++)) {
              return -1;
            }
          }
          return j;
        }
        function parsePeriod(d, string, i) {
          var n = periodRe.exec(string.slice(i));
          return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseShortWeekday(d, string, i) {
          var n = shortWeekdayRe.exec(string.slice(i));
          return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseWeekday(d, string, i) {
          var n = weekdayRe.exec(string.slice(i));
          return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseShortMonth(d, string, i) {
          var n = shortMonthRe.exec(string.slice(i));
          return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseMonth(d, string, i) {
          var n = monthRe.exec(string.slice(i));
          return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseLocaleDateTime(d, string, i) {
          return parseSpecifier(d, locale_dateTime, string, i);
        }
        function parseLocaleDate(d, string, i) {
          return parseSpecifier(d, locale_date, string, i);
        }
        function parseLocaleTime(d, string, i) {
          return parseSpecifier(d, locale_time, string, i);
        }
        function formatShortWeekday(d) {
          return locale_shortWeekdays[d.getDay()];
        }
        function formatWeekday(d) {
          return locale_weekdays[d.getDay()];
        }
        function formatShortMonth(d) {
          return locale_shortMonths[d.getMonth()];
        }
        function formatMonth(d) {
          return locale_months[d.getMonth()];
        }
        function formatPeriod(d) {
          return locale_periods[+(d.getHours() >= 12)];
        }
        function formatUTCShortWeekday(d) {
          return locale_shortWeekdays[d.getUTCDay()];
        }
        function formatUTCWeekday(d) {
          return locale_weekdays[d.getUTCDay()];
        }
        function formatUTCShortMonth(d) {
          return locale_shortMonths[d.getUTCMonth()];
        }
        function formatUTCMonth(d) {
          return locale_months[d.getUTCMonth()];
        }
        function formatUTCPeriod(d) {
          return locale_periods[+(d.getUTCHours() >= 12)];
        }
        return {
          format: function (specifier) {
            var f = newFormat(specifier += "", formats);
            f.toString = function () {
              return specifier;
            };
            return f;
          },
          parse: function (specifier) {
            var p = newParse(specifier += "", localDate);
            p.toString = function () {
              return specifier;
            };
            return p;
          },
          utcFormat: function (specifier) {
            var f = newFormat(specifier += "", utcFormats);
            f.toString = function () {
              return specifier;
            };
            return f;
          },
          utcParse: function (specifier) {
            var p = newParse(specifier, utcDate);
            p.toString = function () {
              return specifier;
            };
            return p;
          }
        };
      }
      var pads = {
        "-": "",
        "_": " ",
        "0": "0"
      };
      var numberRe = /^\s*\d+/;
      var percentRe = /^%/;
      var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      function pad(value, fill, width) {
        var sign = value < 0 ? "-" : "",
            string = (sign ? -value : value) + "",
            length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
      }
      function requote(s) {
        return s.replace(requoteRe, "\\$&");
      }
      function formatRe(names) {
        return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
      }
      function formatLookup(names) {
        var map = {},
            i = -1,
            n = names.length;
        while (++i < n) map[names[i].toLowerCase()] = i;
        return map;
      }
      function parseWeekdayNumber(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 1));
        return n ? (d.w = +n[0], i + n[0].length) : -1;
      }
      function parseWeekNumberSunday(d, string, i) {
        var n = numberRe.exec(string.slice(i));
        return n ? (d.U = +n[0], i + n[0].length) : -1;
      }
      function parseWeekNumberMonday(d, string, i) {
        var n = numberRe.exec(string.slice(i));
        return n ? (d.W = +n[0], i + n[0].length) : -1;
      }
      function parseFullYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 4));
        return n ? (d.y = +n[0], i + n[0].length) : -1;
      }
      function parseYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
      }
      function parseZone(d, string, i) {
        var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
        return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
      }
      function parseMonthNumber(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
      }
      function parseDayOfMonth(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.d = +n[0], i + n[0].length) : -1;
      }
      function parseDayOfYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 3));
        return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
      }
      function parseHour24(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.H = +n[0], i + n[0].length) : -1;
      }
      function parseMinutes(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.M = +n[0], i + n[0].length) : -1;
      }
      function parseSeconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.S = +n[0], i + n[0].length) : -1;
      }
      function parseMilliseconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 3));
        return n ? (d.L = +n[0], i + n[0].length) : -1;
      }
      function parseLiteralPercent(d, string, i) {
        var n = percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
      }
      function formatDayOfMonth(d, p) {
        return pad(d.getDate(), p, 2);
      }
      function formatHour24(d, p) {
        return pad(d.getHours(), p, 2);
      }
      function formatHour12(d, p) {
        return pad(d.getHours() % 12 || 12, p, 2);
      }
      function formatDayOfYear(d, p) {
        return pad(1 + day.count(year(d), d), p, 3);
      }
      function formatMilliseconds(d, p) {
        return pad(d.getMilliseconds(), p, 3);
      }
      function formatMonthNumber(d, p) {
        return pad(d.getMonth() + 1, p, 2);
      }
      function formatMinutes(d, p) {
        return pad(d.getMinutes(), p, 2);
      }
      function formatSeconds(d, p) {
        return pad(d.getSeconds(), p, 2);
      }
      function formatWeekNumberSunday(d, p) {
        return pad(sunday.count(year(d), d), p, 2);
      }
      function formatWeekdayNumber(d) {
        return d.getDay();
      }
      function formatWeekNumberMonday(d, p) {
        return pad(monday.count(year(d), d), p, 2);
      }
      function formatYear(d, p) {
        return pad(d.getFullYear() % 100, p, 2);
      }
      function formatFullYear(d, p) {
        return pad(d.getFullYear() % 10000, p, 4);
      }
      function formatZone(d) {
        var z = d.getTimezoneOffset();
        return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
      }
      function formatUTCDayOfMonth(d, p) {
        return pad(d.getUTCDate(), p, 2);
      }
      function formatUTCHour24(d, p) {
        return pad(d.getUTCHours(), p, 2);
      }
      function formatUTCHour12(d, p) {
        return pad(d.getUTCHours() % 12 || 12, p, 2);
      }
      function formatUTCDayOfYear(d, p) {
        return pad(1 + utcDay.count(utcYear(d), d), p, 3);
      }
      function formatUTCMilliseconds(d, p) {
        return pad(d.getUTCMilliseconds(), p, 3);
      }
      function formatUTCMonthNumber(d, p) {
        return pad(d.getUTCMonth() + 1, p, 2);
      }
      function formatUTCMinutes(d, p) {
        return pad(d.getUTCMinutes(), p, 2);
      }
      function formatUTCSeconds(d, p) {
        return pad(d.getUTCSeconds(), p, 2);
      }
      function formatUTCWeekNumberSunday(d, p) {
        return pad(utcSunday.count(utcYear(d), d), p, 2);
      }
      function formatUTCWeekdayNumber(d) {
        return d.getUTCDay();
      }
      function formatUTCWeekNumberMonday(d, p) {
        return pad(utcMonday.count(utcYear(d), d), p, 2);
      }
      function formatUTCYear(d, p) {
        return pad(d.getUTCFullYear() % 100, p, 2);
      }
      function formatUTCFullYear(d, p) {
        return pad(d.getUTCFullYear() % 10000, p, 4);
      }
      function formatUTCZone() {
        return "+0000";
      }
      function formatLiteralPercent() {
        return "%";
      }
      var locale$2;
      defaultLocale$1({
        dateTime: "%x, %X",
        date: "%-m/%-d/%Y",
        time: "%-I:%M:%S %p",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
      });
      function defaultLocale$1(definition) {
        locale$2 = formatLocale$1(definition);
        exports.timeFormat = locale$2.format;
        exports.timeParse = locale$2.parse;
        exports.utcFormat = locale$2.utcFormat;
        exports.utcParse = locale$2.utcParse;
        return locale$2;
      }
      var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
      function formatIsoNative(date) {
        return date.toISOString();
      }
      var formatIso = Date.prototype.toISOString ? formatIsoNative : exports.utcFormat(isoSpecifier);
      function parseIsoNative(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
      }
      var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : exports.utcParse(isoSpecifier);
      var array$2 = Array.prototype;
      var map$3 = array$2.map;
      var slice$3 = array$2.slice;
      var implicit = { name: "implicit" };
      function ordinal(range) {
        var index = map$1(),
            domain = [],
            unknown = implicit;
        range = range == null ? [] : slice$3.call(range);
        function scale(d) {
          var key = d + "",
              i = index.get(key);
          if (!i) {
            if (unknown !== implicit) return unknown;
            index.set(key, i = domain.push(d));
          }
          return range[(i - 1) % range.length];
        }
        scale.domain = function (_) {
          if (!arguments.length) return domain.slice();
          domain = [], index = map$1();
          var i = -1,
              n = _.length,
              d,
              key;
          while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
          return scale;
        };
        scale.range = function (_) {
          return arguments.length ? (range = slice$3.call(_), scale) : range.slice();
        };
        scale.unknown = function (_) {
          return arguments.length ? (unknown = _, scale) : unknown;
        };
        scale.copy = function () {
          return ordinal().domain(domain).range(range).unknown(unknown);
        };
        return scale;
      }
      function band() {
        var scale = ordinal().unknown(undefined),
            domain = scale.domain,
            ordinalRange = scale.range,
            range$$1 = [0, 1],
            step,
            bandwidth,
            round = false,
            paddingInner = 0,
            paddingOuter = 0,
            align = 0.5;
        delete scale.unknown;
        function rescale() {
          var n = domain().length,
              reverse = range$$1[1] < range$$1[0],
              start = range$$1[reverse - 0],
              stop = range$$1[1 - reverse];
          step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
          if (round) step = Math.floor(step);
          start += (stop - start - step * (n - paddingInner)) * align;
          bandwidth = step * (1 - paddingInner);
          if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
          var values = range(n).map(function (i) {
            return start + step * i;
          });
          return ordinalRange(reverse ? values.reverse() : values);
        }
        scale.domain = function (_) {
          return arguments.length ? (domain(_), rescale()) : domain();
        };
        scale.range = function (_) {
          return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();
        };
        scale.rangeRound = function (_) {
          return range$$1 = [+_[0], +_[1]], round = true, rescale();
        };
        scale.bandwidth = function () {
          return bandwidth;
        };
        scale.step = function () {
          return step;
        };
        scale.round = function (_) {
          return arguments.length ? (round = !!_, rescale()) : round;
        };
        scale.padding = function (_) {
          return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
        };
        scale.paddingInner = function (_) {
          return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
        };
        scale.paddingOuter = function (_) {
          return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
        };
        scale.align = function (_) {
          return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
        };
        scale.copy = function () {
          return band().domain(domain()).range(range$$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
        };
        return rescale();
      }
      function pointish(scale) {
        var copy = scale.copy;
        scale.padding = scale.paddingOuter;
        delete scale.paddingInner;
        delete scale.paddingOuter;
        scale.copy = function () {
          return pointish(copy());
        };
        return scale;
      }
      function point$4() {
        return pointish(band().paddingInner(1));
      }
      var constant$4 = function (x) {
        return function () {
          return x;
        };
      };
      var number$1 = function (x) {
        return +x;
      };
      var unit = [0, 1];
      function deinterpolateLinear(a, b) {
        return (b -= a = +a) ? function (x) {
          return (x - a) / b;
        } : constant$4(b);
      }
      function deinterpolateClamp(deinterpolate) {
        return function (a, b) {
          var d = deinterpolate(a = +a, b = +b);
          return function (x) {
            return x <= a ? 0 : x >= b ? 1 : d(x);
          };
        };
      }
      function reinterpolateClamp(reinterpolate) {
        return function (a, b) {
          var r = reinterpolate(a = +a, b = +b);
          return function (t) {
            return t <= 0 ? a : t >= 1 ? b : r(t);
          };
        };
      }
      function bimap(domain, range$$1, deinterpolate, reinterpolate) {
        var d0 = domain[0],
            d1 = domain[1],
            r0 = range$$1[0],
            r1 = range$$1[1];
        if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
        return function (x) {
          return r0(d0(x));
        };
      }
      function polymap(domain, range$$1, deinterpolate, reinterpolate) {
        var j = Math.min(domain.length, range$$1.length) - 1,
            d = new Array(j),
            r = new Array(j),
            i = -1;
        if (domain[j] < domain[0]) {
          domain = domain.slice().reverse();
          range$$1 = range$$1.slice().reverse();
        }
        while (++i < j) {
          d[i] = deinterpolate(domain[i], domain[i + 1]);
          r[i] = reinterpolate(range$$1[i], range$$1[i + 1]);
        }
        return function (x) {
          var i = bisectRight(domain, x, 1, j) - 1;
          return r[i](d[i](x));
        };
      }
      function copy(source, target) {
        return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp());
      }
      function continuous(deinterpolate, reinterpolate) {
        var domain = unit,
            range$$1 = unit,
            interpolate$$1 = interpolate,
            clamp = false,
            piecewise,
            output,
            input;
        function rescale() {
          piecewise = Math.min(domain.length, range$$1.length) > 2 ? polymap : bimap;
          output = input = null;
          return scale;
        }
        function scale(x) {
          return (output || (output = piecewise(domain, range$$1, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
        }
        scale.invert = function (y) {
          return (input || (input = piecewise(range$$1, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
        };
        scale.domain = function (_) {
          return arguments.length ? (domain = map$3.call(_, number$1), rescale()) : domain.slice();
        };
        scale.range = function (_) {
          return arguments.length ? (range$$1 = slice$3.call(_), rescale()) : range$$1.slice();
        };
        scale.rangeRound = function (_) {
          return range$$1 = slice$3.call(_), interpolate$$1 = interpolateRound, rescale();
        };
        scale.clamp = function (_) {
          return arguments.length ? (clamp = !!_, rescale()) : clamp;
        };
        scale.interpolate = function (_) {
          return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
        };
        return rescale();
      }
      var tickFormat = function (domain, count, specifier) {
        var start = domain[0],
            stop = domain[domain.length - 1],
            step = tickStep(start, stop, count == null ? 10 : count),
            precision;
        specifier = formatSpecifier(specifier == null ? ",f" : specifier);
        switch (specifier.type) {
          case "s":
            {
              var value = Math.max(Math.abs(start), Math.abs(stop));
              if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
              return exports.formatPrefix(specifier, value);
            }
          case "":
          case "e":
          case "g":
          case "p":
          case "r":
            {
              if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
              break;
            }
          case "f":
          case "%":
            {
              if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
              break;
            }
        }
        return exports.format(specifier);
      };
      function linearish(scale) {
        var domain = scale.domain;
        scale.ticks = function (count) {
          var d = domain();
          return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
        };
        scale.tickFormat = function (count, specifier) {
          return tickFormat(domain(), count, specifier);
        };
        scale.nice = function (count) {
          var d = domain(),
              i = d.length - 1,
              n = count == null ? 10 : count,
              start = d[0],
              stop = d[i],
              step = tickStep(start, stop, n);
          if (step) {
            step = tickStep(Math.floor(start / step) * step, Math.ceil(stop / step) * step, n);
            d[0] = Math.floor(start / step) * step;
            d[i] = Math.ceil(stop / step) * step;
            domain(d);
          }
          return scale;
        };
        return scale;
      }
      function linear$2() {
        var scale = continuous(deinterpolateLinear, interpolateNumber);
        scale.copy = function () {
          return copy(scale, linear$2());
        };
        return linearish(scale);
      }
      function identity$4() {
        var domain = [0, 1];
        function scale(x) {
          return +x;
        }
        scale.invert = scale;
        scale.domain = scale.range = function (_) {
          return arguments.length ? (domain = map$3.call(_, number$1), scale) : domain.slice();
        };
        scale.copy = function () {
          return identity$4().domain(domain);
        };
        return linearish(scale);
      }
      var nice = function (domain, interval) {
        domain = domain.slice();
        var i0 = 0,
            i1 = domain.length - 1,
            x0 = domain[i0],
            x1 = domain[i1],
            t;
        if (x1 < x0) {
          t = i0, i0 = i1, i1 = t;
          t = x0, x0 = x1, x1 = t;
        }
        domain[i0] = interval.floor(x0);
        domain[i1] = interval.ceil(x1);
        return domain;
      };
      function deinterpolate(a, b) {
        return (b = Math.log(b / a)) ? function (x) {
          return Math.log(x / a) / b;
        } : constant$4(b);
      }
      function reinterpolate(a, b) {
        return a < 0 ? function (t) {
          return -Math.pow(-b, t) * Math.pow(-a, 1 - t);
        } : function (t) {
          return Math.pow(b, t) * Math.pow(a, 1 - t);
        };
      }
      function pow10(x) {
        return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
      }
      function powp(base) {
        return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {
          return Math.pow(base, x);
        };
      }
      function logp(base) {
        return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function (x) {
          return Math.log(x) / base;
        });
      }
      function reflect(f) {
        return function (x) {
          return -f(-x);
        };
      }
      function log() {
        var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),
            domain = scale.domain,
            base = 10,
            logs = logp(10),
            pows = powp(10);
        function rescale() {
          logs = logp(base), pows = powp(base);
          if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
          return scale;
        }
        scale.base = function (_) {
          return arguments.length ? (base = +_, rescale()) : base;
        };
        scale.domain = function (_) {
          return arguments.length ? (domain(_), rescale()) : domain();
        };
        scale.ticks = function (count) {
          var d = domain(),
              u = d[0],
              v = d[d.length - 1],
              r;
          if (r = v < u) i = u, u = v, v = i;
          var i = logs(u),
              j = logs(v),
              p,
              k,
              t,
              n = count == null ? 10 : +count,
              z = [];
          if (!(base % 1) && j - i < n) {
            i = Math.round(i) - 1, j = Math.round(j) + 1;
            if (u > 0) for (; i < j; ++i) {
              for (k = 1, p = pows(i); k < base; ++k) {
                t = p * k;
                if (t < u) continue;
                if (t > v) break;
                z.push(t);
              }
            } else for (; i < j; ++i) {
              for (k = base - 1, p = pows(i); k >= 1; --k) {
                t = p * k;
                if (t < u) continue;
                if (t > v) break;
                z.push(t);
              }
            }
          } else {
            z = ticks(i, j, Math.min(j - i, n)).map(pows);
          }
          return r ? z.reverse() : z;
        };
        scale.tickFormat = function (count, specifier) {
          if (specifier == null) specifier = base === 10 ? ".0e" : ",";
          if (typeof specifier !== "function") specifier = exports.format(specifier);
          if (count === Infinity) return specifier;
          if (count == null) count = 10;
          var k = Math.max(1, base * count / scale.ticks().length);
          return function (d) {
            var i = d / pows(Math.round(logs(d)));
            if (i * base < base - 0.5) i *= base;
            return i <= k ? specifier(d) : "";
          };
        };
        scale.nice = function () {
          return domain(nice(domain(), {
            floor: function (x) {
              return pows(Math.floor(logs(x)));
            },
            ceil: function (x) {
              return pows(Math.ceil(logs(x)));
            }
          }));
        };
        scale.copy = function () {
          return copy(scale, log().base(base));
        };
        return scale;
      }
      function raise(x, exponent) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      }
      function pow() {
        var exponent = 1,
            scale = continuous(deinterpolate, reinterpolate),
            domain = scale.domain;
        function deinterpolate(a, b) {
          return (b = raise(b, exponent) - (a = raise(a, exponent))) ? function (x) {
            return (raise(x, exponent) - a) / b;
          } : constant$4(b);
        }
        function reinterpolate(a, b) {
          b = raise(b, exponent) - (a = raise(a, exponent));
          return function (t) {
            return raise(a + b * t, 1 / exponent);
          };
        }
        scale.exponent = function (_) {
          return arguments.length ? (exponent = +_, domain(domain())) : exponent;
        };
        scale.copy = function () {
          return copy(scale, pow().exponent(exponent));
        };
        return linearish(scale);
      }
      function sqrt() {
        return pow().exponent(0.5);
      }
      function quantile$$1() {
        var domain = [],
            range$$1 = [],
            thresholds = [];
        function rescale() {
          var i = 0,
              n = Math.max(1, range$$1.length);
          thresholds = new Array(n - 1);
          while (++i < n) thresholds[i - 1] = threshold(domain, i / n);
          return scale;
        }
        function scale(x) {
          if (!isNaN(x = +x)) return range$$1[bisectRight(thresholds, x)];
        }
        scale.invertExtent = function (y) {
          var i = range$$1.indexOf(y);
          return i < 0 ? [NaN, NaN] : [i > 0 ? thresholds[i - 1] : domain[0], i < thresholds.length ? thresholds[i] : domain[domain.length - 1]];
        };
        scale.domain = function (_) {
          if (!arguments.length) return domain.slice();
          domain = [];
          for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
          domain.sort(ascending);
          return rescale();
        };
        scale.range = function (_) {
          return arguments.length ? (range$$1 = slice$3.call(_), rescale()) : range$$1.slice();
        };
        scale.quantiles = function () {
          return thresholds.slice();
        };
        scale.copy = function () {
          return quantile$$1().domain(domain).range(range$$1);
        };
        return scale;
      }
      function quantize$1() {
        var x0 = 0,
            x1 = 1,
            n = 1,
            domain = [0.5],
            range$$1 = [0, 1];
        function scale(x) {
          if (x <= x) return range$$1[bisectRight(domain, x, 0, n)];
        }
        function rescale() {
          var i = -1;
          domain = new Array(n);
          while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
          return scale;
        }
        scale.domain = function (_) {
          return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
        };
        scale.range = function (_) {
          return arguments.length ? (n = (range$$1 = slice$3.call(_)).length - 1, rescale()) : range$$1.slice();
        };
        scale.invertExtent = function (y) {
          var i = range$$1.indexOf(y);
          return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
        };
        scale.copy = function () {
          return quantize$1().domain([x0, x1]).range(range$$1);
        };
        return linearish(scale);
      }
      function threshold$1() {
        var domain = [0.5],
            range$$1 = [0, 1],
            n = 1;
        function scale(x) {
          if (x <= x) return range$$1[bisectRight(domain, x, 0, n)];
        }
        scale.domain = function (_) {
          return arguments.length ? (domain = slice$3.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : domain.slice();
        };
        scale.range = function (_) {
          return arguments.length ? (range$$1 = slice$3.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : range$$1.slice();
        };
        scale.invertExtent = function (y) {
          var i = range$$1.indexOf(y);
          return [domain[i - 1], domain[i]];
        };
        scale.copy = function () {
          return threshold$1().domain(domain).range(range$$1);
        };
        return scale;
      }
      var durationSecond$1 = 1000;
      var durationMinute$1 = durationSecond$1 * 60;
      var durationHour$1 = durationMinute$1 * 60;
      var durationDay$1 = durationHour$1 * 24;
      var durationWeek$1 = durationDay$1 * 7;
      var durationMonth = durationDay$1 * 30;
      var durationYear = durationDay$1 * 365;
      function date$1(t) {
        return new Date(t);
      }
      function number$2(t) {
        return t instanceof Date ? +t : +new Date(+t);
      }
      function calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format) {
        var scale = continuous(deinterpolateLinear, interpolateNumber),
            invert = scale.invert,
            domain = scale.domain;
        var formatMillisecond = format(".%L"),
            formatSecond = format(":%S"),
            formatMinute = format("%I:%M"),
            formatHour = format("%I %p"),
            formatDay = format("%a %d"),
            formatWeek = format("%b %d"),
            formatMonth = format("%B"),
            formatYear = format("%Y");
        var tickIntervals = [[second$$1, 1, durationSecond$1], [second$$1, 5, 5 * durationSecond$1], [second$$1, 15, 15 * durationSecond$1], [second$$1, 30, 30 * durationSecond$1], [minute$$1, 1, durationMinute$1], [minute$$1, 5, 5 * durationMinute$1], [minute$$1, 15, 15 * durationMinute$1], [minute$$1, 30, 30 * durationMinute$1], [hour$$1, 1, durationHour$1], [hour$$1, 3, 3 * durationHour$1], [hour$$1, 6, 6 * durationHour$1], [hour$$1, 12, 12 * durationHour$1], [day$$1, 1, durationDay$1], [day$$1, 2, 2 * durationDay$1], [week, 1, durationWeek$1], [month$$1, 1, durationMonth], [month$$1, 3, 3 * durationMonth], [year$$1, 1, durationYear]];
        function tickFormat(date) {
          return (second$$1(date) < date ? formatMillisecond : minute$$1(date) < date ? formatSecond : hour$$1(date) < date ? formatMinute : day$$1(date) < date ? formatHour : month$$1(date) < date ? week(date) < date ? formatDay : formatWeek : year$$1(date) < date ? formatMonth : formatYear)(date);
        }
        function tickInterval(interval, start, stop, step) {
          if (interval == null) interval = 10;
          if (typeof interval === "number") {
            var target = Math.abs(stop - start) / interval,
                i = bisector(function (i) {
              return i[2];
            }).right(tickIntervals, target);
            if (i === tickIntervals.length) {
              step = tickStep(start / durationYear, stop / durationYear, interval);
              interval = year$$1;
            } else if (i) {
              i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
              step = i[1];
              interval = i[0];
            } else {
              step = tickStep(start, stop, interval);
              interval = millisecond$$1;
            }
          }
          return step == null ? interval : interval.every(step);
        }
        scale.invert = function (y) {
          return new Date(invert(y));
        };
        scale.domain = function (_) {
          return arguments.length ? domain(map$3.call(_, number$2)) : domain().map(date$1);
        };
        scale.ticks = function (interval, step) {
          var d = domain(),
              t0 = d[0],
              t1 = d[d.length - 1],
              r = t1 < t0,
              t;
          if (r) t = t0, t0 = t1, t1 = t;
          t = tickInterval(interval, t0, t1, step);
          t = t ? t.range(t0, t1 + 1) : [];
          return r ? t.reverse() : t;
        };
        scale.tickFormat = function (count, specifier) {
          return specifier == null ? tickFormat : format(specifier);
        };
        scale.nice = function (interval, step) {
          var d = domain();
          return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain(nice(d, interval)) : scale;
        };
        scale.copy = function () {
          return copy(scale, calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format));
        };
        return scale;
      }
      var time = function () {
        return calendar(year, month, sunday, day, hour, minute, second, millisecond, exports.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
      };
      var utcTime = function () {
        return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, exports.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
      };
      var colors = function (s) {
        return s.match(/.{6}/g).map(function (x) {
          return "#" + x;
        });
      };
      var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
      var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");
      var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");
      var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");
      var cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));
      var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));
      var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));
      var rainbow = cubehelix();
      var rainbow$1 = function (t) {
        if (t < 0 || t > 1) t -= Math.floor(t);
        var ts = Math.abs(t - 0.5);
        rainbow.h = 360 * t - 100;
        rainbow.s = 1.5 - 1.5 * ts;
        rainbow.l = 0.8 - 0.9 * ts;
        return rainbow + "";
      };
      function ramp(range) {
        var n = range.length;
        return function (t) {
          return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
        };
      }
      var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
      var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
      var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
      var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
      function sequential(interpolator) {
        var x0 = 0,
            x1 = 1,
            clamp = false;
        function scale(x) {
          var t = (x - x0) / (x1 - x0);
          return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
        }
        scale.domain = function (_) {
          return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
        };
        scale.clamp = function (_) {
          return arguments.length ? (clamp = !!_, scale) : clamp;
        };
        scale.interpolator = function (_) {
          return arguments.length ? (interpolator = _, scale) : interpolator;
        };
        scale.copy = function () {
          return sequential(interpolator).domain([x0, x1]).clamp(clamp);
        };
        return linearish(scale);
      }
      var xhtml = "http://www.w3.org/1999/xhtml";
      var namespaces = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: xhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
      var namespace = function (name) {
        var prefix = name += "",
            i = prefix.indexOf(":");
        if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
        return namespaces.hasOwnProperty(prefix) ? {
          space: namespaces[prefix],
          local: name
        } : name;
      };
      function creatorInherit(name) {
        return function () {
          var document = this.ownerDocument,
              uri = this.namespaceURI;
          return uri === xhtml && document.documentElement.namespaceURI === xhtml ? document.createElement(name) : document.createElementNS(uri, name);
        };
      }
      function creatorFixed(fullname) {
        return function () {
          return this.ownerDocument.createElementNS(fullname.space, fullname.local);
        };
      }
      var creator = function (name) {
        var fullname = namespace(name);
        return (fullname.local ? creatorFixed : creatorInherit)(fullname);
      };
      var nextId = 0;
      function local() {
        return new Local();
      }
      function Local() {
        this._ = "@" + (++nextId).toString(36);
      }
      Local.prototype = local.prototype = {
        constructor: Local,
        get: function (node) {
          var id = this._;
          while (!(id in node)) if (!(node = node.parentNode)) return;
          return node[id];
        },
        set: function (node, value) {
          return node[this._] = value;
        },
        remove: function (node) {
          return this._ in node && delete node[this._];
        },
        toString: function () {
          return this._;
        }
      };
      var matcher = function (selector) {
        return function () {
          return this.matches(selector);
        };
      };
      if (typeof document !== "undefined") {
        var element = document.documentElement;
        if (!element.matches) {
          var vendorMatches = element.webkitMatchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector;
          matcher = function (selector) {
            return function () {
              return vendorMatches.call(this, selector);
            };
          };
        }
      }
      var matcher$1 = matcher;
      var filterEvents = {};
      exports.event = null;
      if (typeof document !== "undefined") {
        var element$1 = document.documentElement;
        if (!("onmouseenter" in element$1)) {
          filterEvents = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
          };
        }
      }
      function filterContextListener(listener, index, group) {
        listener = contextListener(listener, index, group);
        return function (event) {
          var related = event.relatedTarget;
          if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
            listener.call(this, event);
          }
        };
      }
      function contextListener(listener, index, group) {
        return function (event1) {
          var event0 = exports.event;
          exports.event = event1;
          try {
            listener.call(this, this.__data__, index, group);
          } finally {
            exports.event = event0;
          }
        };
      }
      function parseTypenames$1(typenames) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
          var name = "",
              i = t.indexOf(".");
          if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
          return {
            type: t,
            name: name
          };
        });
      }
      function onRemove(typename) {
        return function () {
          var on = this.__on;
          if (!on) return;
          for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
            if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
              this.removeEventListener(o.type, o.listener, o.capture);
            } else {
              on[++i] = o;
            }
          }
          if (++i) on.length = i;else delete this.__on;
        };
      }
      function onAdd(typename, value, capture) {
        var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
        return function (d, i, group) {
          var on = this.__on,
              o,
              listener = wrap(value, i, group);
          if (on) for (var j = 0, m = on.length; j < m; ++j) {
            if ((o = on[j]).type === typename.type && o.name === typename.name) {
              this.removeEventListener(o.type, o.listener, o.capture);
              this.addEventListener(o.type, o.listener = listener, o.capture = capture);
              o.value = value;
              return;
            }
          }
          this.addEventListener(typename.type, listener, capture);
          o = {
            type: typename.type,
            name: typename.name,
            value: value,
            listener: listener,
            capture: capture
          };
          if (!on) this.__on = [o];else on.push(o);
        };
      }
      var selection_on = function (typename, value, capture) {
        var typenames = parseTypenames$1(typename + ""),
            i,
            n = typenames.length,
            t;
        if (arguments.length < 2) {
          var on = this.node().__on;
          if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
            for (i = 0, o = on[j]; i < n; ++i) {
              if ((t = typenames[i]).type === o.type && t.name === o.name) {
                return o.value;
              }
            }
          }
          return;
        }
        on = value ? onAdd : onRemove;
        if (capture == null) capture = false;
        for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
        return this;
      };
      function customEvent(event1, listener, that, args) {
        var event0 = exports.event;
        event1.sourceEvent = exports.event;
        exports.event = event1;
        try {
          return listener.apply(that, args);
        } finally {
          exports.event = event0;
        }
      }
      var sourceEvent = function () {
        var current = exports.event,
            source;
        while (source = current.sourceEvent) current = source;
        return current;
      };
      var point$5 = function (node, event) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
      };
      var mouse = function (node) {
        var event = sourceEvent();
        if (event.changedTouches) event = event.changedTouches[0];
        return point$5(node, event);
      };
      function none$2() {}
      var selector = function (selector) {
        return selector == null ? none$2 : function () {
          return this.querySelector(selector);
        };
      };
      var selection_select = function (select) {
        if (typeof select !== "function") select = selector(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
            if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
              if ("__data__" in node) subnode.__data__ = node.__data__;
              subgroup[i] = subnode;
            }
          }
        }
        return new Selection(subgroups, this._parents);
      };
      function empty() {
        return [];
      }
      var selectorAll = function (selector) {
        return selector == null ? empty : function () {
          return this.querySelectorAll(selector);
        };
      };
      var selection_selectAll = function (select) {
        if (typeof select !== "function") select = selectorAll(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
              subgroups.push(select.call(node, node.__data__, i, group));
              parents.push(node);
            }
          }
        }
        return new Selection(subgroups, parents);
      };
      var selection_filter = function (match) {
        if (typeof match !== "function") match = matcher$1(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
            if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
              subgroup.push(node);
            }
          }
        }
        return new Selection(subgroups, this._parents);
      };
      var sparse = function (update) {
        return new Array(update.length);
      };
      var selection_enter = function () {
        return new Selection(this._enter || this._groups.map(sparse), this._parents);
      };
      function EnterNode(parent, datum) {
        this.ownerDocument = parent.ownerDocument;
        this.namespaceURI = parent.namespaceURI;
        this._next = null;
        this._parent = parent;
        this.__data__ = datum;
      }
      EnterNode.prototype = {
        constructor: EnterNode,
        appendChild: function (child) {
          return this._parent.insertBefore(child, this._next);
        },
        insertBefore: function (child, next) {
          return this._parent.insertBefore(child, next);
        },
        querySelector: function (selector) {
          return this._parent.querySelector(selector);
        },
        querySelectorAll: function (selector) {
          return this._parent.querySelectorAll(selector);
        }
      };
      var constant$5 = function (x) {
        return function () {
          return x;
        };
      };
      var keyPrefix = "$";
      function bindIndex(parent, group, enter, update, exit, data) {
        var i = 0,
            node,
            groupLength = group.length,
            dataLength = data.length;
        for (; i < dataLength; ++i) {
          if (node = group[i]) {
            node.__data__ = data[i];
            update[i] = node;
          } else {
            enter[i] = new EnterNode(parent, data[i]);
          }
        }
        for (; i < groupLength; ++i) {
          if (node = group[i]) {
            exit[i] = node;
          }
        }
      }
      function bindKey(parent, group, enter, update, exit, data, key) {
        var i,
            node,
            nodeByKeyValue = {},
            groupLength = group.length,
            dataLength = data.length,
            keyValues = new Array(groupLength),
            keyValue;
        for (i = 0; i < groupLength; ++i) {
          if (node = group[i]) {
            keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
            if (keyValue in nodeByKeyValue) {
              exit[i] = node;
            } else {
              nodeByKeyValue[keyValue] = node;
            }
          }
        }
        for (i = 0; i < dataLength; ++i) {
          keyValue = keyPrefix + key.call(parent, data[i], i, data);
          if (node = nodeByKeyValue[keyValue]) {
            update[i] = node;
            node.__data__ = data[i];
            nodeByKeyValue[keyValue] = null;
          } else {
            enter[i] = new EnterNode(parent, data[i]);
          }
        }
        for (i = 0; i < groupLength; ++i) {
          if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
            exit[i] = node;
          }
        }
      }
      var selection_data = function (value, key) {
        if (!value) {
          data = new Array(this.size()), j = -1;
          this.each(function (d) {
            data[++j] = d;
          });
          return data;
        }
        var bind = key ? bindKey : bindIndex,
            parents = this._parents,
            groups = this._groups;
        if (typeof value !== "function") value = constant$5(value);
        for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
          var parent = parents[j],
              group = groups[j],
              groupLength = group.length,
              data = value.call(parent, parent && parent.__data__, j, parents),
              dataLength = data.length,
              enterGroup = enter[j] = new Array(dataLength),
              updateGroup = update[j] = new Array(dataLength),
              exitGroup = exit[j] = new Array(groupLength);
          bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
          for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
            if (previous = enterGroup[i0]) {
              if (i0 >= i1) i1 = i0 + 1;
              while (!(next = updateGroup[i1]) && ++i1 < dataLength);
              previous._next = next || null;
            }
          }
        }
        update = new Selection(update, parents);
        update._enter = enter;
        update._exit = exit;
        return update;
      };
      var selection_exit = function () {
        return new Selection(this._exit || this._groups.map(sparse), this._parents);
      };
      var selection_merge = function (selection) {
        for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
          for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
            if (node = group0[i] || group1[i]) {
              merge[i] = node;
            }
          }
        }
        for (; j < m0; ++j) {
          merges[j] = groups0[j];
        }
        return new Selection(merges, this._parents);
      };
      var selection_order = function () {
        for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
          for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
            if (node = group[i]) {
              if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
              next = node;
            }
          }
        }
        return this;
      };
      var selection_sort = function (compare) {
        if (!compare) compare = ascending$2;
        function compareNode(a, b) {
          return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }
        for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
            if (node = group[i]) {
              sortgroup[i] = node;
            }
          }
          sortgroup.sort(compareNode);
        }
        return new Selection(sortgroups, this._parents).order();
      };
      function ascending$2(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      var selection_call = function () {
        var callback = arguments[0];
        arguments[0] = this;
        callback.apply(null, arguments);
        return this;
      };
      var selection_nodes = function () {
        var nodes = new Array(this.size()),
            i = -1;
        this.each(function () {
          nodes[++i] = this;
        });
        return nodes;
      };
      var selection_node = function () {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
          for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
            var node = group[i];
            if (node) return node;
          }
        }
        return null;
      };
      var selection_size = function () {
        var size = 0;
        this.each(function () {
          ++size;
        });
        return size;
      };
      var selection_empty = function () {
        return !this.node();
      };
      var selection_each = function (callback) {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
          for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
            if (node = group[i]) callback.call(node, node.__data__, i, group);
          }
        }
        return this;
      };
      function attrRemove(name) {
        return function () {
          this.removeAttribute(name);
        };
      }
      function attrRemoveNS(fullname) {
        return function () {
          this.removeAttributeNS(fullname.space, fullname.local);
        };
      }
      function attrConstant(name, value) {
        return function () {
          this.setAttribute(name, value);
        };
      }
      function attrConstantNS(fullname, value) {
        return function () {
          this.setAttributeNS(fullname.space, fullname.local, value);
        };
      }
      function attrFunction(name, value) {
        return function () {
          var v = value.apply(this, arguments);
          if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
        };
      }
      function attrFunctionNS(fullname, value) {
        return function () {
          var v = value.apply(this, arguments);
          if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
        };
      }
      var selection_attr = function (name, value) {
        var fullname = namespace(name);
        if (arguments.length < 2) {
          var node = this.node();
          return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
        }
        return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
      };
      var window = function (node) {
        return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
      };
      function styleRemove(name) {
        return function () {
          this.style.removeProperty(name);
        };
      }
      function styleConstant(name, value, priority) {
        return function () {
          this.style.setProperty(name, value, priority);
        };
      }
      function styleFunction(name, value, priority) {
        return function () {
          var v = value.apply(this, arguments);
          if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
        };
      }
      var selection_style = function (name, value, priority) {
        var node;
        return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : window(node = this.node()).getComputedStyle(node, null).getPropertyValue(name);
      };
      function propertyRemove(name) {
        return function () {
          delete this[name];
        };
      }
      function propertyConstant(name, value) {
        return function () {
          this[name] = value;
        };
      }
      function propertyFunction(name, value) {
        return function () {
          var v = value.apply(this, arguments);
          if (v == null) delete this[name];else this[name] = v;
        };
      }
      var selection_property = function (name, value) {
        return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
      };
      function classArray(string) {
        return string.trim().split(/^|\s+/);
      }
      function classList(node) {
        return node.classList || new ClassList(node);
      }
      function ClassList(node) {
        this._node = node;
        this._names = classArray(node.getAttribute("class") || "");
      }
      ClassList.prototype = {
        add: function (name) {
          var i = this._names.indexOf(name);
          if (i < 0) {
            this._names.push(name);
            this._node.setAttribute("class", this._names.join(" "));
          }
        },
        remove: function (name) {
          var i = this._names.indexOf(name);
          if (i >= 0) {
            this._names.splice(i, 1);
            this._node.setAttribute("class", this._names.join(" "));
          }
        },
        contains: function (name) {
          return this._names.indexOf(name) >= 0;
        }
      };
      function classedAdd(node, names) {
        var list = classList(node),
            i = -1,
            n = names.length;
        while (++i < n) list.add(names[i]);
      }
      function classedRemove(node, names) {
        var list = classList(node),
            i = -1,
            n = names.length;
        while (++i < n) list.remove(names[i]);
      }
      function classedTrue(names) {
        return function () {
          classedAdd(this, names);
        };
      }
      function classedFalse(names) {
        return function () {
          classedRemove(this, names);
        };
      }
      function classedFunction(names, value) {
        return function () {
          (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
        };
      }
      var selection_classed = function (name, value) {
        var names = classArray(name + "");
        if (arguments.length < 2) {
          var list = classList(this.node()),
              i = -1,
              n = names.length;
          while (++i < n) if (!list.contains(names[i])) return false;
          return true;
        }
        return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
      };
      function textRemove() {
        this.textContent = "";
      }
      function textConstant(value) {
        return function () {
          this.textContent = value;
        };
      }
      function textFunction(value) {
        return function () {
          var v = value.apply(this, arguments);
          this.textContent = v == null ? "" : v;
        };
      }
      var selection_text = function (value) {
        return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
      };
      function htmlRemove() {
        this.innerHTML = "";
      }
      function htmlConstant(value) {
        return function () {
          this.innerHTML = value;
        };
      }
      function htmlFunction(value) {
        return function () {
          var v = value.apply(this, arguments);
          this.innerHTML = v == null ? "" : v;
        };
      }
      var selection_html = function (value) {
        return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
      };
      function raise$1() {
        if (this.nextSibling) this.parentNode.appendChild(this);
      }
      var selection_raise = function () {
        return this.each(raise$1);
      };
      function lower() {
        if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
      }
      var selection_lower = function () {
        return this.each(lower);
      };
      var selection_append = function (name) {
        var create = typeof name === "function" ? name : creator(name);
        return this.select(function () {
          return this.appendChild(create.apply(this, arguments));
        });
      };
      function constantNull() {
        return null;
      }
      var selection_insert = function (name, before) {
        var create = typeof name === "function" ? name : creator(name),
            select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
        return this.select(function () {
          return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
        });
      };
      function remove() {
        var parent = this.parentNode;
        if (parent) parent.removeChild(this);
      }
      var selection_remove = function () {
        return this.each(remove);
      };
      var selection_datum = function (value) {
        return arguments.length ? this.property("__data__", value) : this.node().__data__;
      };
      function dispatchEvent(node, type, params) {
        var window$$1 = window(node),
            event = window$$1.CustomEvent;
        if (event) {
          event = new event(type, params);
        } else {
          event = window$$1.document.createEvent("Event");
          if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
        }
        node.dispatchEvent(event);
      }
      function dispatchConstant(type, params) {
        return function () {
          return dispatchEvent(this, type, params);
        };
      }
      function dispatchFunction(type, params) {
        return function () {
          return dispatchEvent(this, type, params.apply(this, arguments));
        };
      }
      var selection_dispatch = function (type, params) {
        return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
      };
      var root = [null];
      function Selection(groups, parents) {
        this._groups = groups;
        this._parents = parents;
      }
      function selection() {
        return new Selection([[document.documentElement]], root);
      }
      Selection.prototype = selection.prototype = {
        constructor: Selection,
        select: selection_select,
        selectAll: selection_selectAll,
        filter: selection_filter,
        data: selection_data,
        enter: selection_enter,
        exit: selection_exit,
        merge: selection_merge,
        order: selection_order,
        sort: selection_sort,
        call: selection_call,
        nodes: selection_nodes,
        node: selection_node,
        size: selection_size,
        empty: selection_empty,
        each: selection_each,
        attr: selection_attr,
        style: selection_style,
        property: selection_property,
        classed: selection_classed,
        text: selection_text,
        html: selection_html,
        raise: selection_raise,
        lower: selection_lower,
        append: selection_append,
        insert: selection_insert,
        remove: selection_remove,
        datum: selection_datum,
        on: selection_on,
        dispatch: selection_dispatch
      };
      var select = function (selector) {
        return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
      };
      var selectAll = function (selector) {
        return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([selector == null ? [] : selector], root);
      };
      var touch = function (node, touches, identifier) {
        if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;
        for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
          if ((touch = touches[i]).identifier === identifier) {
            return point$5(node, touch);
          }
        }
        return null;
      };
      var touches = function (node, touches) {
        if (touches == null) touches = sourceEvent().touches;
        for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
          points[i] = point$5(node, touches[i]);
        }
        return points;
      };
      var emptyOn = dispatch("start", "end", "interrupt");
      var emptyTween = [];
      var CREATED = 0;
      var SCHEDULED = 1;
      var STARTING = 2;
      var STARTED = 3;
      var RUNNING = 4;
      var ENDING = 5;
      var ENDED = 6;
      var schedule = function (node, name, id, index, group, timing) {
        var schedules = node.__transition;
        if (!schedules) node.__transition = {};else if (id in schedules) return;
        create(node, id, {
          name: name,
          index: index,
          group: group,
          on: emptyOn,
          tween: emptyTween,
          time: timing.time,
          delay: timing.delay,
          duration: timing.duration,
          ease: timing.ease,
          timer: null,
          state: CREATED
        });
      };
      function init(node, id) {
        var schedule = node.__transition;
        if (!schedule || !(schedule = schedule[id]) || schedule.state > CREATED) throw new Error("too late");
        return schedule;
      }
      function set$3(node, id) {
        var schedule = node.__transition;
        if (!schedule || !(schedule = schedule[id]) || schedule.state > STARTING) throw new Error("too late");
        return schedule;
      }
      function get$1(node, id) {
        var schedule = node.__transition;
        if (!schedule || !(schedule = schedule[id])) throw new Error("too late");
        return schedule;
      }
      function create(node, id, self) {
        var schedules = node.__transition,
            tween;
        schedules[id] = self;
        self.timer = timer(schedule, 0, self.time);
        function schedule(elapsed) {
          self.state = SCHEDULED;
          self.timer.restart(start, self.delay, self.time);
          if (self.delay <= elapsed) start(elapsed - self.delay);
        }
        function start(elapsed) {
          var i, j, n, o;
          if (self.state !== SCHEDULED) return stop();
          for (i in schedules) {
            o = schedules[i];
            if (o.name !== self.name) continue;
            if (o.state === STARTED) return timeout$1(start);
            if (o.state === RUNNING) {
              o.state = ENDED;
              o.timer.stop();
              o.on.call("interrupt", node, node.__data__, o.index, o.group);
              delete schedules[i];
            } else if (+i < id) {
              o.state = ENDED;
              o.timer.stop();
              delete schedules[i];
            }
          }
          timeout$1(function () {
            if (self.state === STARTED) {
              self.state = RUNNING;
              self.timer.restart(tick, self.delay, self.time);
              tick(elapsed);
            }
          });
          self.state = STARTING;
          self.on.call("start", node, node.__data__, self.index, self.group);
          if (self.state !== STARTING) return;
          self.state = STARTED;
          tween = new Array(n = self.tween.length);
          for (i = 0, j = -1; i < n; ++i) {
            if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
              tween[++j] = o;
            }
          }
          tween.length = j + 1;
        }
        function tick(elapsed) {
          var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
              i = -1,
              n = tween.length;
          while (++i < n) {
            tween[i].call(null, t);
          }
          if (self.state === ENDING) {
            self.on.call("end", node, node.__data__, self.index, self.group);
            stop();
          }
        }
        function stop() {
          self.state = ENDED;
          self.timer.stop();
          delete schedules[id];
          for (var i in schedules) return;
          delete node.__transition;
        }
      }
      var interrupt = function (node, name) {
        var schedules = node.__transition,
            schedule,
            active,
            empty = true,
            i;
        if (!schedules) return;
        name = name == null ? null : name + "";
        for (i in schedules) {
          if ((schedule = schedules[i]).name !== name) {
            empty = false;
            continue;
          }
          active = schedule.state > STARTING && schedule.state < ENDING;
          schedule.state = ENDED;
          schedule.timer.stop();
          if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
          delete schedules[i];
        }
        if (empty) delete node.__transition;
      };
      var selection_interrupt = function (name) {
        return this.each(function () {
          interrupt(this, name);
        });
      };
      function tweenRemove(id, name) {
        var tween0, tween1;
        return function () {
          var schedule = set$3(this, id),
              tween = schedule.tween;
          if (tween !== tween0) {
            tween1 = tween0 = tween;
            for (var i = 0, n = tween1.length; i < n; ++i) {
              if (tween1[i].name === name) {
                tween1 = tween1.slice();
                tween1.splice(i, 1);
                break;
              }
            }
          }
          schedule.tween = tween1;
        };
      }
      function tweenFunction(id, name, value) {
        var tween0, tween1;
        if (typeof value !== "function") throw new Error();
        return function () {
          var schedule = set$3(this, id),
              tween = schedule.tween;
          if (tween !== tween0) {
            tween1 = (tween0 = tween).slice();
            for (var t = {
              name: name,
              value: value
            }, i = 0, n = tween1.length; i < n; ++i) {
              if (tween1[i].name === name) {
                tween1[i] = t;
                break;
              }
            }
            if (i === n) tween1.push(t);
          }
          schedule.tween = tween1;
        };
      }
      var transition_tween = function (name, value) {
        var id = this._id;
        name += "";
        if (arguments.length < 2) {
          var tween = get$1(this.node(), id).tween;
          for (var i = 0, n = tween.length, t; i < n; ++i) {
            if ((t = tween[i]).name === name) {
              return t.value;
            }
          }
          return null;
        }
        return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
      };
      function tweenValue(transition, name, value) {
        var id = transition._id;
        transition.each(function () {
          var schedule = set$3(this, id);
          (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
        });
        return function (node) {
          return get$1(node, id).value[name];
        };
      }
      var interpolate$1 = function (a, b) {
        var c;
        return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
      };
      function attrRemove$1(name) {
        return function () {
          this.removeAttribute(name);
        };
      }
      function attrRemoveNS$1(fullname) {
        return function () {
          this.removeAttributeNS(fullname.space, fullname.local);
        };
      }
      function attrConstant$1(name, interpolate$$1, value1) {
        var value00, interpolate0;
        return function () {
          var value0 = this.getAttribute(name);
          return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value1);
        };
      }
      function attrConstantNS$1(fullname, interpolate$$1, value1) {
        var value00, interpolate0;
        return function () {
          var value0 = this.getAttributeNS(fullname.space, fullname.local);
          return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value1);
        };
      }
      function attrFunction$1(name, interpolate$$1, value) {
        var value00, value10, interpolate0;
        return function () {
          var value0,
              value1 = value(this);
          if (value1 == null) return void this.removeAttribute(name);
          value0 = this.getAttribute(name);
          return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
        };
      }
      function attrFunctionNS$1(fullname, interpolate$$1, value) {
        var value00, value10, interpolate0;
        return function () {
          var value0,
              value1 = value(this);
          if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
          value0 = this.getAttributeNS(fullname.space, fullname.local);
          return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
        };
      }
      var transition_attr = function (name, value) {
        var fullname = namespace(name),
            i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
        return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname) : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
      };
      function attrTweenNS(fullname, value) {
        function tween() {
          var node = this,
              i = value.apply(node, arguments);
          return i && function (t) {
            node.setAttributeNS(fullname.space, fullname.local, i(t));
          };
        }
        tween._value = value;
        return tween;
      }
      function attrTween(name, value) {
        function tween() {
          var node = this,
              i = value.apply(node, arguments);
          return i && function (t) {
            node.setAttribute(name, i(t));
          };
        }
        tween._value = value;
        return tween;
      }
      var transition_attrTween = function (name, value) {
        var key = "attr." + name;
        if (arguments.length < 2) return (key = this.tween(key)) && key._value;
        if (value == null) return this.tween(key, null);
        if (typeof value !== "function") throw new Error();
        var fullname = namespace(name);
        return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
      };
      function delayFunction(id, value) {
        return function () {
          init(this, id).delay = +value.apply(this, arguments);
        };
      }
      function delayConstant(id, value) {
        return value = +value, function () {
          init(this, id).delay = value;
        };
      }
      var transition_delay = function (value) {
        var id = this._id;
        return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : get$1(this.node(), id).delay;
      };
      function durationFunction(id, value) {
        return function () {
          set$3(this, id).duration = +value.apply(this, arguments);
        };
      }
      function durationConstant(id, value) {
        return value = +value, function () {
          set$3(this, id).duration = value;
        };
      }
      var transition_duration = function (value) {
        var id = this._id;
        return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : get$1(this.node(), id).duration;
      };
      function easeConstant(id, value) {
        if (typeof value !== "function") throw new Error();
        return function () {
          set$3(this, id).ease = value;
        };
      }
      var transition_ease = function (value) {
        var id = this._id;
        return arguments.length ? this.each(easeConstant(id, value)) : get$1(this.node(), id).ease;
      };
      var transition_filter = function (match) {
        if (typeof match !== "function") match = matcher$1(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
            if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
              subgroup.push(node);
            }
          }
        }
        return new Transition(subgroups, this._parents, this._name, this._id);
      };
      var transition_merge = function (transition) {
        if (transition._id !== this._id) throw new Error();
        for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
          for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
            if (node = group0[i] || group1[i]) {
              merge[i] = node;
            }
          }
        }
        for (; j < m0; ++j) {
          merges[j] = groups0[j];
        }
        return new Transition(merges, this._parents, this._name, this._id);
      };
      function start$1(name) {
        return (name + "").trim().split(/^|\s+/).every(function (t) {
          var i = t.indexOf(".");
          if (i >= 0) t = t.slice(0, i);
          return !t || t === "start";
        });
      }
      function onFunction(id, name, listener) {
        var on0,
            on1,
            sit = start$1(name) ? init : set$3;
        return function () {
          var schedule = sit(this, id),
              on = schedule.on;
          if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
          schedule.on = on1;
        };
      }
      var transition_on = function (name, listener) {
        var id = this._id;
        return arguments.length < 2 ? get$1(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
      };
      function removeFunction(id) {
        return function () {
          var parent = this.parentNode;
          for (var i in this.__transition) if (+i !== id) return;
          if (parent) parent.removeChild(this);
        };
      }
      var transition_remove = function () {
        return this.on("end.remove", removeFunction(this._id));
      };
      var transition_select = function (select$$1) {
        var name = this._name,
            id = this._id;
        if (typeof select$$1 !== "function") select$$1 = selector(select$$1);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
            if ((node = group[i]) && (subnode = select$$1.call(node, node.__data__, i, group))) {
              if ("__data__" in node) subnode.__data__ = node.__data__;
              subgroup[i] = subnode;
              schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
            }
          }
        }
        return new Transition(subgroups, this._parents, name, id);
      };
      var transition_selectAll = function (select$$1) {
        var name = this._name,
            id = this._id;
        if (typeof select$$1 !== "function") select$$1 = selectorAll(select$$1);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
              for (var children = select$$1.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
                if (child = children[k]) {
                  schedule(child, name, id, k, children, inherit);
                }
              }
              subgroups.push(children);
              parents.push(node);
            }
          }
        }
        return new Transition(subgroups, parents, name, id);
      };
      var Selection$1 = selection.prototype.constructor;
      var transition_selection = function () {
        return new Selection$1(this._groups, this._parents);
      };
      function styleRemove$1(name, interpolate$$1) {
        var value00, value10, interpolate0;
        return function () {
          var style = window(this).getComputedStyle(this, null),
              value0 = style.getPropertyValue(name),
              value1 = (this.style.removeProperty(name), style.getPropertyValue(name));
          return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
        };
      }
      function styleRemoveEnd(name) {
        return function () {
          this.style.removeProperty(name);
        };
      }
      function styleConstant$1(name, interpolate$$1, value1) {
        var value00, interpolate0;
        return function () {
          var value0 = window(this).getComputedStyle(this, null).getPropertyValue(name);
          return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value1);
        };
      }
      function styleFunction$1(name, interpolate$$1, value) {
        var value00, value10, interpolate0;
        return function () {
          var style = window(this).getComputedStyle(this, null),
              value0 = style.getPropertyValue(name),
              value1 = value(this);
          if (value1 == null) value1 = (this.style.removeProperty(name), style.getPropertyValue(name));
          return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
        };
      }
      var transition_style = function (name, value, priority) {
        var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
        return value == null ? this.styleTween(name, styleRemove$1(name, i)).on("end.style." + name, styleRemoveEnd(name)) : this.styleTween(name, typeof value === "function" ? styleFunction$1(name, i, tweenValue(this, "style." + name, value)) : styleConstant$1(name, i, value), priority);
      };
      function styleTween(name, value, priority) {
        function tween() {
          var node = this,
              i = value.apply(node, arguments);
          return i && function (t) {
            node.style.setProperty(name, i(t), priority);
          };
        }
        tween._value = value;
        return tween;
      }
      var transition_styleTween = function (name, value, priority) {
        var key = "style." + (name += "");
        if (arguments.length < 2) return (key = this.tween(key)) && key._value;
        if (value == null) return this.tween(key, null);
        if (typeof value !== "function") throw new Error();
        return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
      };
      function textConstant$1(value) {
        return function () {
          this.textContent = value;
        };
      }
      function textFunction$1(value) {
        return function () {
          var value1 = value(this);
          this.textContent = value1 == null ? "" : value1;
        };
      }
      var transition_text = function (value) {
        return this.tween("text", typeof value === "function" ? textFunction$1(tweenValue(this, "text", value)) : textConstant$1(value == null ? "" : value + ""));
      };
      var transition_transition = function () {
        var name = this._name,
            id0 = this._id,
            id1 = newId();
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
              var inherit = get$1(node, id0);
              schedule(node, name, id1, i, group, {
                time: inherit.time + inherit.delay + inherit.duration,
                delay: 0,
                duration: inherit.duration,
                ease: inherit.ease
              });
            }
          }
        }
        return new Transition(groups, this._parents, name, id1);
      };
      var id = 0;
      function Transition(groups, parents, name, id) {
        this._groups = groups;
        this._parents = parents;
        this._name = name;
        this._id = id;
      }
      function transition(name) {
        return selection().transition(name);
      }
      function newId() {
        return ++id;
      }
      var selection_prototype = selection.prototype;
      Transition.prototype = transition.prototype = {
        constructor: Transition,
        select: transition_select,
        selectAll: transition_selectAll,
        filter: transition_filter,
        merge: transition_merge,
        selection: transition_selection,
        transition: transition_transition,
        call: selection_prototype.call,
        nodes: selection_prototype.nodes,
        node: selection_prototype.node,
        size: selection_prototype.size,
        empty: selection_prototype.empty,
        each: selection_prototype.each,
        on: transition_on,
        attr: transition_attr,
        attrTween: transition_attrTween,
        style: transition_style,
        styleTween: transition_styleTween,
        text: transition_text,
        remove: transition_remove,
        tween: transition_tween,
        delay: transition_delay,
        duration: transition_duration,
        ease: transition_ease
      };
      var defaultTiming = {
        time: null,
        delay: 0,
        duration: 250,
        ease: cubicInOut
      };
      function inherit(node, id) {
        var timing;
        while (!(timing = node.__transition) || !(timing = timing[id])) {
          if (!(node = node.parentNode)) {
            return defaultTiming.time = now(), defaultTiming;
          }
        }
        return timing;
      }
      var selection_transition = function (name) {
        var id, timing;
        if (name instanceof Transition) {
          id = name._id, name = name._name;
        } else {
          id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
        }
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
          for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
              schedule(node, name, id, i, group, timing || inherit(node, id));
            }
          }
        }
        return new Transition(groups, this._parents, name, id);
      };
      selection.prototype.interrupt = selection_interrupt;
      selection.prototype.transition = selection_transition;
      var root$1 = [null];
      var active = function (node, name) {
        var schedules = node.__transition,
            schedule,
            i;
        if (schedules) {
          name = name == null ? null : name + "";
          for (i in schedules) {
            if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
              return new Transition([[node]], root$1, name, +i);
            }
          }
        }
        return null;
      };
      var slice$4 = Array.prototype.slice;
      var identity$5 = function (x) {
        return x;
      };
      var top = 1;
      var right = 2;
      var bottom = 3;
      var left = 4;
      var epsilon$2 = 1e-6;
      function translateX(scale0, scale1, d) {
        var x = scale0(d);
        return "translate(" + (isFinite(x) ? x : scale1(d)) + ",0)";
      }
      function translateY(scale0, scale1, d) {
        var y = scale0(d);
        return "translate(0," + (isFinite(y) ? y : scale1(d)) + ")";
      }
      function center(scale) {
        var offset = scale.bandwidth() / 2;
        if (scale.round()) offset = Math.round(offset);
        return function (d) {
          return scale(d) + offset;
        };
      }
      function entering() {
        return !this.__axis;
      }
      function axis(orient, scale) {
        var tickArguments = [],
            tickValues = null,
            tickFormat = null,
            tickSizeInner = 6,
            tickSizeOuter = 6,
            tickPadding = 3;
        function axis(context) {
          var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues,
              format = tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$5 : tickFormat,
              spacing = Math.max(tickSizeInner, 0) + tickPadding,
              transform = orient === top || orient === bottom ? translateX : translateY,
              range = scale.range(),
              range0 = range[0] + 0.5,
              range1 = range[range.length - 1] + 0.5,
              position = (scale.bandwidth ? center : identity$5)(scale.copy()),
              selection = context.selection ? context.selection() : context,
              path = selection.selectAll(".domain").data([null]),
              tick = selection.selectAll(".tick").data(values, scale).order(),
              tickExit = tick.exit(),
              tickEnter = tick.enter().append("g").attr("class", "tick"),
              line = tick.select("line"),
              text = tick.select("text"),
              k = orient === top || orient === left ? -1 : 1,
              x,
              y = orient === left || orient === right ? (x = "x", "y") : (x = "y", "x");
          path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "#000"));
          tick = tick.merge(tickEnter);
          line = line.merge(tickEnter.append("line").attr("stroke", "#000").attr(x + "2", k * tickSizeInner).attr(y + "1", 0.5).attr(y + "2", 0.5));
          text = text.merge(tickEnter.append("text").attr("fill", "#000").attr(x, k * spacing).attr(y, 0.5).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
          if (context !== selection) {
            path = path.transition(context);
            tick = tick.transition(context);
            line = line.transition(context);
            text = text.transition(context);
            tickExit = tickExit.transition(context).attr("opacity", epsilon$2).attr("transform", function (d) {
              return transform(position, this.parentNode.__axis || position, d);
            });
            tickEnter.attr("opacity", epsilon$2).attr("transform", function (d) {
              return transform(this.parentNode.__axis || position, position, d);
            });
          }
          tickExit.remove();
          path.attr("d", orient === left || orient == right ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);
          tick.attr("opacity", 1).attr("transform", function (d) {
            return transform(position, position, d);
          });
          line.attr(x + "2", k * tickSizeInner);
          text.attr(x, k * spacing).text(format);
          selection.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
          selection.each(function () {
            this.__axis = position;
          });
        }
        axis.scale = function (_) {
          return arguments.length ? (scale = _, axis) : scale;
        };
        axis.ticks = function () {
          return tickArguments = slice$4.call(arguments), axis;
        };
        axis.tickArguments = function (_) {
          return arguments.length ? (tickArguments = _ == null ? [] : slice$4.call(_), axis) : tickArguments.slice();
        };
        axis.tickValues = function (_) {
          return arguments.length ? (tickValues = _ == null ? null : slice$4.call(_), axis) : tickValues && tickValues.slice();
        };
        axis.tickFormat = function (_) {
          return arguments.length ? (tickFormat = _, axis) : tickFormat;
        };
        axis.tickSize = function (_) {
          return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
        };
        axis.tickSizeInner = function (_) {
          return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
        };
        axis.tickSizeOuter = function (_) {
          return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
        };
        axis.tickPadding = function (_) {
          return arguments.length ? (tickPadding = +_, axis) : tickPadding;
        };
        return axis;
      }
      function axisTop(scale) {
        return axis(top, scale);
      }
      function axisRight(scale) {
        return axis(right, scale);
      }
      function axisBottom(scale) {
        return axis(bottom, scale);
      }
      function axisLeft(scale) {
        return axis(left, scale);
      }
      function defaultSeparation(a, b) {
        return a.parent === b.parent ? 1 : 2;
      }
      function meanX(children) {
        return children.reduce(meanXReduce, 0) / children.length;
      }
      function meanXReduce(x, c) {
        return x + c.x;
      }
      function maxY(children) {
        return 1 + children.reduce(maxYReduce, 0);
      }
      function maxYReduce(y, c) {
        return Math.max(y, c.y);
      }
      function leafLeft(node) {
        var children;
        while (children = node.children) node = children[0];
        return node;
      }
      function leafRight(node) {
        var children;
        while (children = node.children) node = children[children.length - 1];
        return node;
      }
      var cluster = function () {
        var separation = defaultSeparation,
            dx = 1,
            dy = 1,
            nodeSize = false;
        function cluster(root) {
          var previousNode,
              x = 0;
          root.eachAfter(function (node) {
            var children = node.children;
            if (children) {
              node.x = meanX(children);
              node.y = maxY(children);
            } else {
              node.x = previousNode ? x += separation(node, previousNode) : 0;
              node.y = 0;
              previousNode = node;
            }
          });
          var left = leafLeft(root),
              right = leafRight(root),
              x0 = left.x - separation(left, right) / 2,
              x1 = right.x + separation(right, left) / 2;
          return root.eachAfter(nodeSize ? function (node) {
            node.x = (node.x - root.x) * dx;
            node.y = (root.y - node.y) * dy;
          } : function (node) {
            node.x = (node.x - x0) / (x1 - x0) * dx;
            node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
          });
        }
        cluster.separation = function (x) {
          return arguments.length ? (separation = x, cluster) : separation;
        };
        cluster.size = function (x) {
          return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy];
        };
        cluster.nodeSize = function (x) {
          return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null;
        };
        return cluster;
      };
      var node_each = function (callback) {
        var node = this,
            current,
            next = [node],
            children,
            i,
            n;
        do {
          current = next.reverse(), next = [];
          while (node = current.pop()) {
            callback(node), children = node.children;
            if (children) for (i = 0, n = children.length; i < n; ++i) {
              next.push(children[i]);
            }
          }
        } while (next.length);
        return this;
      };
      var node_eachBefore = function (callback) {
        var node = this,
            nodes = [node],
            children,
            i;
        while (node = nodes.pop()) {
          callback(node), children = node.children;
          if (children) for (i = children.length - 1; i >= 0; --i) {
            nodes.push(children[i]);
          }
        }
        return this;
      };
      var node_eachAfter = function (callback) {
        var node = this,
            nodes = [node],
            next = [],
            children,
            i,
            n;
        while (node = nodes.pop()) {
          next.push(node), children = node.children;
          if (children) for (i = 0, n = children.length; i < n; ++i) {
            nodes.push(children[i]);
          }
        }
        while (node = next.pop()) {
          callback(node);
        }
        return this;
      };
      var node_sum = function (value) {
        return this.eachAfter(function (node) {
          var sum = +value(node.data) || 0,
              children = node.children,
              i = children && children.length;
          while (--i >= 0) sum += children[i].value;
          node.value = sum;
        });
      };
      var node_sort = function (compare) {
        return this.eachBefore(function (node) {
          if (node.children) {
            node.children.sort(compare);
          }
        });
      };
      var node_path = function (end) {
        var start = this,
            ancestor = leastCommonAncestor(start, end),
            nodes = [start];
        while (start !== ancestor) {
          start = start.parent;
          nodes.push(start);
        }
        var k = nodes.length;
        while (end !== ancestor) {
          nodes.splice(k, 0, end);
          end = end.parent;
        }
        return nodes;
      };
      function leastCommonAncestor(a, b) {
        if (a === b) return a;
        var aNodes = a.ancestors(),
            bNodes = b.ancestors(),
            c = null;
        a = aNodes.pop();
        b = bNodes.pop();
        while (a === b) {
          c = a;
          a = aNodes.pop();
          b = bNodes.pop();
        }
        return c;
      }
      var node_ancestors = function () {
        var node = this,
            nodes = [node];
        while (node = node.parent) {
          nodes.push(node);
        }
        return nodes;
      };
      var node_descendants = function () {
        var nodes = [];
        this.each(function (node) {
          nodes.push(node);
        });
        return nodes;
      };
      var node_leaves = function () {
        var leaves = [];
        this.eachBefore(function (node) {
          if (!node.children) {
            leaves.push(node);
          }
        });
        return leaves;
      };
      var node_links = function () {
        var root = this,
            links = [];
        root.each(function (node) {
          if (node !== root) {
            links.push({
              source: node.parent,
              target: node
            });
          }
        });
        return links;
      };
      function hierarchy(data, children) {
        var root = new Node(data),
            valued = +data.value && (root.value = data.value),
            node,
            nodes = [root],
            child,
            childs,
            i,
            n;
        if (children == null) children = defaultChildren;
        while (node = nodes.pop()) {
          if (valued) node.value = +node.data.value;
          if ((childs = children(node.data)) && (n = childs.length)) {
            node.children = new Array(n);
            for (i = n - 1; i >= 0; --i) {
              nodes.push(child = node.children[i] = new Node(childs[i]));
              child.parent = node;
              child.depth = node.depth + 1;
            }
          }
        }
        return root.eachBefore(computeHeight);
      }
      function node_copy() {
        return hierarchy(this).eachBefore(copyData);
      }
      function defaultChildren(d) {
        return d.children;
      }
      function copyData(node) {
        node.data = node.data.data;
      }
      function computeHeight(node) {
        var height = 0;
        do node.height = height; while ((node = node.parent) && node.height < ++height);
      }
      function Node(data) {
        this.data = data;
        this.depth = this.height = 0;
        this.parent = null;
      }
      Node.prototype = hierarchy.prototype = {
        constructor: Node,
        each: node_each,
        eachAfter: node_eachAfter,
        eachBefore: node_eachBefore,
        sum: node_sum,
        sort: node_sort,
        path: node_path,
        ancestors: node_ancestors,
        descendants: node_descendants,
        leaves: node_leaves,
        links: node_links,
        copy: node_copy
      };
      function Node$2(value) {
        this._ = value;
        this.next = null;
      }
      var shuffle$1 = function (array) {
        var i,
            n = (array = array.slice()).length,
            head = null,
            node = head;
        while (n) {
          var next = new Node$2(array[n - 1]);
          if (node) node = node.next = next;else node = head = next;
          array[i] = array[--n];
        }
        return {
          head: head,
          tail: node
        };
      };
      var enclose = function (circles) {
        return encloseN(shuffle$1(circles), []);
      };
      function encloses(a, b) {
        var dx = b.x - a.x,
            dy = b.y - a.y,
            dr = a.r - b.r;
        return dr * dr + 1e-6 > dx * dx + dy * dy;
      }
      function encloseN(L, B) {
        var circle,
            l0 = null,
            l1 = L.head,
            l2,
            p1;
        switch (B.length) {
          case 1:
            circle = enclose1(B[0]);
            break;
          case 2:
            circle = enclose2(B[0], B[1]);
            break;
          case 3:
            circle = enclose3(B[0], B[1], B[2]);
            break;
        }
        while (l1) {
          p1 = l1._, l2 = l1.next;
          if (!circle || !encloses(circle, p1)) {
            if (l0) L.tail = l0, l0.next = null;else L.head = L.tail = null;
            B.push(p1);
            circle = encloseN(L, B);
            B.pop();
            if (L.head) l1.next = L.head, L.head = l1;else l1.next = null, L.head = L.tail = l1;
            l0 = L.tail, l0.next = l2;
          } else {
            l0 = l1;
          }
          l1 = l2;
        }
        L.tail = l0;
        return circle;
      }
      function enclose1(a) {
        return {
          x: a.x,
          y: a.y,
          r: a.r
        };
      }
      function enclose2(a, b) {
        var x1 = a.x,
            y1 = a.y,
            r1 = a.r,
            x2 = b.x,
            y2 = b.y,
            r2 = b.r,
            x21 = x2 - x1,
            y21 = y2 - y1,
            r21 = r2 - r1,
            l = Math.sqrt(x21 * x21 + y21 * y21);
        return {
          x: (x1 + x2 + x21 / l * r21) / 2,
          y: (y1 + y2 + y21 / l * r21) / 2,
          r: (l + r1 + r2) / 2
        };
      }
      function enclose3(a, b, c) {
        var x1 = a.x,
            y1 = a.y,
            r1 = a.r,
            x2 = b.x,
            y2 = b.y,
            r2 = b.r,
            x3 = c.x,
            y3 = c.y,
            r3 = c.r,
            a2 = 2 * (x1 - x2),
            b2 = 2 * (y1 - y2),
            c2 = 2 * (r2 - r1),
            d2 = x1 * x1 + y1 * y1 - r1 * r1 - x2 * x2 - y2 * y2 + r2 * r2,
            a3 = 2 * (x1 - x3),
            b3 = 2 * (y1 - y3),
            c3 = 2 * (r3 - r1),
            d3 = x1 * x1 + y1 * y1 - r1 * r1 - x3 * x3 - y3 * y3 + r3 * r3,
            ab = a3 * b2 - a2 * b3,
            xa = (b2 * d3 - b3 * d2) / ab - x1,
            xb = (b3 * c2 - b2 * c3) / ab,
            ya = (a3 * d2 - a2 * d3) / ab - y1,
            yb = (a2 * c3 - a3 * c2) / ab,
            A = xb * xb + yb * yb - 1,
            B = 2 * (xa * xb + ya * yb + r1),
            C = xa * xa + ya * ya - r1 * r1,
            r = (-B - Math.sqrt(B * B - 4 * A * C)) / (2 * A);
        return {
          x: xa + xb * r + x1,
          y: ya + yb * r + y1,
          r: r
        };
      }
      function place(a, b, c) {
        var ax = a.x,
            ay = a.y,
            da = b.r + c.r,
            db = a.r + c.r,
            dx = b.x - ax,
            dy = b.y - ay,
            dc = dx * dx + dy * dy;
        if (dc) {
          var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
              y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
          c.x = ax + x * dx + y * dy;
          c.y = ay + x * dy - y * dx;
        } else {
          c.x = ax + db;
          c.y = ay;
        }
      }
      function intersects(a, b) {
        var dx = b.x - a.x,
            dy = b.y - a.y,
            dr = a.r + b.r;
        return dr * dr > dx * dx + dy * dy;
      }
      function distance2(circle, x, y) {
        var dx = circle.x - x,
            dy = circle.y - y;
        return dx * dx + dy * dy;
      }
      function Node$1(circle) {
        this._ = circle;
        this.next = null;
        this.previous = null;
      }
      function packEnclose(circles) {
        if (!(n = circles.length)) return 0;
        var a, b, c, n;
        a = circles[0], a.x = 0, a.y = 0;
        if (!(n > 1)) return a.r;
        b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
        if (!(n > 2)) return a.r + b.r;
        place(b, a, c = circles[2]);
        var aa = a.r * a.r,
            ba = b.r * b.r,
            ca = c.r * c.r,
            oa = aa + ba + ca,
            ox = aa * a.x + ba * b.x + ca * c.x,
            oy = aa * a.y + ba * b.y + ca * c.y,
            cx,
            cy,
            i,
            j,
            k,
            sj,
            sk;
        a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
        a.next = c.previous = b;
        b.next = a.previous = c;
        c.next = b.previous = a;
        pack: for (i = 3; i < n; ++i) {
          place(a._, b._, c = circles[i]), c = new Node$1(c);
          if ((k = a.previous) === (j = b.next)) {
            if (intersects(j._, c._)) {
              a = b, b = j, --i;
              continue pack;
            }
          } else {
            sj = j._.r, sk = k._.r;
            do {
              if (sj <= sk) {
                if (intersects(j._, c._)) {
                  b = j, a.next = b, b.previous = a, --i;
                  continue pack;
                }
                j = j.next, sj += j._.r;
              } else {
                if (intersects(k._, c._)) {
                  a = k, a.next = b, b.previous = a, --i;
                  continue pack;
                }
                k = k.previous, sk += k._.r;
              }
            } while (j !== k.next);
          }
          c.previous = a, c.next = b, a.next = b.previous = b = c;
          oa += ca = c._.r * c._.r;
          ox += ca * c._.x;
          oy += ca * c._.y;
          aa = distance2(a._, cx = ox / oa, cy = oy / oa);
          while ((c = c.next) !== b) {
            if ((ca = distance2(c._, cx, cy)) < aa) {
              a = c, aa = ca;
            }
          }
          b = a.next;
        }
        a = [b._], c = b;
        while ((c = c.next) !== b) a.push(c._);
        c = enclose(a);
        for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;
        return c.r;
      }
      var siblings = function (circles) {
        packEnclose(circles);
        return circles;
      };
      function optional(f) {
        return f == null ? null : required(f);
      }
      function required(f) {
        if (typeof f !== "function") throw new Error();
        return f;
      }
      function constantZero() {
        return 0;
      }
      var constant$6 = function (x) {
        return function () {
          return x;
        };
      };
      function defaultRadius(d) {
        return Math.sqrt(d.value);
      }
      var index = function () {
        var radius = null,
            dx = 1,
            dy = 1,
            padding = constantZero;
        function pack(root) {
          root.x = dx / 2, root.y = dy / 2;
          if (radius) {
            root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
          } else {
            root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
          }
          return root;
        }
        pack.radius = function (x) {
          return arguments.length ? (radius = optional(x), pack) : radius;
        };
        pack.size = function (x) {
          return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
        };
        pack.padding = function (x) {
          return arguments.length ? (padding = typeof x === "function" ? x : constant$6(+x), pack) : padding;
        };
        return pack;
      };
      function radiusLeaf(radius) {
        return function (node) {
          if (!node.children) {
            node.r = Math.max(0, +radius(node) || 0);
          }
        };
      }
      function packChildren(padding, k) {
        return function (node) {
          if (children = node.children) {
            var children,
                i,
                n = children.length,
                r = padding(node) * k || 0,
                e;
            if (r) for (i = 0; i < n; ++i) children[i].r += r;
            e = packEnclose(children);
            if (r) for (i = 0; i < n; ++i) children[i].r -= r;
            node.r = e + r;
          }
        };
      }
      function translateChild(k) {
        return function (node) {
          var parent = node.parent;
          node.r *= k;
          if (parent) {
            node.x = parent.x + k * node.x;
            node.y = parent.y + k * node.y;
          }
        };
      }
      var roundNode = function (node) {
        node.x0 = Math.round(node.x0);
        node.y0 = Math.round(node.y0);
        node.x1 = Math.round(node.x1);
        node.y1 = Math.round(node.y1);
      };
      var treemapDice = function (parent, x0, y0, x1, y1) {
        var nodes = parent.children,
            node,
            i = -1,
            n = nodes.length,
            k = parent.value && (x1 - x0) / parent.value;
        while (++i < n) {
          node = nodes[i], node.y0 = y0, node.y1 = y1;
          node.x0 = x0, node.x1 = x0 += node.value * k;
        }
      };
      var partition = function () {
        var dx = 1,
            dy = 1,
            padding = 0,
            round = false;
        function partition(root) {
          var n = root.height + 1;
          root.x0 = root.y0 = padding;
          root.x1 = dx;
          root.y1 = dy / n;
          root.eachBefore(positionNode(dy, n));
          if (round) root.eachBefore(roundNode);
          return root;
        }
        function positionNode(dy, n) {
          return function (node) {
            if (node.children) {
              treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
            }
            var x0 = node.x0,
                y0 = node.y0,
                x1 = node.x1 - padding,
                y1 = node.y1 - padding;
            if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
            if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
            node.x0 = x0;
            node.y0 = y0;
            node.x1 = x1;
            node.y1 = y1;
          };
        }
        partition.round = function (x) {
          return arguments.length ? (round = !!x, partition) : round;
        };
        partition.size = function (x) {
          return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
        };
        partition.padding = function (x) {
          return arguments.length ? (padding = +x, partition) : padding;
        };
        return partition;
      };
      var keyPrefix$1 = "$";
      var preroot = { depth: -1 };
      var ambiguous = {};
      function defaultId(d) {
        return d.id;
      }
      function defaultParentId(d) {
        return d.parentId;
      }
      var stratify = function () {
        var id = defaultId,
            parentId = defaultParentId;
        function stratify(data) {
          var d,
              i,
              n = data.length,
              root,
              parent,
              node,
              nodes = new Array(n),
              nodeId,
              nodeKey,
              nodeByKey = {};
          for (i = 0; i < n; ++i) {
            d = data[i], node = nodes[i] = new Node(d);
            if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
              nodeKey = keyPrefix$1 + (node.id = nodeId);
              nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
            }
          }
          for (i = 0; i < n; ++i) {
            node = nodes[i], nodeId = parentId(data[i], i, data);
            if (nodeId == null || !(nodeId += "")) {
              if (root) throw new Error("multiple roots");
              root = node;
            } else {
              parent = nodeByKey[keyPrefix$1 + nodeId];
              if (!parent) throw new Error("missing: " + nodeId);
              if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
              if (parent.children) parent.children.push(node);else parent.children = [node];
              node.parent = parent;
            }
          }
          if (!root) throw new Error("no root");
          root.parent = preroot;
          root.eachBefore(function (node) {
            node.depth = node.parent.depth + 1;
            --n;
          }).eachBefore(computeHeight);
          root.parent = null;
          if (n > 0) throw new Error("cycle");
          return root;
        }
        stratify.id = function (x) {
          return arguments.length ? (id = required(x), stratify) : id;
        };
        stratify.parentId = function (x) {
          return arguments.length ? (parentId = required(x), stratify) : parentId;
        };
        return stratify;
      };
      function defaultSeparation$1(a, b) {
        return a.parent === b.parent ? 1 : 2;
      }
      function nextLeft(v) {
        var children = v.children;
        return children ? children[0] : v.t;
      }
      function nextRight(v) {
        var children = v.children;
        return children ? children[children.length - 1] : v.t;
      }
      function moveSubtree(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
      }
      function executeShifts(v) {
        var shift = 0,
            change = 0,
            children = v.children,
            i = children.length,
            w;
        while (--i >= 0) {
          w = children[i];
          w.z += shift;
          w.m += shift;
          shift += w.s + (change += w.c);
        }
      }
      function nextAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
      }
      function TreeNode(node, i) {
        this._ = node;
        this.parent = null;
        this.children = null;
        this.A = null;
        this.a = this;
        this.z = 0;
        this.m = 0;
        this.c = 0;
        this.s = 0;
        this.t = null;
        this.i = i;
      }
      TreeNode.prototype = Object.create(Node.prototype);
      function treeRoot(root) {
        var tree = new TreeNode(root, 0),
            node,
            nodes = [tree],
            child,
            children,
            i,
            n;
        while (node = nodes.pop()) {
          if (children = node._.children) {
            node.children = new Array(n = children.length);
            for (i = n - 1; i >= 0; --i) {
              nodes.push(child = node.children[i] = new TreeNode(children[i], i));
              child.parent = node;
            }
          }
        }
        (tree.parent = new TreeNode(null, 0)).children = [tree];
        return tree;
      }
      var tree = function () {
        var separation = defaultSeparation$1,
            dx = 1,
            dy = 1,
            nodeSize = null;
        function tree(root) {
          var t = treeRoot(root);
          t.eachAfter(firstWalk), t.parent.m = -t.z;
          t.eachBefore(secondWalk);
          if (nodeSize) root.eachBefore(sizeNode);else {
            var left = root,
                right = root,
                bottom = root;
            root.eachBefore(function (node) {
              if (node.x < left.x) left = node;
              if (node.x > right.x) right = node;
              if (node.depth > bottom.depth) bottom = node;
            });
            var s = left === right ? 1 : separation(left, right) / 2,
                tx = s - left.x,
                kx = dx / (right.x + s + tx),
                ky = dy / (bottom.depth || 1);
            root.eachBefore(function (node) {
              node.x = (node.x + tx) * kx;
              node.y = node.depth * ky;
            });
          }
          return root;
        }
        function firstWalk(v) {
          var children = v.children,
              siblings = v.parent.children,
              w = v.i ? siblings[v.i - 1] : null;
          if (children) {
            executeShifts(v);
            var midpoint = (children[0].z + children[children.length - 1].z) / 2;
            if (w) {
              v.z = w.z + separation(v._, w._);
              v.m = v.z - midpoint;
            } else {
              v.z = midpoint;
            }
          } else if (w) {
            v.z = w.z + separation(v._, w._);
          }
          v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
          v._.x = v.z + v.parent.m;
          v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
          if (w) {
            var vip = v,
                vop = v,
                vim = w,
                vom = vip.parent.children[0],
                sip = vip.m,
                sop = vop.m,
                sim = vim.m,
                som = vom.m,
                shift;
            while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
              vom = nextLeft(vom);
              vop = nextRight(vop);
              vop.a = v;
              shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
              if (shift > 0) {
                moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
                sip += shift;
                sop += shift;
              }
              sim += vim.m;
              sip += vip.m;
              som += vom.m;
              sop += vop.m;
            }
            if (vim && !nextRight(vop)) {
              vop.t = vim;
              vop.m += sim - sop;
            }
            if (vip && !nextLeft(vom)) {
              vom.t = vip;
              vom.m += sip - som;
              ancestor = v;
            }
          }
          return ancestor;
        }
        function sizeNode(node) {
          node.x *= dx;
          node.y = node.depth * dy;
        }
        tree.separation = function (x) {
          return arguments.length ? (separation = x, tree) : separation;
        };
        tree.size = function (x) {
          return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];
        };
        tree.nodeSize = function (x) {
          return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;
        };
        return tree;
      };
      var treemapSlice = function (parent, x0, y0, x1, y1) {
        var nodes = parent.children,
            node,
            i = -1,
            n = nodes.length,
            k = parent.value && (y1 - y0) / parent.value;
        while (++i < n) {
          node = nodes[i], node.x0 = x0, node.x1 = x1;
          node.y0 = y0, node.y1 = y0 += node.value * k;
        }
      };
      var phi = (1 + Math.sqrt(5)) / 2;
      function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
        var rows = [],
            nodes = parent.children,
            row,
            nodeValue,
            i0 = 0,
            i1 = 0,
            n = nodes.length,
            dx,
            dy,
            value = parent.value,
            sumValue,
            minValue,
            maxValue,
            newRatio,
            minRatio,
            alpha,
            beta;
        while (i0 < n) {
          dx = x1 - x0, dy = y1 - y0;
          do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
          minValue = maxValue = sumValue;
          alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
          beta = sumValue * sumValue * alpha;
          minRatio = Math.max(maxValue / beta, beta / minValue);
          for (; i1 < n; ++i1) {
            sumValue += nodeValue = nodes[i1].value;
            if (nodeValue < minValue) minValue = nodeValue;
            if (nodeValue > maxValue) maxValue = nodeValue;
            beta = sumValue * sumValue * alpha;
            newRatio = Math.max(maxValue / beta, beta / minValue);
            if (newRatio > minRatio) {
              sumValue -= nodeValue;
              break;
            }
            minRatio = newRatio;
          }
          rows.push(row = {
            value: sumValue,
            dice: dx < dy,
            children: nodes.slice(i0, i1)
          });
          if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
          value -= sumValue, i0 = i1;
        }
        return rows;
      }
      var squarify = function custom(ratio) {
        function squarify(parent, x0, y0, x1, y1) {
          squarifyRatio(ratio, parent, x0, y0, x1, y1);
        }
        squarify.ratio = function (x) {
          return custom((x = +x) > 1 ? x : 1);
        };
        return squarify;
      }(phi);
      var index$1 = function () {
        var tile = squarify,
            round = false,
            dx = 1,
            dy = 1,
            paddingStack = [0],
            paddingInner = constantZero,
            paddingTop = constantZero,
            paddingRight = constantZero,
            paddingBottom = constantZero,
            paddingLeft = constantZero;
        function treemap(root) {
          root.x0 = root.y0 = 0;
          root.x1 = dx;
          root.y1 = dy;
          root.eachBefore(positionNode);
          paddingStack = [0];
          if (round) root.eachBefore(roundNode);
          return root;
        }
        function positionNode(node) {
          var p = paddingStack[node.depth],
              x0 = node.x0 + p,
              y0 = node.y0 + p,
              x1 = node.x1 - p,
              y1 = node.y1 - p;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
          if (node.children) {
            p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
            x0 += paddingLeft(node) - p;
            y0 += paddingTop(node) - p;
            x1 -= paddingRight(node) - p;
            y1 -= paddingBottom(node) - p;
            if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
            if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
            tile(node, x0, y0, x1, y1);
          }
        }
        treemap.round = function (x) {
          return arguments.length ? (round = !!x, treemap) : round;
        };
        treemap.size = function (x) {
          return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
        };
        treemap.tile = function (x) {
          return arguments.length ? (tile = required(x), treemap) : tile;
        };
        treemap.padding = function (x) {
          return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
        };
        treemap.paddingInner = function (x) {
          return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$6(+x), treemap) : paddingInner;
        };
        treemap.paddingOuter = function (x) {
          return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
        };
        treemap.paddingTop = function (x) {
          return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$6(+x), treemap) : paddingTop;
        };
        treemap.paddingRight = function (x) {
          return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$6(+x), treemap) : paddingRight;
        };
        treemap.paddingBottom = function (x) {
          return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$6(+x), treemap) : paddingBottom;
        };
        treemap.paddingLeft = function (x) {
          return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$6(+x), treemap) : paddingLeft;
        };
        return treemap;
      };
      var binary = function (parent, x0, y0, x1, y1) {
        var nodes = parent.children,
            i,
            n = nodes.length,
            sum,
            sums = new Array(n + 1);
        for (sums[0] = sum = i = 0; i < n; ++i) {
          sums[i + 1] = sum += nodes[i].value;
        }
        partition(0, n, parent.value, x0, y0, x1, y1);
        function partition(i, j, value, x0, y0, x1, y1) {
          if (i >= j - 1) {
            var node = nodes[i];
            node.x0 = x0, node.y0 = y0;
            node.x1 = x1, node.y1 = y1;
            return;
          }
          var valueOffset = sums[i],
              valueTarget = value / 2 + valueOffset,
              k = i + 1,
              hi = j - 1;
          while (k < hi) {
            var mid = k + hi >>> 1;
            if (sums[mid] < valueTarget) k = mid + 1;else hi = mid;
          }
          var valueLeft = sums[k] - valueOffset,
              valueRight = value - valueLeft;
          if (y1 - y0 > x1 - x0) {
            var yk = (y0 * valueRight + y1 * valueLeft) / value;
            partition(i, k, valueLeft, x0, y0, x1, yk);
            partition(k, j, valueRight, x0, yk, x1, y1);
          } else {
            var xk = (x0 * valueRight + x1 * valueLeft) / value;
            partition(i, k, valueLeft, x0, y0, xk, y1);
            partition(k, j, valueRight, xk, y0, x1, y1);
          }
        }
      };
      var sliceDice = function (parent, x0, y0, x1, y1) {
        (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
      };
      var resquarify = function custom(ratio) {
        function resquarify(parent, x0, y0, x1, y1) {
          if ((rows = parent._squarify) && rows.ratio === ratio) {
            var rows,
                row,
                nodes,
                i,
                j = -1,
                n,
                m = rows.length,
                value = parent.value;
            while (++j < m) {
              row = rows[j], nodes = row.children;
              for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
              if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
              value -= row.value;
            }
          } else {
            parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
            rows.ratio = ratio;
          }
        }
        resquarify.ratio = function (x) {
          return custom((x = +x) > 1 ? x : 1);
        };
        return resquarify;
      }(phi);
      var center$1 = function (x, y) {
        var nodes;
        if (x == null) x = 0;
        if (y == null) y = 0;
        function force() {
          var i,
              n = nodes.length,
              node,
              sx = 0,
              sy = 0;
          for (i = 0; i < n; ++i) {
            node = nodes[i], sx += node.x, sy += node.y;
          }
          for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
            node = nodes[i], node.x -= sx, node.y -= sy;
          }
        }
        force.initialize = function (_) {
          nodes = _;
        };
        force.x = function (_) {
          return arguments.length ? (x = +_, force) : x;
        };
        force.y = function (_) {
          return arguments.length ? (y = +_, force) : y;
        };
        return force;
      };
      var constant$7 = function (x) {
        return function () {
          return x;
        };
      };
      var jiggle = function () {
        return (Math.random() - 0.5) * 1e-6;
      };
      function x$1(d) {
        return d.x + d.vx;
      }
      function y$1(d) {
        return d.y + d.vy;
      }
      var collide = function (radius) {
        var nodes,
            radii,
            strength = 1,
            iterations = 1;
        if (typeof radius !== "function") radius = constant$7(radius == null ? 1 : +radius);
        function force() {
          var i,
              n = nodes.length,
              tree,
              node,
              xi,
              yi,
              ri,
              ri2;
          for (var k = 0; k < iterations; ++k) {
            tree = quadtree(nodes, x$1, y$1).visitAfter(prepare);
            for (i = 0; i < n; ++i) {
              node = nodes[i];
              ri = radii[node.index], ri2 = ri * ri;
              xi = node.x + node.vx;
              yi = node.y + node.vy;
              tree.visit(apply);
            }
          }
          function apply(quad, x0, y0, x1, y1) {
            var data = quad.data,
                rj = quad.r,
                r = ri + rj;
            if (data) {
              if (data.index > node.index) {
                var x = xi - data.x - data.vx,
                    y = yi - data.y - data.vy,
                    l = x * x + y * y;
                if (l < r * r) {
                  if (x === 0) x = jiggle(), l += x * x;
                  if (y === 0) y = jiggle(), l += y * y;
                  l = (r - (l = Math.sqrt(l))) / l * strength;
                  node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                  node.vy += (y *= l) * r;
                  data.vx -= x * (r = 1 - r);
                  data.vy -= y * r;
                }
              }
              return;
            }
            return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
          }
        }
        function prepare(quad) {
          if (quad.data) return quad.r = radii[quad.data.index];
          for (var i = quad.r = 0; i < 4; ++i) {
            if (quad[i] && quad[i].r > quad.r) {
              quad.r = quad[i].r;
            }
          }
        }
        function initialize() {
          if (!nodes) return;
          var i,
              n = nodes.length,
              node;
          radii = new Array(n);
          for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
        }
        force.initialize = function (_) {
          nodes = _;
          initialize();
        };
        force.iterations = function (_) {
          return arguments.length ? (iterations = +_, force) : iterations;
        };
        force.strength = function (_) {
          return arguments.length ? (strength = +_, force) : strength;
        };
        force.radius = function (_) {
          return arguments.length ? (radius = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : radius;
        };
        return force;
      };
      function index$2(d) {
        return d.index;
      }
      function find(nodeById, nodeId) {
        var node = nodeById.get(nodeId);
        if (!node) throw new Error("missing: " + nodeId);
        return node;
      }
      var link = function (links) {
        var id = index$2,
            strength = defaultStrength,
            strengths,
            distance = constant$7(30),
            distances,
            nodes,
            count,
            bias,
            iterations = 1;
        if (links == null) links = [];
        function defaultStrength(link) {
          return 1 / Math.min(count[link.source.index], count[link.target.index]);
        }
        function force(alpha) {
          for (var k = 0, n = links.length; k < iterations; ++k) {
            for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
              link = links[i], source = link.source, target = link.target;
              x = target.x + target.vx - source.x - source.vx || jiggle();
              y = target.y + target.vy - source.y - source.vy || jiggle();
              l = Math.sqrt(x * x + y * y);
              l = (l - distances[i]) / l * alpha * strengths[i];
              x *= l, y *= l;
              target.vx -= x * (b = bias[i]);
              target.vy -= y * b;
              source.vx += x * (b = 1 - b);
              source.vy += y * b;
            }
          }
        }
        function initialize() {
          if (!nodes) return;
          var i,
              n = nodes.length,
              m = links.length,
              nodeById = map$1(nodes, id),
              link;
          for (i = 0, count = new Array(n); i < m; ++i) {
            link = links[i], link.index = i;
            if (typeof link.source !== "object") link.source = find(nodeById, link.source);
            if (typeof link.target !== "object") link.target = find(nodeById, link.target);
            count[link.source.index] = (count[link.source.index] || 0) + 1;
            count[link.target.index] = (count[link.target.index] || 0) + 1;
          }
          for (i = 0, bias = new Array(m); i < m; ++i) {
            link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
          }
          strengths = new Array(m), initializeStrength();
          distances = new Array(m), initializeDistance();
        }
        function initializeStrength() {
          if (!nodes) return;
          for (var i = 0, n = links.length; i < n; ++i) {
            strengths[i] = +strength(links[i], i, links);
          }
        }
        function initializeDistance() {
          if (!nodes) return;
          for (var i = 0, n = links.length; i < n; ++i) {
            distances[i] = +distance(links[i], i, links);
          }
        }
        force.initialize = function (_) {
          nodes = _;
          initialize();
        };
        force.links = function (_) {
          return arguments.length ? (links = _, initialize(), force) : links;
        };
        force.id = function (_) {
          return arguments.length ? (id = _, force) : id;
        };
        force.iterations = function (_) {
          return arguments.length ? (iterations = +_, force) : iterations;
        };
        force.strength = function (_) {
          return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initializeStrength(), force) : strength;
        };
        force.distance = function (_) {
          return arguments.length ? (distance = typeof _ === "function" ? _ : constant$7(+_), initializeDistance(), force) : distance;
        };
        return force;
      };
      function x$2(d) {
        return d.x;
      }
      function y$2(d) {
        return d.y;
      }
      var initialRadius = 10;
      var initialAngle = Math.PI * (3 - Math.sqrt(5));
      var simulation = function (nodes) {
        var simulation,
            alpha = 1,
            alphaMin = 0.001,
            alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
            alphaTarget = 0,
            velocityDecay = 0.6,
            forces = map$1(),
            stepper = timer(step),
            event = dispatch("tick", "end");
        if (nodes == null) nodes = [];
        function step() {
          tick();
          event.call("tick", simulation);
          if (alpha < alphaMin) {
            stepper.stop();
            event.call("end", simulation);
          }
        }
        function tick() {
          var i,
              n = nodes.length,
              node;
          alpha += (alphaTarget - alpha) * alphaDecay;
          forces.each(function (force) {
            force(alpha);
          });
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;else node.y = node.fy, node.vy = 0;
          }
        }
        function initializeNodes() {
          for (var i = 0, n = nodes.length, node; i < n; ++i) {
            node = nodes[i], node.index = i;
            if (isNaN(node.x) || isNaN(node.y)) {
              var radius = initialRadius * Math.sqrt(i),
                  angle = i * initialAngle;
              node.x = radius * Math.cos(angle);
              node.y = radius * Math.sin(angle);
            }
            if (isNaN(node.vx) || isNaN(node.vy)) {
              node.vx = node.vy = 0;
            }
          }
        }
        function initializeForce(force) {
          if (force.initialize) force.initialize(nodes);
          return force;
        }
        initializeNodes();
        return simulation = {
          tick: tick,
          restart: function () {
            return stepper.restart(step), simulation;
          },
          stop: function () {
            return stepper.stop(), simulation;
          },
          nodes: function (_) {
            return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
          },
          alpha: function (_) {
            return arguments.length ? (alpha = +_, simulation) : alpha;
          },
          alphaMin: function (_) {
            return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
          },
          alphaDecay: function (_) {
            return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
          },
          alphaTarget: function (_) {
            return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
          },
          velocityDecay: function (_) {
            return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
          },
          force: function (name, _) {
            return arguments.length > 1 ? (_ == null ? forces.remove(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
          },
          find: function (x, y, radius) {
            var i = 0,
                n = nodes.length,
                dx,
                dy,
                d2,
                node,
                closest;
            if (radius == null) radius = Infinity;else radius *= radius;
            for (i = 0; i < n; ++i) {
              node = nodes[i];
              dx = x - node.x;
              dy = y - node.y;
              d2 = dx * dx + dy * dy;
              if (d2 < radius) closest = node, radius = d2;
            }
            return closest;
          },
          on: function (name, _) {
            return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
          }
        };
      };
      var manyBody = function () {
        var nodes,
            node,
            alpha,
            strength = constant$7(-30),
            strengths,
            distanceMin2 = 1,
            distanceMax2 = Infinity,
            theta2 = 0.81;
        function force(_) {
          var i,
              n = nodes.length,
              tree = quadtree(nodes, x$2, y$2).visitAfter(accumulate);
          for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
        }
        function initialize() {
          if (!nodes) return;
          var i,
              n = nodes.length,
              node;
          strengths = new Array(n);
          for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
        }
        function accumulate(quad) {
          var strength = 0,
              q,
              c,
              x$$1,
              y$$1,
              i;
          if (quad.length) {
            for (x$$1 = y$$1 = i = 0; i < 4; ++i) {
              if ((q = quad[i]) && (c = q.value)) {
                strength += c, x$$1 += c * q.x, y$$1 += c * q.y;
              }
            }
            quad.x = x$$1 / strength;
            quad.y = y$$1 / strength;
          } else {
            q = quad;
            q.x = q.data.x;
            q.y = q.data.y;
            do strength += strengths[q.data.index]; while (q = q.next);
          }
          quad.value = strength;
        }
        function apply(quad, x1, _, x2) {
          if (!quad.value) return true;
          var x$$1 = quad.x - node.x,
              y$$1 = quad.y - node.y,
              w = x2 - x1,
              l = x$$1 * x$$1 + y$$1 * y$$1;
          if (w * w / theta2 < l) {
            if (l < distanceMax2) {
              if (x$$1 === 0) x$$1 = jiggle(), l += x$$1 * x$$1;
              if (y$$1 === 0) y$$1 = jiggle(), l += y$$1 * y$$1;
              if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
              node.vx += x$$1 * quad.value * alpha / l;
              node.vy += y$$1 * quad.value * alpha / l;
            }
            return true;
          } else if (quad.length || l >= distanceMax2) return;
          if (quad.data !== node || quad.next) {
            if (x$$1 === 0) x$$1 = jiggle(), l += x$$1 * x$$1;
            if (y$$1 === 0) y$$1 = jiggle(), l += y$$1 * y$$1;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
          }
          do if (quad.data !== node) {
            w = strengths[quad.data.index] * alpha / l;
            node.vx += x$$1 * w;
            node.vy += y$$1 * w;
          } while (quad = quad.next);
        }
        force.initialize = function (_) {
          nodes = _;
          initialize();
        };
        force.strength = function (_) {
          return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : strength;
        };
        force.distanceMin = function (_) {
          return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
        };
        force.distanceMax = function (_) {
          return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
        };
        force.theta = function (_) {
          return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
        };
        return force;
      };
      var x$3 = function (x) {
        var strength = constant$7(0.1),
            nodes,
            strengths,
            xz;
        if (typeof x !== "function") x = constant$7(x == null ? 0 : +x);
        function force(alpha) {
          for (var i = 0, n = nodes.length, node; i < n; ++i) {
            node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
          }
        }
        function initialize() {
          if (!nodes) return;
          var i,
              n = nodes.length;
          strengths = new Array(n);
          xz = new Array(n);
          for (i = 0; i < n; ++i) {
            strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
          }
        }
        force.initialize = function (_) {
          nodes = _;
          initialize();
        };
        force.strength = function (_) {
          return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : strength;
        };
        force.x = function (_) {
          return arguments.length ? (x = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : x;
        };
        return force;
      };
      var y$3 = function (y) {
        var strength = constant$7(0.1),
            nodes,
            strengths,
            yz;
        if (typeof y !== "function") y = constant$7(y == null ? 0 : +y);
        function force(alpha) {
          for (var i = 0, n = nodes.length, node; i < n; ++i) {
            node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
          }
        }
        function initialize() {
          if (!nodes) return;
          var i,
              n = nodes.length;
          strengths = new Array(n);
          yz = new Array(n);
          for (i = 0; i < n; ++i) {
            strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
          }
        }
        force.initialize = function (_) {
          nodes = _;
          initialize();
        };
        force.strength = function (_) {
          return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : strength;
        };
        force.y = function (_) {
          return arguments.length ? (y = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : y;
        };
        return force;
      };
      function nopropagation() {
        exports.event.stopImmediatePropagation();
      }
      var noevent = function () {
        exports.event.preventDefault();
        exports.event.stopImmediatePropagation();
      };
      var dragDisable = function (view) {
        var root = view.document.documentElement,
            selection$$1 = select(view).on("dragstart.drag", noevent, true);
        if ("onselectstart" in root) {
          selection$$1.on("selectstart.drag", noevent, true);
        } else {
          root.__noselect = root.style.MozUserSelect;
          root.style.MozUserSelect = "none";
        }
      };
      function yesdrag(view, noclick) {
        var root = view.document.documentElement,
            selection$$1 = select(view).on("dragstart.drag", null);
        if (noclick) {
          selection$$1.on("click.drag", noevent, true);
          setTimeout(function () {
            selection$$1.on("click.drag", null);
          }, 0);
        }
        if ("onselectstart" in root) {
          selection$$1.on("selectstart.drag", null);
        } else {
          root.style.MozUserSelect = root.__noselect;
          delete root.__noselect;
        }
      }
      var constant$8 = function (x) {
        return function () {
          return x;
        };
      };
      function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
        this.target = target;
        this.type = type;
        this.subject = subject;
        this.identifier = id;
        this.active = active;
        this.x = x;
        this.y = y;
        this.dx = dx;
        this.dy = dy;
        this._ = dispatch;
      }
      DragEvent.prototype.on = function () {
        var value = this._.on.apply(this._, arguments);
        return value === this._ ? this : value;
      };
      function defaultFilter() {
        return !exports.event.button;
      }
      function defaultContainer() {
        return this.parentNode;
      }
      function defaultSubject(d) {
        return d == null ? {
          x: exports.event.x,
          y: exports.event.y
        } : d;
      }
      var drag = function () {
        var filter = defaultFilter,
            container = defaultContainer,
            subject = defaultSubject,
            gestures = {},
            listeners = dispatch("start", "drag", "end"),
            active = 0,
            mousemoving,
            touchending;
        function drag(selection$$1) {
          selection$$1.on("mousedown.drag", mousedowned).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
        }
        function mousedowned() {
          if (touchending || !filter.apply(this, arguments)) return;
          var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
          if (!gesture) return;
          select(exports.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
          dragDisable(exports.event.view);
          nopropagation();
          mousemoving = false;
          gesture("start");
        }
        function mousemoved() {
          noevent();
          mousemoving = true;
          gestures.mouse("drag");
        }
        function mouseupped() {
          select(exports.event.view).on("mousemove.drag mouseup.drag", null);
          yesdrag(exports.event.view, mousemoving);
          noevent();
          gestures.mouse("end");
        }
        function touchstarted() {
          if (!filter.apply(this, arguments)) return;
          var touches$$1 = exports.event.changedTouches,
              c = container.apply(this, arguments),
              n = touches$$1.length,
              i,
              gesture;
          for (i = 0; i < n; ++i) {
            if (gesture = beforestart(touches$$1[i].identifier, c, touch, this, arguments)) {
              nopropagation();
              gesture("start");
            }
          }
        }
        function touchmoved() {
          var touches$$1 = exports.event.changedTouches,
              n = touches$$1.length,
              i,
              gesture;
          for (i = 0; i < n; ++i) {
            if (gesture = gestures[touches$$1[i].identifier]) {
              noevent();
              gesture("drag");
            }
          }
        }
        function touchended() {
          var touches$$1 = exports.event.changedTouches,
              n = touches$$1.length,
              i,
              gesture;
          if (touchending) clearTimeout(touchending);
          touchending = setTimeout(function () {
            touchending = null;
          }, 500);
          for (i = 0; i < n; ++i) {
            if (gesture = gestures[touches$$1[i].identifier]) {
              nopropagation();
              gesture("end");
            }
          }
        }
        function beforestart(id, container, point, that, args) {
          var p = point(container, id),
              s,
              dx,
              dy,
              sublisteners = listeners.copy();
          if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function () {
            if ((exports.event.subject = s = subject.apply(that, args)) == null) return false;
            dx = s.x - p[0] || 0;
            dy = s.y - p[1] || 0;
            return true;
          })) return;
          return function gesture(type) {
            var p0 = p,
                n;
            switch (type) {
              case "start":
                gestures[id] = gesture, n = active++;
                break;
              case "end":
                delete gestures[id], --active;
              case "drag":
                p = point(container, id), n = active;
                break;
            }
            customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
          };
        }
        drag.filter = function (_) {
          return arguments.length ? (filter = typeof _ === "function" ? _ : constant$8(!!_), drag) : filter;
        };
        drag.container = function (_) {
          return arguments.length ? (container = typeof _ === "function" ? _ : constant$8(_), drag) : container;
        };
        drag.subject = function (_) {
          return arguments.length ? (subject = typeof _ === "function" ? _ : constant$8(_), drag) : subject;
        };
        drag.on = function () {
          var value = listeners.on.apply(listeners, arguments);
          return value === listeners ? drag : value;
        };
        return drag;
      };
      var constant$9 = function (x) {
        return function () {
          return x;
        };
      };
      function x$4(d) {
        return d[0];
      }
      function y$4(d) {
        return d[1];
      }
      function RedBlackTree() {
        this._ = null;
      }
      function RedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
      }
      RedBlackTree.prototype = {
        constructor: RedBlackTree,
        insert: function (after, node) {
          var parent, grandpa, uncle;
          if (after) {
            node.P = after;
            node.N = after.N;
            if (after.N) after.N.P = node;
            after.N = node;
            if (after.R) {
              after = after.R;
              while (after.L) after = after.L;
              after.L = node;
            } else {
              after.R = node;
            }
            parent = after;
          } else if (this._) {
            after = RedBlackFirst(this._);
            node.P = null;
            node.N = after;
            after.P = after.L = node;
            parent = after;
          } else {
            node.P = node.N = null;
            this._ = node;
            parent = null;
          }
          node.L = node.R = null;
          node.U = parent;
          node.C = true;
          after = node;
          while (parent && parent.C) {
            grandpa = parent.U;
            if (parent === grandpa.L) {
              uncle = grandpa.R;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.R) {
                  RedBlackRotateLeft(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                RedBlackRotateRight(this, grandpa);
              }
            } else {
              uncle = grandpa.L;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.L) {
                  RedBlackRotateRight(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                RedBlackRotateLeft(this, grandpa);
              }
            }
            parent = after.U;
          }
          this._.C = false;
        },
        remove: function (node) {
          if (node.N) node.N.P = node.P;
          if (node.P) node.P.N = node.N;
          node.N = node.P = null;
          var parent = node.U,
              sibling,
              left = node.L,
              right = node.R,
              next,
              red;
          if (!left) next = right;else if (!right) next = left;else next = RedBlackFirst(right);
          if (parent) {
            if (parent.L === node) parent.L = next;else parent.R = next;
          } else {
            this._ = next;
          }
          if (left && right) {
            red = next.C;
            next.C = node.C;
            next.L = left;
            left.U = next;
            if (next !== right) {
              parent = next.U;
              next.U = node.U;
              node = next.R;
              parent.L = node;
              next.R = right;
              right.U = next;
            } else {
              next.U = parent;
              parent = next;
              node = next.R;
            }
          } else {
            red = node.C;
            node = next;
          }
          if (node) node.U = parent;
          if (red) return;
          if (node && node.C) {
            node.C = false;
            return;
          }
          do {
            if (node === this._) break;
            if (node === parent.L) {
              sibling = parent.R;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                RedBlackRotateLeft(this, parent);
                sibling = parent.R;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.R || !sibling.R.C) {
                  sibling.L.C = false;
                  sibling.C = true;
                  RedBlackRotateRight(this, sibling);
                  sibling = parent.R;
                }
                sibling.C = parent.C;
                parent.C = sibling.R.C = false;
                RedBlackRotateLeft(this, parent);
                node = this._;
                break;
              }
            } else {
              sibling = parent.L;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                RedBlackRotateRight(this, parent);
                sibling = parent.L;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.L || !sibling.L.C) {
                  sibling.R.C = false;
                  sibling.C = true;
                  RedBlackRotateLeft(this, sibling);
                  sibling = parent.L;
                }
                sibling.C = parent.C;
                parent.C = sibling.L.C = false;
                RedBlackRotateRight(this, parent);
                node = this._;
                break;
              }
            }
            sibling.C = true;
            node = parent;
            parent = parent.U;
          } while (!node.C);
          if (node) node.C = false;
        }
      };
      function RedBlackRotateLeft(tree, node) {
        var p = node,
            q = node.R,
            parent = p.U;
        if (parent) {
          if (parent.L === p) parent.L = q;else parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R) p.R.U = p;
        q.L = p;
      }
      function RedBlackRotateRight(tree, node) {
        var p = node,
            q = node.L,
            parent = p.U;
        if (parent) {
          if (parent.L === p) parent.L = q;else parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L) p.L.U = p;
        q.R = p;
      }
      function RedBlackFirst(node) {
        while (node.L) node = node.L;
        return node;
      }
      function createEdge(left, right, v0, v1) {
        var edge = [null, null],
            index = edges.push(edge) - 1;
        edge.left = left;
        edge.right = right;
        if (v0) setEdgeEnd(edge, left, right, v0);
        if (v1) setEdgeEnd(edge, right, left, v1);
        cells[left.index].halfedges.push(index);
        cells[right.index].halfedges.push(index);
        return edge;
      }
      function createBorderEdge(left, v0, v1) {
        var edge = [v0, v1];
        edge.left = left;
        return edge;
      }
      function setEdgeEnd(edge, left, right, vertex) {
        if (!edge[0] && !edge[1]) {
          edge[0] = vertex;
          edge.left = left;
          edge.right = right;
        } else if (edge.left === right) {
          edge[1] = vertex;
        } else {
          edge[0] = vertex;
        }
      }
      function clipEdge(edge, x0, y0, x1, y1) {
        var a = edge[0],
            b = edge[1],
            ax = a[0],
            ay = a[1],
            bx = b[0],
            by = b[1],
            t0 = 0,
            t1 = 1,
            dx = bx - ax,
            dy = by - ay,
            r;
        r = x0 - ax;
        if (!dx && r > 0) return;
        r /= dx;
        if (dx < 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        } else if (dx > 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        }
        r = x1 - ax;
        if (!dx && r < 0) return;
        r /= dx;
        if (dx < 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        } else if (dx > 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        }
        r = y0 - ay;
        if (!dy && r > 0) return;
        r /= dy;
        if (dy < 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        } else if (dy > 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        }
        r = y1 - ay;
        if (!dy && r < 0) return;
        r /= dy;
        if (dy < 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        } else if (dy > 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        }
        if (!(t0 > 0) && !(t1 < 1)) return true;
        if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
        if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
        return true;
      }
      function connectEdge(edge, x0, y0, x1, y1) {
        var v1 = edge[1];
        if (v1) return true;
        var v0 = edge[0],
            left = edge.left,
            right = edge.right,
            lx = left[0],
            ly = left[1],
            rx = right[0],
            ry = right[1],
            fx = (lx + rx) / 2,
            fy = (ly + ry) / 2,
            fm,
            fb;
        if (ry === ly) {
          if (fx < x0 || fx >= x1) return;
          if (lx > rx) {
            if (!v0) v0 = [fx, y0];else if (v0[1] >= y1) return;
            v1 = [fx, y1];
          } else {
            if (!v0) v0 = [fx, y1];else if (v0[1] < y0) return;
            v1 = [fx, y0];
          }
        } else {
          fm = (lx - rx) / (ry - ly);
          fb = fy - fm * fx;
          if (fm < -1 || fm > 1) {
            if (lx > rx) {
              if (!v0) v0 = [(y0 - fb) / fm, y0];else if (v0[1] >= y1) return;
              v1 = [(y1 - fb) / fm, y1];
            } else {
              if (!v0) v0 = [(y1 - fb) / fm, y1];else if (v0[1] < y0) return;
              v1 = [(y0 - fb) / fm, y0];
            }
          } else {
            if (ly < ry) {
              if (!v0) v0 = [x0, fm * x0 + fb];else if (v0[0] >= x1) return;
              v1 = [x1, fm * x1 + fb];
            } else {
              if (!v0) v0 = [x1, fm * x1 + fb];else if (v0[0] < x0) return;
              v1 = [x0, fm * x0 + fb];
            }
          }
        }
        edge[0] = v0;
        edge[1] = v1;
        return true;
      }
      function clipEdges(x0, y0, x1, y1) {
        var i = edges.length,
            edge;
        while (i--) {
          if (!connectEdge(edge = edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$3 || Math.abs(edge[0][1] - edge[1][1]) > epsilon$3)) {
            delete edges[i];
          }
        }
      }
      function createCell(site) {
        return cells[site.index] = {
          site: site,
          halfedges: []
        };
      }
      function cellHalfedgeAngle(cell, edge) {
        var site = cell.site,
            va = edge.left,
            vb = edge.right;
        if (site === vb) vb = va, va = site;
        if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
        if (site === va) va = edge[1], vb = edge[0];else va = edge[0], vb = edge[1];
        return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
      }
      function cellHalfedgeStart(cell, edge) {
        return edge[+(edge.left !== cell.site)];
      }
      function cellHalfedgeEnd(cell, edge) {
        return edge[+(edge.left === cell.site)];
      }
      function sortCellHalfedges() {
        for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
          if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
            var index = new Array(m),
                array = new Array(m);
            for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
            index.sort(function (i, j) {
              return array[j] - array[i];
            });
            for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
            for (j = 0; j < m; ++j) halfedges[j] = array[j];
          }
        }
      }
      function clipCells(x0, y0, x1, y1) {
        var nCells = cells.length,
            iCell,
            cell,
            site,
            iHalfedge,
            halfedges,
            nHalfedges,
            start,
            startX,
            startY,
            end,
            endX,
            endY,
            cover = true;
        for (iCell = 0; iCell < nCells; ++iCell) {
          if (cell = cells[iCell]) {
            site = cell.site;
            halfedges = cell.halfedges;
            iHalfedge = halfedges.length;
            while (iHalfedge--) {
              if (!edges[halfedges[iHalfedge]]) {
                halfedges.splice(iHalfedge, 1);
              }
            }
            iHalfedge = 0, nHalfedges = halfedges.length;
            while (iHalfedge < nHalfedges) {
              end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
              start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
              if (Math.abs(endX - startX) > epsilon$3 || Math.abs(endY - startY) > epsilon$3) {
                halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x0) < epsilon$3 && y1 - endY > epsilon$3 ? [x0, Math.abs(startX - x0) < epsilon$3 ? startY : y1] : Math.abs(endY - y1) < epsilon$3 && x1 - endX > epsilon$3 ? [Math.abs(startY - y1) < epsilon$3 ? startX : x1, y1] : Math.abs(endX - x1) < epsilon$3 && endY - y0 > epsilon$3 ? [x1, Math.abs(startX - x1) < epsilon$3 ? startY : y0] : Math.abs(endY - y0) < epsilon$3 && endX - x0 > epsilon$3 ? [Math.abs(startY - y0) < epsilon$3 ? startX : x0, y0] : null)) - 1);
                ++nHalfedges;
              }
            }
            if (nHalfedges) cover = false;
          }
        }
        if (cover) {
          var dx,
              dy,
              d2,
              dc = Infinity;
          for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
            if (cell = cells[iCell]) {
              site = cell.site;
              dx = site[0] - x0;
              dy = site[1] - y0;
              d2 = dx * dx + dy * dy;
              if (d2 < dc) dc = d2, cover = cell;
            }
          }
          if (cover) {
            var v00 = [x0, y0],
                v01 = [x0, y1],
                v11 = [x1, y1],
                v10 = [x1, y0];
            cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);
          }
        }
        for (iCell = 0; iCell < nCells; ++iCell) {
          if (cell = cells[iCell]) {
            if (!cell.halfedges.length) {
              delete cells[iCell];
            }
          }
        }
      }
      var circlePool = [];
      var firstCircle;
      function Circle() {
        RedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
      }
      function attachCircle(arc) {
        var lArc = arc.P,
            rArc = arc.N;
        if (!lArc || !rArc) return;
        var lSite = lArc.site,
            cSite = arc.site,
            rSite = rArc.site;
        if (lSite === rSite) return;
        var bx = cSite[0],
            by = cSite[1],
            ax = lSite[0] - bx,
            ay = lSite[1] - by,
            cx = rSite[0] - bx,
            cy = rSite[1] - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -epsilon2$1) return;
        var ha = ax * ax + ay * ay,
            hc = cx * cx + cy * cy,
            x = (cy * ha - ay * hc) / d,
            y = (ax * hc - cx * ha) / d;
        var circle = circlePool.pop() || new Circle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y);
        arc.circle = circle;
        var before = null,
            node = circles._;
        while (node) {
          if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
            if (node.L) node = node.L;else {
              before = node.P;
              break;
            }
          } else {
            if (node.R) node = node.R;else {
              before = node;
              break;
            }
          }
        }
        circles.insert(before, circle);
        if (!before) firstCircle = circle;
      }
      function detachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
          if (!circle.P) firstCircle = circle.N;
          circles.remove(circle);
          circlePool.push(circle);
          RedBlackNode(circle);
          arc.circle = null;
        }
      }
      var beachPool = [];
      function Beach() {
        RedBlackNode(this);
        this.edge = this.site = this.circle = null;
      }
      function createBeach(site) {
        var beach = beachPool.pop() || new Beach();
        beach.site = site;
        return beach;
      }
      function detachBeach(beach) {
        detachCircle(beach);
        beaches.remove(beach);
        beachPool.push(beach);
        RedBlackNode(beach);
      }
      function removeBeach(beach) {
        var circle = beach.circle,
            x = circle.x,
            y = circle.cy,
            vertex = [x, y],
            previous = beach.P,
            next = beach.N,
            disappearing = [beach];
        detachBeach(beach);
        var lArc = previous;
        while (lArc.circle && Math.abs(x - lArc.circle.x) < epsilon$3 && Math.abs(y - lArc.circle.cy) < epsilon$3) {
          previous = lArc.P;
          disappearing.unshift(lArc);
          detachBeach(lArc);
          lArc = previous;
        }
        disappearing.unshift(lArc);
        detachCircle(lArc);
        var rArc = next;
        while (rArc.circle && Math.abs(x - rArc.circle.x) < epsilon$3 && Math.abs(y - rArc.circle.cy) < epsilon$3) {
          next = rArc.N;
          disappearing.push(rArc);
          detachBeach(rArc);
          rArc = next;
        }
        disappearing.push(rArc);
        detachCircle(rArc);
        var nArcs = disappearing.length,
            iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
          rArc = disappearing[iArc];
          lArc = disappearing[iArc - 1];
          setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
        attachCircle(lArc);
        attachCircle(rArc);
      }
      function addBeach(site) {
        var x = site[0],
            directrix = site[1],
            lArc,
            rArc,
            dxl,
            dxr,
            node = beaches._;
        while (node) {
          dxl = leftBreakPoint(node, directrix) - x;
          if (dxl > epsilon$3) node = node.L;else {
            dxr = x - rightBreakPoint(node, directrix);
            if (dxr > epsilon$3) {
              if (!node.R) {
                lArc = node;
                break;
              }
              node = node.R;
            } else {
              if (dxl > -epsilon$3) {
                lArc = node.P;
                rArc = node;
              } else if (dxr > -epsilon$3) {
                lArc = node;
                rArc = node.N;
              } else {
                lArc = rArc = node;
              }
              break;
            }
          }
        }
        createCell(site);
        var newArc = createBeach(site);
        beaches.insert(lArc, newArc);
        if (!lArc && !rArc) return;
        if (lArc === rArc) {
          detachCircle(lArc);
          rArc = createBeach(lArc.site);
          beaches.insert(newArc, rArc);
          newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
          attachCircle(lArc);
          attachCircle(rArc);
          return;
        }
        if (!rArc) {
          newArc.edge = createEdge(lArc.site, newArc.site);
          return;
        }
        detachCircle(lArc);
        detachCircle(rArc);
        var lSite = lArc.site,
            ax = lSite[0],
            ay = lSite[1],
            bx = site[0] - ax,
            by = site[1] - ay,
            rSite = rArc.site,
            cx = rSite[0] - ax,
            cy = rSite[1] - ay,
            d = 2 * (bx * cy - by * cx),
            hb = bx * bx + by * by,
            hc = cx * cx + cy * cy,
            vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
        setEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = createEdge(lSite, site, null, vertex);
        rArc.edge = createEdge(site, rSite, null, vertex);
        attachCircle(lArc);
        attachCircle(rArc);
      }
      function leftBreakPoint(arc, directrix) {
        var site = arc.site,
            rfocx = site[0],
            rfocy = site[1],
            pby2 = rfocy - directrix;
        if (!pby2) return rfocx;
        var lArc = arc.P;
        if (!lArc) return -Infinity;
        site = lArc.site;
        var lfocx = site[0],
            lfocy = site[1],
            plby2 = lfocy - directrix;
        if (!plby2) return lfocx;
        var hl = lfocx - rfocx,
            aby2 = 1 / pby2 - 1 / plby2,
            b = hl / plby2;
        if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
      }
      function rightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc) return leftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site[1] === directrix ? site[0] : Infinity;
      }
      var epsilon$3 = 1e-6;
      var epsilon2$1 = 1e-12;
      var beaches;
      var cells;
      var circles;
      var edges;
      function triangleArea(a, b, c) {
        return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
      }
      function lexicographic(a, b) {
        return b[1] - a[1] || b[0] - a[0];
      }
      function Diagram(sites, extent) {
        var site = sites.sort(lexicographic).pop(),
            x,
            y,
            circle;
        edges = [];
        cells = new Array(sites.length);
        beaches = new RedBlackTree();
        circles = new RedBlackTree();
        while (true) {
          circle = firstCircle;
          if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
            if (site[0] !== x || site[1] !== y) {
              addBeach(site);
              x = site[0], y = site[1];
            }
            site = sites.pop();
          } else if (circle) {
            removeBeach(circle.arc);
          } else {
            break;
          }
        }
        sortCellHalfedges();
        if (extent) {
          var x0 = +extent[0][0],
              y0 = +extent[0][1],
              x1 = +extent[1][0],
              y1 = +extent[1][1];
          clipEdges(x0, y0, x1, y1);
          clipCells(x0, y0, x1, y1);
        }
        this.edges = edges;
        this.cells = cells;
        beaches = circles = edges = cells = null;
      }
      Diagram.prototype = {
        constructor: Diagram,
        polygons: function () {
          var edges = this.edges;
          return this.cells.map(function (cell) {
            var polygon = cell.halfedges.map(function (i) {
              return cellHalfedgeStart(cell, edges[i]);
            });
            polygon.data = cell.site.data;
            return polygon;
          });
        },
        triangles: function () {
          var triangles = [],
              edges = this.edges;
          this.cells.forEach(function (cell, i) {
            var site = cell.site,
                halfedges = cell.halfedges,
                j = -1,
                m = halfedges.length,
                s0,
                e1 = edges[halfedges[m - 1]],
                s1 = e1.left === site ? e1.right : e1.left;
            while (++j < m) {
              s0 = s1;
              e1 = edges[halfedges[j]];
              s1 = e1.left === site ? e1.right : e1.left;
              if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
                triangles.push([site.data, s0.data, s1.data]);
              }
            }
          });
          return triangles;
        },
        links: function () {
          return this.edges.filter(function (edge) {
            return edge.right;
          }).map(function (edge) {
            return {
              source: edge.left.data,
              target: edge.right.data
            };
          });
        },
        find: function (x, y, radius) {
          var that = this,
              i0,
              i1 = that._found || 0,
              cell = that.cells[i1] || that.cells[i1 = 0],
              dx = x - cell.site[0],
              dy = y - cell.site[1],
              d2 = dx * dx + dy * dy;
          do {
            cell = that.cells[i0 = i1], i1 = null;
            cell.halfedges.forEach(function (e) {
              var edge = that.edges[e],
                  v = edge.left;
              if ((v === cell.site || !v) && !(v = edge.right)) return;
              var vx = x - v[0],
                  vy = y - v[1],
                  v2 = vx * vx + vy * vy;
              if (v2 < d2) d2 = v2, i1 = v.index;
            });
          } while (i1 !== null);
          that._found = i0;
          return radius == null || d2 <= radius * radius ? cell.site : null;
        }
      };
      var voronoi = function () {
        var x$$1 = x$4,
            y$$1 = y$4,
            extent = null;
        function voronoi(data) {
          return new Diagram(data.map(function (d, i) {
            var s = [Math.round(x$$1(d, i, data) / epsilon$3) * epsilon$3, Math.round(y$$1(d, i, data) / epsilon$3) * epsilon$3];
            s.index = i;
            s.data = d;
            return s;
          }), extent);
        }
        voronoi.polygons = function (data) {
          return voronoi(data).polygons();
        };
        voronoi.links = function (data) {
          return voronoi(data).links();
        };
        voronoi.triangles = function (data) {
          return voronoi(data).triangles();
        };
        voronoi.x = function (_) {
          return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$9(+_), voronoi) : x$$1;
        };
        voronoi.y = function (_) {
          return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$9(+_), voronoi) : y$$1;
        };
        voronoi.extent = function (_) {
          return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
        };
        voronoi.size = function (_) {
          return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
        };
        return voronoi;
      };
      var constant$10 = function (x) {
        return function () {
          return x;
        };
      };
      function ZoomEvent(target, type, transform) {
        this.target = target;
        this.type = type;
        this.transform = transform;
      }
      function Transform(k, x, y) {
        this.k = k;
        this.x = x;
        this.y = y;
      }
      Transform.prototype = {
        constructor: Transform,
        scale: function (k) {
          return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
        },
        translate: function (x, y) {
          return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
        },
        apply: function (point) {
          return [point[0] * this.k + this.x, point[1] * this.k + this.y];
        },
        applyX: function (x) {
          return x * this.k + this.x;
        },
        applyY: function (y) {
          return y * this.k + this.y;
        },
        invert: function (location) {
          return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
        },
        invertX: function (x) {
          return (x - this.x) / this.k;
        },
        invertY: function (y) {
          return (y - this.y) / this.k;
        },
        rescaleX: function (x) {
          return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
        },
        rescaleY: function (y) {
          return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
        },
        toString: function () {
          return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
        }
      };
      var identity$6 = new Transform(1, 0, 0);
      transform.prototype = Transform.prototype;
      function transform(node) {
        return node.__zoom || identity$6;
      }
      function nopropagation$1() {
        exports.event.stopImmediatePropagation();
      }
      var noevent$1 = function () {
        exports.event.preventDefault();
        exports.event.stopImmediatePropagation();
      };
      function defaultFilter$1() {
        return !exports.event.button;
      }
      function defaultExtent() {
        var e = this,
            w,
            h;
        if (e instanceof SVGElement) {
          e = e.ownerSVGElement || e;
          w = e.width.baseVal.value;
          h = e.height.baseVal.value;
        } else {
          w = e.clientWidth;
          h = e.clientHeight;
        }
        return [[0, 0], [w, h]];
      }
      function defaultTransform() {
        return this.__zoom || identity$6;
      }
      var zoom = function () {
        var filter = defaultFilter$1,
            extent = defaultExtent,
            k0 = 0,
            k1 = Infinity,
            x0 = -k1,
            x1 = k1,
            y0 = x0,
            y1 = x1,
            duration = 250,
            interpolate$$1 = interpolateZoom,
            gestures = [],
            listeners = dispatch("start", "zoom", "end"),
            touchstarting,
            touchending,
            touchDelay = 500,
            wheelDelay = 150;
        function zoom(selection$$1) {
          selection$$1.on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").property("__zoom", defaultTransform);
        }
        zoom.transform = function (collection, transform) {
          var selection$$1 = collection.selection ? collection.selection() : collection;
          selection$$1.property("__zoom", defaultTransform);
          if (collection !== selection$$1) {
            schedule(collection, transform);
          } else {
            selection$$1.interrupt().each(function () {
              gesture(this, arguments).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
            });
          }
        };
        zoom.scaleBy = function (selection$$1, k) {
          zoom.scaleTo(selection$$1, function () {
            var k0 = this.__zoom.k,
                k1 = typeof k === "function" ? k.apply(this, arguments) : k;
            return k0 * k1;
          });
        };
        zoom.scaleTo = function (selection$$1, k) {
          zoom.transform(selection$$1, function () {
            var e = extent.apply(this, arguments),
                t0 = this.__zoom,
                p0 = centroid(e),
                p1 = t0.invert(p0),
                k1 = typeof k === "function" ? k.apply(this, arguments) : k;
            return constrain(translate(scale(t0, k1), p0, p1), e);
          });
        };
        zoom.translateBy = function (selection$$1, x, y) {
          zoom.transform(selection$$1, function () {
            return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments));
          });
        };
        function scale(transform, k) {
          k = Math.max(k0, Math.min(k1, k));
          return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
        }
        function translate(transform, p0, p1) {
          var x = p0[0] - p1[0] * transform.k,
              y = p0[1] - p1[1] * transform.k;
          return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
        }
        function constrain(transform, extent) {
          var dx0 = transform.invertX(extent[0][0]) - x0,
              dx1 = transform.invertX(extent[1][0]) - x1,
              dy0 = transform.invertY(extent[0][1]) - y0,
              dy1 = transform.invertY(extent[1][1]) - y1;
          return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
        }
        function centroid(extent) {
          return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
        }
        function schedule(transition$$1, transform, center) {
          transition$$1.on("start.zoom", function () {
            gesture(this, arguments).start();
          }).on("interrupt.zoom end.zoom", function () {
            gesture(this, arguments).end();
          }).tween("zoom", function () {
            var that = this,
                args = arguments,
                g = gesture(that, args),
                e = extent.apply(that, args),
                p = center || centroid(e),
                w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
                a = that.__zoom,
                b = typeof transform === "function" ? transform.apply(that, args) : transform,
                i = interpolate$$1(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
            return function (t) {
              if (t === 1) t = b;else {
                var l = i(t),
                    k = w / l[2];
                t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
              }
              g.zoom(null, t);
            };
          });
        }
        function gesture(that, args) {
          for (var i = 0, n = gestures.length, g; i < n; ++i) {
            if ((g = gestures[i]).that === that) {
              return g;
            }
          }
          return new Gesture(that, args);
        }
        function Gesture(that, args) {
          this.that = that;
          this.args = args;
          this.index = -1;
          this.active = 0;
          this.extent = extent.apply(that, args);
        }
        Gesture.prototype = {
          start: function () {
            if (++this.active === 1) {
              this.index = gestures.push(this) - 1;
              this.emit("start");
            }
            return this;
          },
          zoom: function (key, transform) {
            if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
            if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
            if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
            this.that.__zoom = transform;
            this.emit("zoom");
            return this;
          },
          end: function () {
            if (--this.active === 0) {
              gestures.splice(this.index, 1);
              this.index = -1;
              this.emit("end");
            }
            return this;
          },
          emit: function (type) {
            customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
          }
        };
        function wheeled() {
          if (!filter.apply(this, arguments)) return;
          var g = gesture(this, arguments),
              t = this.__zoom,
              k = Math.max(k0, Math.min(k1, t.k * Math.pow(2, -exports.event.deltaY * (exports.event.deltaMode ? 120 : 1) / 500))),
              p = mouse(this);
          if (g.wheel) {
            if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
              g.mouse[1] = t.invert(g.mouse[0] = p);
            }
            clearTimeout(g.wheel);
          } else if (t.k === k) return;else {
            g.mouse = [p, t.invert(p)];
            interrupt(this);
            g.start();
          }
          noevent$1();
          g.wheel = setTimeout(wheelidled, wheelDelay);
          g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent));
          function wheelidled() {
            g.wheel = null;
            g.end();
          }
        }
        function mousedowned() {
          if (touchending || !filter.apply(this, arguments)) return;
          var g = gesture(this, arguments),
              v = select(exports.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
              p = mouse(this);
          dragDisable(exports.event.view);
          nopropagation$1();
          g.mouse = [p, this.__zoom.invert(p)];
          interrupt(this);
          g.start();
          function mousemoved() {
            noevent$1();
            g.moved = true;
            g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent));
          }
          function mouseupped() {
            v.on("mousemove.zoom mouseup.zoom", null);
            yesdrag(exports.event.view, g.moved);
            noevent$1();
            g.end();
          }
        }
        function dblclicked() {
          if (!filter.apply(this, arguments)) return;
          var t0 = this.__zoom,
              p0 = mouse(this),
              p1 = t0.invert(p0),
              k1 = t0.k * (exports.event.shiftKey ? 0.5 : 2),
              t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments));
          noevent$1();
          if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0);else select(this).call(zoom.transform, t1);
        }
        function touchstarted() {
          if (!filter.apply(this, arguments)) return;
          var g = gesture(this, arguments),
              touches$$1 = exports.event.changedTouches,
              n = touches$$1.length,
              i,
              t,
              p;
          nopropagation$1();
          for (i = 0; i < n; ++i) {
            t = touches$$1[i], p = touch(this, touches$$1, t.identifier);
            p = [p, this.__zoom.invert(p), t.identifier];
            if (!g.touch0) g.touch0 = p;else if (!g.touch1) g.touch1 = p;
          }
          if (touchstarting) {
            touchstarting = clearTimeout(touchstarting);
            if (!g.touch1) {
              g.end();
              p = select(this).on("dblclick.zoom");
              if (p) p.apply(this, arguments);
              return;
            }
          }
          if (exports.event.touches.length === n) {
            touchstarting = setTimeout(function () {
              touchstarting = null;
            }, touchDelay);
            interrupt(this);
            g.start();
          }
        }
        function touchmoved() {
          var g = gesture(this, arguments),
              touches$$1 = exports.event.changedTouches,
              n = touches$$1.length,
              i,
              t,
              p,
              l;
          noevent$1();
          if (touchstarting) touchstarting = clearTimeout(touchstarting);
          for (i = 0; i < n; ++i) {
            t = touches$$1[i], p = touch(this, touches$$1, t.identifier);
            if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
          }
          t = g.that.__zoom;
          if (g.touch1) {
            var p0 = g.touch0[0],
                l0 = g.touch0[1],
                p1 = g.touch1[0],
                l1 = g.touch1[1],
                dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
                dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
            t = scale(t, Math.sqrt(dp / dl));
            p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
            l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
          } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];else return;
          g.zoom("touch", constrain(translate(t, p, l), g.extent));
        }
        function touchended() {
          var g = gesture(this, arguments),
              touches$$1 = exports.event.changedTouches,
              n = touches$$1.length,
              i,
              t;
          nopropagation$1();
          if (touchending) clearTimeout(touchending);
          touchending = setTimeout(function () {
            touchending = null;
          }, touchDelay);
          for (i = 0; i < n; ++i) {
            t = touches$$1[i];
            if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
          }
          if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
          if (!g.touch0) g.end();
        }
        zoom.filter = function (_) {
          return arguments.length ? (filter = typeof _ === "function" ? _ : constant$10(!!_), zoom) : filter;
        };
        zoom.extent = function (_) {
          return arguments.length ? (extent = typeof _ === "function" ? _ : constant$10([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
        };
        zoom.scaleExtent = function (_) {
          return arguments.length ? (k0 = +_[0], k1 = +_[1], zoom) : [k0, k1];
        };
        zoom.translateExtent = function (_) {
          return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], zoom) : [[x0, y0], [x1, y1]];
        };
        zoom.duration = function (_) {
          return arguments.length ? (duration = +_, zoom) : duration;
        };
        zoom.interpolate = function (_) {
          return arguments.length ? (interpolate$$1 = _, zoom) : interpolate$$1;
        };
        zoom.on = function () {
          var value = listeners.on.apply(listeners, arguments);
          return value === listeners ? zoom : value;
        };
        return zoom;
      };
      var constant$11 = function (x) {
        return function () {
          return x;
        };
      };
      var BrushEvent = function (target, type, selection) {
        this.target = target;
        this.type = type;
        this.selection = selection;
      };
      function nopropagation$2() {
        exports.event.stopImmediatePropagation();
      }
      var noevent$2 = function () {
        exports.event.preventDefault();
        exports.event.stopImmediatePropagation();
      };
      var MODE_DRAG = { name: "drag" };
      var MODE_SPACE = { name: "space" };
      var MODE_HANDLE = { name: "handle" };
      var MODE_CENTER = { name: "center" };
      var X = {
        name: "x",
        handles: ["e", "w"].map(type$1),
        input: function (x, e) {
          return x && [[x[0], e[0][1]], [x[1], e[1][1]]];
        },
        output: function (xy) {
          return xy && [xy[0][0], xy[1][0]];
        }
      };
      var Y = {
        name: "y",
        handles: ["n", "s"].map(type$1),
        input: function (y, e) {
          return y && [[e[0][0], y[0]], [e[1][0], y[1]]];
        },
        output: function (xy) {
          return xy && [xy[0][1], xy[1][1]];
        }
      };
      var XY = {
        name: "xy",
        handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type$1),
        input: function (xy) {
          return xy;
        },
        output: function (xy) {
          return xy;
        }
      };
      var cursors = {
        overlay: "crosshair",
        selection: "move",
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
      };
      var flipX = {
        e: "w",
        w: "e",
        nw: "ne",
        ne: "nw",
        se: "sw",
        sw: "se"
      };
      var flipY = {
        n: "s",
        s: "n",
        nw: "sw",
        ne: "se",
        se: "ne",
        sw: "nw"
      };
      var signsX = {
        overlay: +1,
        selection: +1,
        n: null,
        e: +1,
        s: null,
        w: -1,
        nw: -1,
        ne: +1,
        se: +1,
        sw: -1
      };
      var signsY = {
        overlay: +1,
        selection: +1,
        n: -1,
        e: null,
        s: +1,
        w: null,
        nw: -1,
        ne: -1,
        se: +1,
        sw: +1
      };
      function type$1(t) {
        return { type: t };
      }
      function defaultFilter$2() {
        return !exports.event.button;
      }
      function defaultExtent$1() {
        var svg = this.ownerSVGElement || this;
        return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
      }
      function local$1(node) {
        while (!node.__brush) if (!(node = node.parentNode)) return;
        return node.__brush;
      }
      function empty$1(extent) {
        return extent[0][0] === extent[1][0] || extent[0][1] === extent[1][1];
      }
      function brushSelection(node) {
        var state = node.__brush;
        return state ? state.dim.output(state.selection) : null;
      }
      function brushX() {
        return brush$1(X);
      }
      function brushY() {
        return brush$1(Y);
      }
      var brush = function () {
        return brush$1(XY);
      };
      function brush$1(dim) {
        var extent = defaultExtent$1,
            filter = defaultFilter$2,
            listeners = dispatch(brush, "start", "brush", "end"),
            handleSize = 6,
            touchending;
        function brush(group) {
          var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type$1("overlay")]);
          overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function () {
            var extent = local$1(this).extent;
            select(this).attr("x", extent[0][0]).attr("y", extent[0][1]).attr("width", extent[1][0] - extent[0][0]).attr("height", extent[1][1] - extent[0][1]);
          });
          group.selectAll(".selection").data([type$1("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
          var handle = group.selectAll(".handle").data(dim.handles, function (d) {
            return d.type;
          });
          handle.exit().remove();
          handle.enter().append("rect").attr("class", function (d) {
            return "handle handle--" + d.type;
          }).attr("cursor", function (d) {
            return cursors[d.type];
          });
          group.each(redraw).attr("fill", "none").attr("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush touchstart.brush", started);
        }
        brush.move = function (group, selection$$1) {
          if (group.selection) {
            group.on("start.brush", function () {
              emitter(this, arguments).beforestart().start();
            }).on("interrupt.brush end.brush", function () {
              emitter(this, arguments).end();
            }).tween("brush", function () {
              var that = this,
                  state = that.__brush,
                  emit = emitter(that, arguments),
                  selection0 = state.selection,
                  selection1 = dim.input(typeof selection$$1 === "function" ? selection$$1.apply(this, arguments) : selection$$1, state.extent),
                  i = interpolate(selection0, selection1);
              function tween(t) {
                state.selection = t === 1 && empty$1(selection1) ? null : i(t);
                redraw.call(that);
                emit.brush();
              }
              return selection0 && selection1 ? tween : tween(1);
            });
          } else {
            group.each(function () {
              var that = this,
                  args = arguments,
                  state = that.__brush,
                  selection1 = dim.input(typeof selection$$1 === "function" ? selection$$1.apply(that, args) : selection$$1, state.extent),
                  emit = emitter(that, args).beforestart();
              interrupt(that);
              state.selection = selection1 == null || empty$1(selection1) ? null : selection1;
              redraw.call(that);
              emit.start().brush().end();
            });
          }
        };
        function redraw() {
          var group = select(this),
              selection$$1 = local$1(this).selection;
          if (selection$$1) {
            group.selectAll(".selection").style("display", null).attr("x", selection$$1[0][0]).attr("y", selection$$1[0][1]).attr("width", selection$$1[1][0] - selection$$1[0][0]).attr("height", selection$$1[1][1] - selection$$1[0][1]);
            group.selectAll(".handle").style("display", null).attr("x", function (d) {
              return d.type[d.type.length - 1] === "e" ? selection$$1[1][0] - handleSize / 2 : selection$$1[0][0] - handleSize / 2;
            }).attr("y", function (d) {
              return d.type[0] === "s" ? selection$$1[1][1] - handleSize / 2 : selection$$1[0][1] - handleSize / 2;
            }).attr("width", function (d) {
              return d.type === "n" || d.type === "s" ? selection$$1[1][0] - selection$$1[0][0] + handleSize : handleSize;
            }).attr("height", function (d) {
              return d.type === "e" || d.type === "w" ? selection$$1[1][1] - selection$$1[0][1] + handleSize : handleSize;
            });
          } else {
            group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
          }
        }
        function emitter(that, args) {
          return that.__brush.emitter || new Emitter(that, args);
        }
        function Emitter(that, args) {
          this.that = that;
          this.args = args;
          this.state = that.__brush;
          this.active = 0;
        }
        Emitter.prototype = {
          beforestart: function () {
            if (++this.active === 1) this.state.emitter = this, this.starting = true;
            return this;
          },
          start: function () {
            if (this.starting) this.starting = false, this.emit("start");
            return this;
          },
          brush: function () {
            this.emit("brush");
            return this;
          },
          end: function () {
            if (--this.active === 0) delete this.state.emitter, this.emit("end");
            return this;
          },
          emit: function (type) {
            customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
          }
        };
        function started() {
          if (exports.event.touches) {
            if (exports.event.changedTouches.length < exports.event.touches.length) return noevent$2();
          } else if (touchending) return;
          if (!filter.apply(this, arguments)) return;
          var that = this,
              type = exports.event.target.__data__.type,
              mode = (exports.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : exports.event.altKey ? MODE_CENTER : MODE_HANDLE,
              signX = dim === Y ? null : signsX[type],
              signY = dim === X ? null : signsY[type],
              state = local$1(that),
              extent = state.extent,
              selection$$1 = state.selection,
              W = extent[0][0],
              w0,
              w1,
              N = extent[0][1],
              n0,
              n1,
              E = extent[1][0],
              e0,
              e1,
              S = extent[1][1],
              s0,
              s1,
              dx,
              dy,
              moving,
              shifting = signX && signY && exports.event.shiftKey,
              lockX,
              lockY,
              point0 = mouse(that),
              point = point0,
              emit = emitter(that, arguments).beforestart();
          if (type === "overlay") {
            state.selection = selection$$1 = [[w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]], [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]];
          } else {
            w0 = selection$$1[0][0];
            n0 = selection$$1[0][1];
            e0 = selection$$1[1][0];
            s0 = selection$$1[1][1];
          }
          w1 = w0;
          n1 = n0;
          e1 = e0;
          s1 = s0;
          var group = select(that).attr("pointer-events", "none");
          var overlay = group.selectAll(".overlay").attr("cursor", cursors[type]);
          if (exports.event.touches) {
            group.on("touchmove.brush", moved, true).on("touchend.brush touchcancel.brush", ended, true);
          } else {
            var view = select(exports.event.view).on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
            dragDisable(exports.event.view);
          }
          nopropagation$2();
          interrupt(that);
          redraw.call(that);
          emit.start();
          function moved() {
            var point1 = mouse(that);
            if (shifting && !lockX && !lockY) {
              if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;else lockX = true;
            }
            point = point1;
            moving = true;
            noevent$2();
            move();
          }
          function move() {
            var t;
            dx = point[0] - point0[0];
            dy = point[1] - point0[1];
            switch (mode) {
              case MODE_SPACE:
              case MODE_DRAG:
                {
                  if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
                  if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
                  break;
                }
              case MODE_HANDLE:
                {
                  if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                  if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
                  break;
                }
              case MODE_CENTER:
                {
                  if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
                  if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
                  break;
                }
            }
            if (e1 < w1) {
              signX *= -1;
              t = w0, w0 = e0, e0 = t;
              t = w1, w1 = e1, e1 = t;
              if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
            }
            if (s1 < n1) {
              signY *= -1;
              t = n0, n0 = s0, s0 = t;
              t = n1, n1 = s1, s1 = t;
              if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
            }
            if (state.selection) selection$$1 = state.selection;
            if (lockX) w1 = selection$$1[0][0], e1 = selection$$1[1][0];
            if (lockY) n1 = selection$$1[0][1], s1 = selection$$1[1][1];
            if (selection$$1[0][0] !== w1 || selection$$1[0][1] !== n1 || selection$$1[1][0] !== e1 || selection$$1[1][1] !== s1) {
              state.selection = [[w1, n1], [e1, s1]];
              redraw.call(that);
              emit.brush();
            }
          }
          function ended() {
            nopropagation$2();
            if (exports.event.touches) {
              if (exports.event.touches.length) return;
              if (touchending) clearTimeout(touchending);
              touchending = setTimeout(function () {
                touchending = null;
              }, 500);
              group.on("touchmove.brush touchend.brush touchcancel.brush", null);
            } else {
              yesdrag(exports.event.view, moving);
              view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
            }
            group.attr("pointer-events", "all");
            overlay.attr("cursor", cursors.overlay);
            if (state.selection) selection$$1 = state.selection;
            if (empty$1(selection$$1)) state.selection = null, redraw.call(that);
            emit.end();
          }
          function keydowned() {
            switch (exports.event.keyCode) {
              case 16:
                {
                  shifting = signX && signY;
                  break;
                }
              case 18:
                {
                  if (mode === MODE_HANDLE) {
                    if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                    if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                    mode = MODE_CENTER;
                    move();
                  }
                  break;
                }
              case 32:
                {
                  if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                    if (signX < 0) e0 = e1 - dx;else if (signX > 0) w0 = w1 - dx;
                    if (signY < 0) s0 = s1 - dy;else if (signY > 0) n0 = n1 - dy;
                    mode = MODE_SPACE;
                    overlay.attr("cursor", cursors.selection);
                    move();
                  }
                  break;
                }
              default:
                return;
            }
            noevent$2();
          }
          function keyupped() {
            switch (exports.event.keyCode) {
              case 16:
                {
                  if (shifting) {
                    lockX = lockY = shifting = false;
                    move();
                  }
                  break;
                }
              case 18:
                {
                  if (mode === MODE_CENTER) {
                    if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
                    if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
                    mode = MODE_HANDLE;
                    move();
                  }
                  break;
                }
              case 32:
                {
                  if (mode === MODE_SPACE) {
                    if (exports.event.altKey) {
                      if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                      if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                      mode = MODE_CENTER;
                    } else {
                      if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
                      if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
                      mode = MODE_HANDLE;
                    }
                    overlay.attr("cursor", cursors[type]);
                    move();
                  }
                  break;
                }
              default:
                return;
            }
            noevent$2();
          }
        }
        function initialize() {
          var state = this.__brush || { selection: null };
          state.extent = extent.apply(this, arguments);
          state.dim = dim;
          return state;
        }
        brush.extent = function (_) {
          return arguments.length ? (extent = typeof _ === "function" ? _ : constant$11([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
        };
        brush.filter = function (_) {
          return arguments.length ? (filter = typeof _ === "function" ? _ : constant$11(!!_), brush) : filter;
        };
        brush.handleSize = function (_) {
          return arguments.length ? (handleSize = +_, brush) : handleSize;
        };
        brush.on = function () {
          var value = listeners.on.apply(listeners, arguments);
          return value === listeners ? brush : value;
        };
        return brush;
      }
      var cos = Math.cos;
      var sin = Math.sin;
      var pi$3 = Math.PI;
      var halfPi$2 = pi$3 / 2;
      var tau$3 = pi$3 * 2;
      var max$1 = Math.max;
      function compareValue(compare) {
        return function (a, b) {
          return compare(a.source.value + a.target.value, b.source.value + b.target.value);
        };
      }
      var chord = function () {
        var padAngle = 0,
            sortGroups = null,
            sortSubgroups = null,
            sortChords = null;
        function chord(matrix) {
          var n = matrix.length,
              groupSums = [],
              groupIndex = range(n),
              subgroupIndex = [],
              chords = [],
              groups = chords.groups = new Array(n),
              subgroups = new Array(n * n),
              k,
              x,
              x0,
              dx,
              i,
              j;
          k = 0, i = -1;
          while (++i < n) {
            x = 0, j = -1;
            while (++j < n) {
              x += matrix[i][j];
            }
            groupSums.push(x);
            subgroupIndex.push(range(n));
            k += x;
          }
          if (sortGroups) groupIndex.sort(function (a, b) {
            return sortGroups(groupSums[a], groupSums[b]);
          });
          if (sortSubgroups) subgroupIndex.forEach(function (d, i) {
            d.sort(function (a, b) {
              return sortSubgroups(matrix[i][a], matrix[i][b]);
            });
          });
          k = max$1(0, tau$3 - padAngle * n) / k;
          dx = k ? padAngle : tau$3 / n;
          x = 0, i = -1;
          while (++i < n) {
            x0 = x, j = -1;
            while (++j < n) {
              var di = groupIndex[i],
                  dj = subgroupIndex[di][j],
                  v = matrix[di][dj],
                  a0 = x,
                  a1 = x += v * k;
              subgroups[dj * n + di] = {
                index: di,
                subindex: dj,
                startAngle: a0,
                endAngle: a1,
                value: v
              };
            }
            groups[di] = {
              index: di,
              startAngle: x0,
              endAngle: x,
              value: groupSums[di]
            };
            x += dx;
          }
          i = -1;
          while (++i < n) {
            j = i - 1;
            while (++j < n) {
              var source = subgroups[j * n + i],
                  target = subgroups[i * n + j];
              if (source.value || target.value) {
                chords.push(source.value < target.value ? {
                  source: target,
                  target: source
                } : {
                  source: source,
                  target: target
                });
              }
            }
          }
          return sortChords ? chords.sort(sortChords) : chords;
        }
        chord.padAngle = function (_) {
          return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
        };
        chord.sortGroups = function (_) {
          return arguments.length ? (sortGroups = _, chord) : sortGroups;
        };
        chord.sortSubgroups = function (_) {
          return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
        };
        chord.sortChords = function (_) {
          return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
        };
        return chord;
      };
      var slice$5 = Array.prototype.slice;
      var constant$12 = function (x) {
        return function () {
          return x;
        };
      };
      function defaultSource(d) {
        return d.source;
      }
      function defaultTarget(d) {
        return d.target;
      }
      function defaultRadius$1(d) {
        return d.radius;
      }
      function defaultStartAngle(d) {
        return d.startAngle;
      }
      function defaultEndAngle(d) {
        return d.endAngle;
      }
      var ribbon = function () {
        var source = defaultSource,
            target = defaultTarget,
            radius = defaultRadius$1,
            startAngle = defaultStartAngle,
            endAngle = defaultEndAngle,
            context = null;
        function ribbon() {
          var buffer,
              argv = slice$5.call(arguments),
              s = source.apply(this, argv),
              t = target.apply(this, argv),
              sr = +radius.apply(this, (argv[0] = s, argv)),
              sa0 = startAngle.apply(this, argv) - halfPi$2,
              sa1 = endAngle.apply(this, argv) - halfPi$2,
              sx0 = sr * cos(sa0),
              sy0 = sr * sin(sa0),
              tr = +radius.apply(this, (argv[0] = t, argv)),
              ta0 = startAngle.apply(this, argv) - halfPi$2,
              ta1 = endAngle.apply(this, argv) - halfPi$2;
          if (!context) context = buffer = path();
          context.moveTo(sx0, sy0);
          context.arc(0, 0, sr, sa0, sa1);
          if (sa0 !== ta0 || sa1 !== ta1) {
            context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
            context.arc(0, 0, tr, ta0, ta1);
          }
          context.quadraticCurveTo(0, 0, sx0, sy0);
          context.closePath();
          if (buffer) return context = null, buffer + "" || null;
        }
        ribbon.radius = function (_) {
          return arguments.length ? (radius = typeof _ === "function" ? _ : constant$12(+_), ribbon) : radius;
        };
        ribbon.startAngle = function (_) {
          return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$12(+_), ribbon) : startAngle;
        };
        ribbon.endAngle = function (_) {
          return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$12(+_), ribbon) : endAngle;
        };
        ribbon.source = function (_) {
          return arguments.length ? (source = _, ribbon) : source;
        };
        ribbon.target = function (_) {
          return arguments.length ? (target = _, ribbon) : target;
        };
        ribbon.context = function (_) {
          return arguments.length ? (context = _ == null ? null : _, ribbon) : context;
        };
        return ribbon;
      };
      var adder = function () {
        return new Adder();
      };
      function Adder() {
        this.reset();
      }
      Adder.prototype = {
        constructor: Adder,
        reset: function () {
          this.s = this.t = 0;
        },
        add: function (y) {
          add$1(temp, y, this.t);
          add$1(this, temp.s, this.s);
          if (this.s) this.t += temp.t;else this.s = temp.t;
        },
        valueOf: function () {
          return this.s;
        }
      };
      var temp = new Adder();
      function add$1(adder, a, b) {
        var x = adder.s = a + b,
            bv = x - a,
            av = x - bv;
        adder.t = a - av + (b - bv);
      }
      var epsilon$4 = 1e-6;
      var epsilon2$2 = 1e-12;
      var pi$4 = Math.PI;
      var halfPi$3 = pi$4 / 2;
      var quarterPi = pi$4 / 4;
      var tau$4 = pi$4 * 2;
      var degrees$1 = 180 / pi$4;
      var radians = pi$4 / 180;
      var abs = Math.abs;
      var atan = Math.atan;
      var atan2 = Math.atan2;
      var cos$1 = Math.cos;
      var ceil = Math.ceil;
      var exp = Math.exp;
      var log$1 = Math.log;
      var pow$1 = Math.pow;
      var sin$1 = Math.sin;
      var sign$1 = Math.sign || function (x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
      };
      var sqrt$1 = Math.sqrt;
      var tan = Math.tan;
      function acos(x) {
        return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);
      }
      function asin$1(x) {
        return x > 1 ? halfPi$3 : x < -1 ? -halfPi$3 : Math.asin(x);
      }
      function haversin(x) {
        return (x = sin$1(x / 2)) * x;
      }
      function noop$2() {}
      function streamGeometry(geometry, stream) {
        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
          streamGeometryType[geometry.type](geometry, stream);
        }
      }
      var streamObjectType = {
        Feature: function (feature, stream) {
          streamGeometry(feature.geometry, stream);
        },
        FeatureCollection: function (object, stream) {
          var features = object.features,
              i = -1,
              n = features.length;
          while (++i < n) streamGeometry(features[i].geometry, stream);
        }
      };
      var streamGeometryType = {
        Sphere: function (object, stream) {
          stream.sphere();
        },
        Point: function (object, stream) {
          object = object.coordinates;
          stream.point(object[0], object[1], object[2]);
        },
        MultiPoint: function (object, stream) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
        },
        LineString: function (object, stream) {
          streamLine(object.coordinates, stream, 0);
        },
        MultiLineString: function (object, stream) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n) streamLine(coordinates[i], stream, 0);
        },
        Polygon: function (object, stream) {
          streamPolygon(object.coordinates, stream);
        },
        MultiPolygon: function (object, stream) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n) streamPolygon(coordinates[i], stream);
        },
        GeometryCollection: function (object, stream) {
          var geometries = object.geometries,
              i = -1,
              n = geometries.length;
          while (++i < n) streamGeometry(geometries[i], stream);
        }
      };
      function streamLine(coordinates, stream, closed) {
        var i = -1,
            n = coordinates.length - closed,
            coordinate;
        stream.lineStart();
        while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
        stream.lineEnd();
      }
      function streamPolygon(coordinates, stream) {
        var i = -1,
            n = coordinates.length;
        stream.polygonStart();
        while (++i < n) streamLine(coordinates[i], stream, 1);
        stream.polygonEnd();
      }
      var geoStream = function (object, stream) {
        if (object && streamObjectType.hasOwnProperty(object.type)) {
          streamObjectType[object.type](object, stream);
        } else {
          streamGeometry(object, stream);
        }
      };
      var areaRingSum = adder();
      var areaSum = adder();
      var lambda00;
      var phi00;
      var lambda0;
      var cosPhi0;
      var sinPhi0;
      var areaStream = {
        point: noop$2,
        lineStart: noop$2,
        lineEnd: noop$2,
        polygonStart: function () {
          areaRingSum.reset();
          areaStream.lineStart = areaRingStart;
          areaStream.lineEnd = areaRingEnd;
        },
        polygonEnd: function () {
          var areaRing = +areaRingSum;
          areaSum.add(areaRing < 0 ? tau$4 + areaRing : areaRing);
          this.lineStart = this.lineEnd = this.point = noop$2;
        },
        sphere: function () {
          areaSum.add(tau$4);
        }
      };
      function areaRingStart() {
        areaStream.point = areaPointFirst;
      }
      function areaRingEnd() {
        areaPoint(lambda00, phi00);
      }
      function areaPointFirst(lambda, phi) {
        areaStream.point = areaPoint;
        lambda00 = lambda, phi00 = phi;
        lambda *= radians, phi *= radians;
        lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);
      }
      function areaPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        phi = phi / 2 + quarterPi;
        var dLambda = lambda - lambda0,
            sdLambda = dLambda >= 0 ? 1 : -1,
            adLambda = sdLambda * dLambda,
            cosPhi = cos$1(phi),
            sinPhi = sin$1(phi),
            k = sinPhi0 * sinPhi,
            u = cosPhi0 * cosPhi + k * cos$1(adLambda),
            v = k * sdLambda * sin$1(adLambda);
        areaRingSum.add(atan2(v, u));
        lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
      }
      var area$2 = function (object) {
        areaSum.reset();
        geoStream(object, areaStream);
        return areaSum * 2;
      };
      function spherical(cartesian) {
        return [atan2(cartesian[1], cartesian[0]), asin$1(cartesian[2])];
      }
      function cartesian(spherical) {
        var lambda = spherical[0],
            phi = spherical[1],
            cosPhi = cos$1(phi);
        return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
      }
      function cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }
      function cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }
      function cartesianAddInPlace(a, b) {
        a[0] += b[0], a[1] += b[1], a[2] += b[2];
      }
      function cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
      }
      function cartesianNormalizeInPlace(d) {
        var l = sqrt$1(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l, d[1] /= l, d[2] /= l;
      }
      var lambda0$1;
      var phi0;
      var lambda1;
      var phi1;
      var lambda2;
      var lambda00$1;
      var phi00$1;
      var p0;
      var deltaSum = adder();
      var ranges;
      var range$1;
      var boundsStream = {
        point: boundsPoint,
        lineStart: boundsLineStart,
        lineEnd: boundsLineEnd,
        polygonStart: function () {
          boundsStream.point = boundsRingPoint;
          boundsStream.lineStart = boundsRingStart;
          boundsStream.lineEnd = boundsRingEnd;
          deltaSum.reset();
          areaStream.polygonStart();
        },
        polygonEnd: function () {
          areaStream.polygonEnd();
          boundsStream.point = boundsPoint;
          boundsStream.lineStart = boundsLineStart;
          boundsStream.lineEnd = boundsLineEnd;
          if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > epsilon$4) phi1 = 90;else if (deltaSum < -epsilon$4) phi0 = -90;
          range$1[0] = lambda0$1, range$1[1] = lambda1;
        }
      };
      function boundsPoint(lambda, phi) {
        ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
        if (phi < phi0) phi0 = phi;
        if (phi > phi1) phi1 = phi;
      }
      function linePoint(lambda, phi) {
        var p = cartesian([lambda * radians, phi * radians]);
        if (p0) {
          var normal = cartesianCross(p0, p),
              equatorial = [normal[1], -normal[0], 0],
              inflection = cartesianCross(equatorial, normal);
          cartesianNormalizeInPlace(inflection);
          inflection = spherical(inflection);
          var delta = lambda - lambda2,
              sign$$1 = delta > 0 ? 1 : -1,
              lambdai = inflection[0] * degrees$1 * sign$$1,
              phii,
              antimeridian = abs(delta) > 180;
          if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
            phii = inflection[1] * degrees$1;
            if (phii > phi1) phi1 = phii;
          } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
            phii = -inflection[1] * degrees$1;
            if (phii < phi0) phi0 = phii;
          } else {
            if (phi < phi0) phi0 = phi;
            if (phi > phi1) phi1 = phi;
          }
          if (antimeridian) {
            if (lambda < lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          } else {
            if (lambda1 >= lambda0$1) {
              if (lambda < lambda0$1) lambda0$1 = lambda;
              if (lambda > lambda1) lambda1 = lambda;
            } else {
              if (lambda > lambda2) {
                if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
              } else {
                if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
              }
            }
          }
        } else {
          boundsPoint(lambda, phi);
        }
        p0 = p, lambda2 = lambda;
      }
      function boundsLineStart() {
        boundsStream.point = linePoint;
      }
      function boundsLineEnd() {
        range$1[0] = lambda0$1, range$1[1] = lambda1;
        boundsStream.point = boundsPoint;
        p0 = null;
      }
      function boundsRingPoint(lambda, phi) {
        if (p0) {
          var delta = lambda - lambda2;
          deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
        } else {
          lambda00$1 = lambda, phi00$1 = phi;
        }
        areaStream.point(lambda, phi);
        linePoint(lambda, phi);
      }
      function boundsRingStart() {
        areaStream.lineStart();
      }
      function boundsRingEnd() {
        boundsRingPoint(lambda00$1, phi00$1);
        areaStream.lineEnd();
        if (abs(deltaSum) > epsilon$4) lambda0$1 = -(lambda1 = 180);
        range$1[0] = lambda0$1, range$1[1] = lambda1;
        p0 = null;
      }
      function angle(lambda0, lambda1) {
        return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
      }
      function rangeCompare(a, b) {
        return a[0] - b[0];
      }
      function rangeContains(range, x) {
        return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
      }
      var bounds = function (feature) {
        var i, n, a, b, merged, deltaMax, delta;
        phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
        ranges = [];
        geoStream(feature, boundsStream);
        if (n = ranges.length) {
          ranges.sort(rangeCompare);
          for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
            b = ranges[i];
            if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
              if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
              if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
            } else {
              merged.push(a = b);
            }
          }
          for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
            b = merged[i];
            if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
          }
        }
        ranges = range$1 = null;
        return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
      };
      var W0;
      var W1;
      var X0;
      var Y0;
      var Z0;
      var X1;
      var Y1;
      var Z1;
      var X2;
      var Y2;
      var Z2;
      var lambda00$2;
      var phi00$2;
      var x0;
      var y0;
      var z0;
      var centroidStream = {
        sphere: noop$2,
        point: centroidPoint,
        lineStart: centroidLineStart,
        lineEnd: centroidLineEnd,
        polygonStart: function () {
          centroidStream.lineStart = centroidRingStart;
          centroidStream.lineEnd = centroidRingEnd;
        },
        polygonEnd: function () {
          centroidStream.lineStart = centroidLineStart;
          centroidStream.lineEnd = centroidLineEnd;
        }
      };
      function centroidPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos$1(phi);
        centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
      }
      function centroidPointCartesian(x, y, z) {
        ++W0;
        X0 += (x - X0) / W0;
        Y0 += (y - Y0) / W0;
        Z0 += (z - Z0) / W0;
      }
      function centroidLineStart() {
        centroidStream.point = centroidLinePointFirst;
      }
      function centroidLinePointFirst(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos$1(phi);
        x0 = cosPhi * cos$1(lambda);
        y0 = cosPhi * sin$1(lambda);
        z0 = sin$1(phi);
        centroidStream.point = centroidLinePoint;
        centroidPointCartesian(x0, y0, z0);
      }
      function centroidLinePoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos$1(phi),
            x = cosPhi * cos$1(lambda),
            y = cosPhi * sin$1(lambda),
            z = sin$1(phi),
            w = atan2(sqrt$1((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
        W1 += w;
        X1 += w * (x0 + (x0 = x));
        Y1 += w * (y0 + (y0 = y));
        Z1 += w * (z0 + (z0 = z));
        centroidPointCartesian(x0, y0, z0);
      }
      function centroidLineEnd() {
        centroidStream.point = centroidPoint;
      }
      function centroidRingStart() {
        centroidStream.point = centroidRingPointFirst;
      }
      function centroidRingEnd() {
        centroidRingPoint(lambda00$2, phi00$2);
        centroidStream.point = centroidPoint;
      }
      function centroidRingPointFirst(lambda, phi) {
        lambda00$2 = lambda, phi00$2 = phi;
        lambda *= radians, phi *= radians;
        centroidStream.point = centroidRingPoint;
        var cosPhi = cos$1(phi);
        x0 = cosPhi * cos$1(lambda);
        y0 = cosPhi * sin$1(lambda);
        z0 = sin$1(phi);
        centroidPointCartesian(x0, y0, z0);
      }
      function centroidRingPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos$1(phi),
            x = cosPhi * cos$1(lambda),
            y = cosPhi * sin$1(lambda),
            z = sin$1(phi),
            cx = y0 * z - z0 * y,
            cy = z0 * x - x0 * z,
            cz = x0 * y - y0 * x,
            m = sqrt$1(cx * cx + cy * cy + cz * cz),
            u = x0 * x + y0 * y + z0 * z,
            v = m && -acos(u) / m,
            w = atan2(m, u);
        X2 += v * cx;
        Y2 += v * cy;
        Z2 += v * cz;
        W1 += w;
        X1 += w * (x0 + (x0 = x));
        Y1 += w * (y0 + (y0 = y));
        Z1 += w * (z0 + (z0 = z));
        centroidPointCartesian(x0, y0, z0);
      }
      var centroid$1 = function (object) {
        W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
        geoStream(object, centroidStream);
        var x = X2,
            y = Y2,
            z = Z2,
            m = x * x + y * y + z * z;
        if (m < epsilon2$2) {
          x = X1, y = Y1, z = Z1;
          if (W1 < epsilon$4) x = X0, y = Y0, z = Z0;
          m = x * x + y * y + z * z;
          if (m < epsilon2$2) return [NaN, NaN];
        }
        return [atan2(y, x) * degrees$1, asin$1(z / sqrt$1(m)) * degrees$1];
      };
      var constant$13 = function (x) {
        return function () {
          return x;
        };
      };
      var compose = function (a, b) {
        function compose(x, y) {
          return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert) compose.invert = function (x, y) {
          return x = b.invert(x, y), x && a.invert(x[0], x[1]);
        };
        return compose;
      };
      function rotationIdentity(lambda, phi) {
        return [lambda > pi$4 ? lambda - tau$4 : lambda < -pi$4 ? lambda + tau$4 : lambda, phi];
      }
      rotationIdentity.invert = rotationIdentity;
      function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
        return (deltaLambda %= tau$4) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
      }
      function forwardRotationLambda(deltaLambda) {
        return function (lambda, phi) {
          return lambda += deltaLambda, [lambda > pi$4 ? lambda - tau$4 : lambda < -pi$4 ? lambda + tau$4 : lambda, phi];
        };
      }
      function rotationLambda(deltaLambda) {
        var rotation = forwardRotationLambda(deltaLambda);
        rotation.invert = forwardRotationLambda(-deltaLambda);
        return rotation;
      }
      function rotationPhiGamma(deltaPhi, deltaGamma) {
        var cosDeltaPhi = cos$1(deltaPhi),
            sinDeltaPhi = sin$1(deltaPhi),
            cosDeltaGamma = cos$1(deltaGamma),
            sinDeltaGamma = sin$1(deltaGamma);
        function rotation(lambda, phi) {
          var cosPhi = cos$1(phi),
              x = cos$1(lambda) * cosPhi,
              y = sin$1(lambda) * cosPhi,
              z = sin$1(phi),
              k = z * cosDeltaPhi + x * sinDeltaPhi;
          return [atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), asin$1(k * cosDeltaGamma + y * sinDeltaGamma)];
        }
        rotation.invert = function (lambda, phi) {
          var cosPhi = cos$1(phi),
              x = cos$1(lambda) * cosPhi,
              y = sin$1(lambda) * cosPhi,
              z = sin$1(phi),
              k = z * cosDeltaGamma - y * sinDeltaGamma;
          return [atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), asin$1(k * cosDeltaPhi - x * sinDeltaPhi)];
        };
        return rotation;
      }
      var rotation = function (rotate) {
        rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
        function forward(coordinates) {
          coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
          return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
        }
        forward.invert = function (coordinates) {
          coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
          return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
        };
        return forward;
      };
      function circleStream(stream, radius, delta, direction, t0, t1) {
        if (!delta) return;
        var cosRadius = cos$1(radius),
            sinRadius = sin$1(radius),
            step = direction * delta;
        if (t0 == null) {
          t0 = radius + direction * tau$4;
          t1 = radius - step / 2;
        } else {
          t0 = circleRadius(cosRadius, t0);
          t1 = circleRadius(cosRadius, t1);
          if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$4;
        }
        for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
          point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
          stream.point(point[0], point[1]);
        }
      }
      function circleRadius(cosRadius, point) {
        point = cartesian(point), point[0] -= cosRadius;
        cartesianNormalizeInPlace(point);
        var radius = acos(-point[1]);
        return ((-point[2] < 0 ? -radius : radius) + tau$4 - epsilon$4) % tau$4;
      }
      var circle$1 = function () {
        var center = constant$13([0, 0]),
            radius = constant$13(90),
            precision = constant$13(6),
            ring,
            rotate,
            stream = { point: point };
        function point(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= degrees$1, x[1] *= degrees$1;
        }
        function circle() {
          var c = center.apply(this, arguments),
              r = radius.apply(this, arguments) * radians,
              p = precision.apply(this, arguments) * radians;
          ring = [];
          rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
          circleStream(stream, r, p, 1);
          c = {
            type: "Polygon",
            coordinates: [ring]
          };
          ring = rotate = null;
          return c;
        }
        circle.center = function (_) {
          return arguments.length ? (center = typeof _ === "function" ? _ : constant$13([+_[0], +_[1]]), circle) : center;
        };
        circle.radius = function (_) {
          return arguments.length ? (radius = typeof _ === "function" ? _ : constant$13(+_), circle) : radius;
        };
        circle.precision = function (_) {
          return arguments.length ? (precision = typeof _ === "function" ? _ : constant$13(+_), circle) : precision;
        };
        return circle;
      };
      var clipBuffer = function () {
        var lines = [],
            line;
        return {
          point: function (x, y) {
            line.push([x, y]);
          },
          lineStart: function () {
            lines.push(line = []);
          },
          lineEnd: noop$2,
          rejoin: function () {
            if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
          },
          result: function () {
            var result = lines;
            lines = [];
            line = null;
            return result;
          }
        };
      };
      var clipLine = function (a, b, x0, y0, x1, y1) {
        var ax = a[0],
            ay = a[1],
            bx = b[0],
            by = b[1],
            t0 = 0,
            t1 = 1,
            dx = bx - ax,
            dy = by - ay,
            r;
        r = x0 - ax;
        if (!dx && r > 0) return;
        r /= dx;
        if (dx < 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        } else if (dx > 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        }
        r = x1 - ax;
        if (!dx && r < 0) return;
        r /= dx;
        if (dx < 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        } else if (dx > 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        }
        r = y0 - ay;
        if (!dy && r > 0) return;
        r /= dy;
        if (dy < 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        } else if (dy > 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        }
        r = y1 - ay;
        if (!dy && r < 0) return;
        r /= dy;
        if (dy < 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        } else if (dy > 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        }
        if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
        if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
        return true;
      };
      var pointEqual = function (a, b) {
        return abs(a[0] - b[0]) < epsilon$4 && abs(a[1] - b[1]) < epsilon$4;
      };
      function Intersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
      }
      var clipPolygon = function (segments, compareIntersection, startInside, interpolate, stream) {
        var subject = [],
            clip = [],
            i,
            n;
        segments.forEach(function (segment) {
          if ((n = segment.length - 1) <= 0) return;
          var n,
              p0 = segment[0],
              p1 = segment[n],
              x;
          if (pointEqual(p0, p1)) {
            stream.lineStart();
            for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          subject.push(x = new Intersection(p0, segment, null, true));
          clip.push(x.o = new Intersection(p0, null, x, false));
          subject.push(x = new Intersection(p1, segment, null, false));
          clip.push(x.o = new Intersection(p1, null, x, true));
        });
        if (!subject.length) return;
        clip.sort(compareIntersection);
        link$1(subject);
        link$1(clip);
        for (i = 0, n = clip.length; i < n; ++i) {
          clip[i].e = startInside = !startInside;
        }
        var start = subject[0],
            points,
            point;
        while (1) {
          var current = start,
              isSubject = true;
          while (current.v) if ((current = current.n) === start) return;
          points = current.z;
          stream.lineStart();
          do {
            current.v = current.o.v = true;
            if (current.e) {
              if (isSubject) {
                for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.n.x, 1, stream);
              }
              current = current.n;
            } else {
              if (isSubject) {
                points = current.p.z;
                for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.p.x, -1, stream);
              }
              current = current.p;
            }
            current = current.o;
            points = current.z;
            isSubject = !isSubject;
          } while (!current.v);
          stream.lineEnd();
        }
      };
      function link$1(array) {
        if (!(n = array.length)) return;
        var n,
            i = 0,
            a = array[0],
            b;
        while (++i < n) {
          a.n = b = array[i];
          b.p = a;
          a = b;
        }
        a.n = b = array[0];
        b.p = a;
      }
      var clipMax = 1e9;
      var clipMin = -clipMax;
      function clipExtent(x0, y0, x1, y1) {
        function visible(x, y) {
          return x0 <= x && x <= x1 && y0 <= y && y <= y1;
        }
        function interpolate(from, to, direction, stream) {
          var a = 0,
              a1 = 0;
          if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
            do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0); while ((a = (a + direction + 4) % 4) !== a1);
          } else {
            stream.point(to[0], to[1]);
          }
        }
        function corner(p, direction) {
          return abs(p[0] - x0) < epsilon$4 ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < epsilon$4 ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < epsilon$4 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compareIntersection(a, b) {
          return comparePoint(a.x, b.x);
        }
        function comparePoint(a, b) {
          var ca = corner(a, 1),
              cb = corner(b, 1);
          return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
        return function (stream) {
          var activeStream = stream,
              bufferStream = clipBuffer(),
              segments,
              polygon,
              ring,
              x__,
              y__,
              v__,
              x_,
              y_,
              v_,
              first,
              clean;
          var clipStream = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: polygonStart,
            polygonEnd: polygonEnd
          };
          function point(x, y) {
            if (visible(x, y)) activeStream.point(x, y);
          }
          function polygonInside() {
            var winding = 0;
            for (var i = 0, n = polygon.length; i < n; ++i) {
              for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
                a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
                if (a1 <= y1) {
                  if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;
                } else {
                  if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;
                }
              }
            }
            return winding;
          }
          function polygonStart() {
            activeStream = bufferStream, segments = [], polygon = [], clean = true;
          }
          function polygonEnd() {
            var startInside = polygonInside(),
                cleanInside = clean && startInside,
                visible = (segments = merge(segments)).length;
            if (cleanInside || visible) {
              stream.polygonStart();
              if (cleanInside) {
                stream.lineStart();
                interpolate(null, null, 1, stream);
                stream.lineEnd();
              }
              if (visible) {
                clipPolygon(segments, compareIntersection, startInside, interpolate, stream);
              }
              stream.polygonEnd();
            }
            activeStream = stream, segments = polygon = ring = null;
          }
          function lineStart() {
            clipStream.point = linePoint;
            if (polygon) polygon.push(ring = []);
            first = true;
            v_ = false;
            x_ = y_ = NaN;
          }
          function lineEnd() {
            if (segments) {
              linePoint(x__, y__);
              if (v__ && v_) bufferStream.rejoin();
              segments.push(bufferStream.result());
            }
            clipStream.point = point;
            if (v_) activeStream.lineEnd();
          }
          function linePoint(x, y) {
            var v = visible(x, y);
            if (polygon) ring.push([x, y]);
            if (first) {
              x__ = x, y__ = y, v__ = v;
              first = false;
              if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
              }
            } else {
              if (v && v_) activeStream.point(x, y);else {
                var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                    b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
                if (clipLine(a, b, x0, y0, x1, y1)) {
                  if (!v_) {
                    activeStream.lineStart();
                    activeStream.point(a[0], a[1]);
                  }
                  activeStream.point(b[0], b[1]);
                  if (!v) activeStream.lineEnd();
                  clean = false;
                } else if (v) {
                  activeStream.lineStart();
                  activeStream.point(x, y);
                  clean = false;
                }
              }
            }
            x_ = x, y_ = y, v_ = v;
          }
          return clipStream;
        };
      }
      var extent$1 = function () {
        var x0 = 0,
            y0 = 0,
            x1 = 960,
            y1 = 500,
            cache,
            cacheStream,
            clip;
        return clip = {
          stream: function (stream) {
            return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);
          },
          extent: function (_) {
            return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
          }
        };
      };
      var lengthSum = adder();
      var lambda0$2;
      var sinPhi0$1;
      var cosPhi0$1;
      var lengthStream = {
        sphere: noop$2,
        point: noop$2,
        lineStart: lengthLineStart,
        lineEnd: noop$2,
        polygonStart: noop$2,
        polygonEnd: noop$2
      };
      function lengthLineStart() {
        lengthStream.point = lengthPointFirst;
        lengthStream.lineEnd = lengthLineEnd;
      }
      function lengthLineEnd() {
        lengthStream.point = lengthStream.lineEnd = noop$2;
      }
      function lengthPointFirst(lambda, phi) {
        lambda *= radians, phi *= radians;
        lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);
        lengthStream.point = lengthPoint;
      }
      function lengthPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var sinPhi = sin$1(phi),
            cosPhi = cos$1(phi),
            delta = abs(lambda - lambda0$2),
            cosDelta = cos$1(delta),
            sinDelta = sin$1(delta),
            x = cosPhi * sinDelta,
            y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
            z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
        lengthSum.add(atan2(sqrt$1(x * x + y * y), z));
        lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
      }
      var length$2 = function (object) {
        lengthSum.reset();
        geoStream(object, lengthStream);
        return +lengthSum;
      };
      var coordinates = [null, null];
      var object$1 = {
        type: "LineString",
        coordinates: coordinates
      };
      var distance = function (a, b) {
        coordinates[0] = a;
        coordinates[1] = b;
        return length$2(object$1);
      };
      function graticuleX(y0, y1, dy) {
        var y = range(y0, y1 - epsilon$4, dy).concat(y1);
        return function (x) {
          return y.map(function (y) {
            return [x, y];
          });
        };
      }
      function graticuleY(x0, x1, dx) {
        var x = range(x0, x1 - epsilon$4, dx).concat(x1);
        return function (y) {
          return x.map(function (x) {
            return [x, y];
          });
        };
      }
      function graticule() {
        var x1,
            x0,
            X1,
            X0,
            y1,
            y0,
            Y1,
            Y0,
            dx = 10,
            dy = dx,
            DX = 90,
            DY = 360,
            x,
            y,
            X,
            Y,
            precision = 2.5;
        function graticule() {
          return {
            type: "MultiLineString",
            coordinates: lines()
          };
        }
        function lines() {
          return range(ceil(X0 / DX) * DX, X1, DX).map(X).concat(range(ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(range(ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
            return abs(x % DX) > epsilon$4;
          }).map(x)).concat(range(ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
            return abs(y % DY) > epsilon$4;
          }).map(y));
        }
        graticule.lines = function () {
          return lines().map(function (coordinates) {
            return {
              type: "LineString",
              coordinates: coordinates
            };
          });
        };
        graticule.outline = function () {
          return {
            type: "Polygon",
            coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
          };
        };
        graticule.extent = function (_) {
          if (!arguments.length) return graticule.extentMinor();
          return graticule.extentMajor(_).extentMinor(_);
        };
        graticule.extentMajor = function (_) {
          if (!arguments.length) return [[X0, Y0], [X1, Y1]];
          X0 = +_[0][0], X1 = +_[1][0];
          Y0 = +_[0][1], Y1 = +_[1][1];
          if (X0 > X1) _ = X0, X0 = X1, X1 = _;
          if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
          return graticule.precision(precision);
        };
        graticule.extentMinor = function (_) {
          if (!arguments.length) return [[x0, y0], [x1, y1]];
          x0 = +_[0][0], x1 = +_[1][0];
          y0 = +_[0][1], y1 = +_[1][1];
          if (x0 > x1) _ = x0, x0 = x1, x1 = _;
          if (y0 > y1) _ = y0, y0 = y1, y1 = _;
          return graticule.precision(precision);
        };
        graticule.step = function (_) {
          if (!arguments.length) return graticule.stepMinor();
          return graticule.stepMajor(_).stepMinor(_);
        };
        graticule.stepMajor = function (_) {
          if (!arguments.length) return [DX, DY];
          DX = +_[0], DY = +_[1];
          return graticule;
        };
        graticule.stepMinor = function (_) {
          if (!arguments.length) return [dx, dy];
          dx = +_[0], dy = +_[1];
          return graticule;
        };
        graticule.precision = function (_) {
          if (!arguments.length) return precision;
          precision = +_;
          x = graticuleX(y0, y1, 90);
          y = graticuleY(x0, x1, precision);
          X = graticuleX(Y0, Y1, 90);
          Y = graticuleY(X0, X1, precision);
          return graticule;
        };
        return graticule.extentMajor([[-180, -90 + epsilon$4], [180, 90 - epsilon$4]]).extentMinor([[-180, -80 - epsilon$4], [180, 80 + epsilon$4]]);
      }
      function graticule10() {
        return graticule()();
      }
      var interpolate$2 = function (a, b) {
        var x0 = a[0] * radians,
            y0 = a[1] * radians,
            x1 = b[0] * radians,
            y1 = b[1] * radians,
            cy0 = cos$1(y0),
            sy0 = sin$1(y0),
            cy1 = cos$1(y1),
            sy1 = sin$1(y1),
            kx0 = cy0 * cos$1(x0),
            ky0 = cy0 * sin$1(x0),
            kx1 = cy1 * cos$1(x1),
            ky1 = cy1 * sin$1(x1),
            d = 2 * asin$1(sqrt$1(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
            k = sin$1(d);
        var interpolate = d ? function (t) {
          var B = sin$1(t *= d) / k,
              A = sin$1(d - t) / k,
              x = A * kx0 + B * kx1,
              y = A * ky0 + B * ky1,
              z = A * sy0 + B * sy1;
          return [atan2(y, x) * degrees$1, atan2(z, sqrt$1(x * x + y * y)) * degrees$1];
        } : function () {
          return [x0 * degrees$1, y0 * degrees$1];
        };
        interpolate.distance = d;
        return interpolate;
      };
      var identity$7 = function (x) {
        return x;
      };
      var areaSum$1 = adder();
      var areaRingSum$1 = adder();
      var x00;
      var y00;
      var x0$1;
      var y0$1;
      var areaStream$1 = {
        point: noop$2,
        lineStart: noop$2,
        lineEnd: noop$2,
        polygonStart: function () {
          areaStream$1.lineStart = areaRingStart$1;
          areaStream$1.lineEnd = areaRingEnd$1;
        },
        polygonEnd: function () {
          areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$2;
          areaSum$1.add(abs(areaRingSum$1));
          areaRingSum$1.reset();
        },
        result: function () {
          var area = areaSum$1 / 2;
          areaSum$1.reset();
          return area;
        }
      };
      function areaRingStart$1() {
        areaStream$1.point = areaPointFirst$1;
      }
      function areaPointFirst$1(x, y) {
        areaStream$1.point = areaPoint$1;
        x00 = x0$1 = x, y00 = y0$1 = y;
      }
      function areaPoint$1(x, y) {
        areaRingSum$1.add(y0$1 * x - x0$1 * y);
        x0$1 = x, y0$1 = y;
      }
      function areaRingEnd$1() {
        areaPoint$1(x00, y00);
      }
      var x0$2 = Infinity;
      var y0$2 = x0$2;
      var x1 = -x0$2;
      var y1 = x1;
      var boundsStream$1 = {
        point: boundsPoint$1,
        lineStart: noop$2,
        lineEnd: noop$2,
        polygonStart: noop$2,
        polygonEnd: noop$2,
        result: function () {
          var bounds = [[x0$2, y0$2], [x1, y1]];
          x1 = y1 = -(y0$2 = x0$2 = Infinity);
          return bounds;
        }
      };
      function boundsPoint$1(x, y) {
        if (x < x0$2) x0$2 = x;
        if (x > x1) x1 = x;
        if (y < y0$2) y0$2 = y;
        if (y > y1) y1 = y;
      }
      var X0$1 = 0;
      var Y0$1 = 0;
      var Z0$1 = 0;
      var X1$1 = 0;
      var Y1$1 = 0;
      var Z1$1 = 0;
      var X2$1 = 0;
      var Y2$1 = 0;
      var Z2$1 = 0;
      var x00$1;
      var y00$1;
      var x0$3;
      var y0$3;
      var centroidStream$1 = {
        point: centroidPoint$1,
        lineStart: centroidLineStart$1,
        lineEnd: centroidLineEnd$1,
        polygonStart: function () {
          centroidStream$1.lineStart = centroidRingStart$1;
          centroidStream$1.lineEnd = centroidRingEnd$1;
        },
        polygonEnd: function () {
          centroidStream$1.point = centroidPoint$1;
          centroidStream$1.lineStart = centroidLineStart$1;
          centroidStream$1.lineEnd = centroidLineEnd$1;
        },
        result: function () {
          var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] : [NaN, NaN];
          X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
          return centroid;
        }
      };
      function centroidPoint$1(x, y) {
        X0$1 += x;
        Y0$1 += y;
        ++Z0$1;
      }
      function centroidLineStart$1() {
        centroidStream$1.point = centroidPointFirstLine;
      }
      function centroidPointFirstLine(x, y) {
        centroidStream$1.point = centroidPointLine;
        centroidPoint$1(x0$3 = x, y0$3 = y);
      }
      function centroidPointLine(x, y) {
        var dx = x - x0$3,
            dy = y - y0$3,
            z = sqrt$1(dx * dx + dy * dy);
        X1$1 += z * (x0$3 + x) / 2;
        Y1$1 += z * (y0$3 + y) / 2;
        Z1$1 += z;
        centroidPoint$1(x0$3 = x, y0$3 = y);
      }
      function centroidLineEnd$1() {
        centroidStream$1.point = centroidPoint$1;
      }
      function centroidRingStart$1() {
        centroidStream$1.point = centroidPointFirstRing;
      }
      function centroidRingEnd$1() {
        centroidPointRing(x00$1, y00$1);
      }
      function centroidPointFirstRing(x, y) {
        centroidStream$1.point = centroidPointRing;
        centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
      }
      function centroidPointRing(x, y) {
        var dx = x - x0$3,
            dy = y - y0$3,
            z = sqrt$1(dx * dx + dy * dy);
        X1$1 += z * (x0$3 + x) / 2;
        Y1$1 += z * (y0$3 + y) / 2;
        Z1$1 += z;
        z = y0$3 * x - x0$3 * y;
        X2$1 += z * (x0$3 + x);
        Y2$1 += z * (y0$3 + y);
        Z2$1 += z * 3;
        centroidPoint$1(x0$3 = x, y0$3 = y);
      }
      function PathContext(context) {
        this._context = context;
      }
      PathContext.prototype = {
        _radius: 4.5,
        pointRadius: function (_) {
          return this._radius = _, this;
        },
        polygonStart: function () {
          this._line = 0;
        },
        polygonEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._point = 0;
        },
        lineEnd: function () {
          if (this._line === 0) this._context.closePath();
          this._point = NaN;
        },
        point: function (x, y) {
          switch (this._point) {
            case 0:
              {
                this._context.moveTo(x, y);
                this._point = 1;
                break;
              }
            case 1:
              {
                this._context.lineTo(x, y);
                break;
              }
            default:
              {
                this._context.moveTo(x + this._radius, y);
                this._context.arc(x, y, this._radius, 0, tau$4);
                break;
              }
          }
        },
        result: noop$2
      };
      function PathString() {
        this._string = [];
      }
      PathString.prototype = {
        _circle: circle$2(4.5),
        pointRadius: function (_) {
          return this._circle = circle$2(_), this;
        },
        polygonStart: function () {
          this._line = 0;
        },
        polygonEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          this._point = 0;
        },
        lineEnd: function () {
          if (this._line === 0) this._string.push("Z");
          this._point = NaN;
        },
        point: function (x, y) {
          switch (this._point) {
            case 0:
              {
                this._string.push("M", x, ",", y);
                this._point = 1;
                break;
              }
            case 1:
              {
                this._string.push("L", x, ",", y);
                break;
              }
            default:
              {
                this._string.push("M", x, ",", y, this._circle);
                break;
              }
          }
        },
        result: function () {
          if (this._string.length) {
            var result = this._string.join("");
            this._string = [];
            return result;
          }
        }
      };
      function circle$2(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
      }
      var index$3 = function (projection, context) {
        var pointRadius = 4.5,
            projectionStream,
            contextStream;
        function path(object) {
          if (object) {
            if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
            geoStream(object, projectionStream(contextStream));
          }
          return contextStream.result();
        }
        path.area = function (object) {
          geoStream(object, projectionStream(areaStream$1));
          return areaStream$1.result();
        };
        path.bounds = function (object) {
          geoStream(object, projectionStream(boundsStream$1));
          return boundsStream$1.result();
        };
        path.centroid = function (object) {
          geoStream(object, projectionStream(centroidStream$1));
          return centroidStream$1.result();
        };
        path.projection = function (_) {
          return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$7) : (projection = _).stream, path) : projection;
        };
        path.context = function (_) {
          if (!arguments.length) return context;
          contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
          if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
          return path;
        };
        path.pointRadius = function (_) {
          if (!arguments.length) return pointRadius;
          pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
          return path;
        };
        return path.projection(projection).context(context);
      };
      var sum$2 = adder();
      var polygonContains = function (polygon, point) {
        var lambda = point[0],
            phi = point[1],
            normal = [sin$1(lambda), -cos$1(lambda), 0],
            angle = 0,
            winding = 0;
        sum$2.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
          if (!(m = (ring = polygon[i]).length)) continue;
          var ring,
              m,
              point0 = ring[m - 1],
              lambda0 = point0[0],
              phi0 = point0[1] / 2 + quarterPi,
              sinPhi0 = sin$1(phi0),
              cosPhi0 = cos$1(phi0);
          for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
            var point1 = ring[j],
                lambda1 = point1[0],
                phi1 = point1[1] / 2 + quarterPi,
                sinPhi1 = sin$1(phi1),
                cosPhi1 = cos$1(phi1),
                delta = lambda1 - lambda0,
                sign$$1 = delta >= 0 ? 1 : -1,
                absDelta = sign$$1 * delta,
                antimeridian = absDelta > pi$4,
                k = sinPhi0 * sinPhi1;
            sum$2.add(atan2(k * sign$$1 * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
            angle += antimeridian ? delta + sign$$1 * tau$4 : delta;
            if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
              var arc = cartesianCross(cartesian(point0), cartesian(point1));
              cartesianNormalizeInPlace(arc);
              var intersection = cartesianCross(normal, arc);
              cartesianNormalizeInPlace(intersection);
              var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);
              if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
                winding += antimeridian ^ delta >= 0 ? 1 : -1;
              }
            }
          }
        }
        return (angle < -epsilon$4 || angle < epsilon$4 && sum$2 < -epsilon$4) ^ winding & 1;
      };
      var clip = function (pointVisible, clipLine, interpolate, start) {
        return function (rotate, sink) {
          var line = clipLine(sink),
              rotatedStart = rotate.invert(start[0], start[1]),
              ringBuffer = clipBuffer(),
              ringSink = clipLine(ringBuffer),
              polygonStarted = false,
              polygon,
              segments,
              ring;
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
              clip.point = pointRing;
              clip.lineStart = ringStart;
              clip.lineEnd = ringEnd;
              segments = [];
              polygon = [];
            },
            polygonEnd: function () {
              clip.point = point;
              clip.lineStart = lineStart;
              clip.lineEnd = lineEnd;
              segments = merge(segments);
              var startInside = polygonContains(polygon, rotatedStart);
              if (segments.length) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                clipPolygon(segments, compareIntersection, startInside, interpolate, sink);
              } else if (startInside) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                sink.lineStart();
                interpolate(null, null, 1, sink);
                sink.lineEnd();
              }
              if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
              segments = polygon = null;
            },
            sphere: function () {
              sink.polygonStart();
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
              sink.polygonEnd();
            }
          };
          function point(lambda, phi) {
            var point = rotate(lambda, phi);
            if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);
          }
          function pointLine(lambda, phi) {
            var point = rotate(lambda, phi);
            line.point(point[0], point[1]);
          }
          function lineStart() {
            clip.point = pointLine;
            line.lineStart();
          }
          function lineEnd() {
            clip.point = point;
            line.lineEnd();
          }
          function pointRing(lambda, phi) {
            ring.push([lambda, phi]);
            var point = rotate(lambda, phi);
            ringSink.point(point[0], point[1]);
          }
          function ringStart() {
            ringSink.lineStart();
            ring = [];
          }
          function ringEnd() {
            pointRing(ring[0][0], ring[0][1]);
            ringSink.lineEnd();
            var clean = ringSink.clean(),
                ringSegments = ringBuffer.result(),
                i,
                n = ringSegments.length,
                m,
                segment,
                point;
            ring.pop();
            polygon.push(ring);
            ring = null;
            if (!n) return;
            if (clean & 1) {
              segment = ringSegments[0];
              if ((m = segment.length - 1) > 0) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                sink.lineStart();
                for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
                sink.lineEnd();
              }
              return;
            }
            if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
            segments.push(ringSegments.filter(validSegment));
          }
          return clip;
        };
      };
      function validSegment(segment) {
        return segment.length > 1;
      }
      function compareIntersection(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfPi$3 - epsilon$4 : halfPi$3 - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi$3 - epsilon$4 : halfPi$3 - b[1]);
      }
      var clipAntimeridian = clip(function () {
        return true;
      }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi$4, -halfPi$3]);
      function clipAntimeridianLine(stream) {
        var lambda0 = NaN,
            phi0 = NaN,
            sign0 = NaN,
            clean;
        return {
          lineStart: function () {
            stream.lineStart();
            clean = 1;
          },
          point: function (lambda1, phi1) {
            var sign1 = lambda1 > 0 ? pi$4 : -pi$4,
                delta = abs(lambda1 - lambda0);
            if (abs(delta - pi$4) < epsilon$4) {
              stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$3 : -halfPi$3);
              stream.point(sign0, phi0);
              stream.lineEnd();
              stream.lineStart();
              stream.point(sign1, phi0);
              stream.point(lambda1, phi0);
              clean = 0;
            } else if (sign0 !== sign1 && delta >= pi$4) {
              if (abs(lambda0 - sign0) < epsilon$4) lambda0 -= sign0 * epsilon$4;
              if (abs(lambda1 - sign1) < epsilon$4) lambda1 -= sign1 * epsilon$4;
              phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
              stream.point(sign0, phi0);
              stream.lineEnd();
              stream.lineStart();
              stream.point(sign1, phi0);
              clean = 0;
            }
            stream.point(lambda0 = lambda1, phi0 = phi1);
            sign0 = sign1;
          },
          lineEnd: function () {
            stream.lineEnd();
            lambda0 = phi0 = NaN;
          },
          clean: function () {
            return 2 - clean;
          }
        };
      }
      function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
        var cosPhi0,
            cosPhi1,
            sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
        return abs(sinLambda0Lambda1) > epsilon$4 ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1) - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
      }
      function clipAntimeridianInterpolate(from, to, direction, stream) {
        var phi;
        if (from == null) {
          phi = direction * halfPi$3;
          stream.point(-pi$4, phi);
          stream.point(0, phi);
          stream.point(pi$4, phi);
          stream.point(pi$4, 0);
          stream.point(pi$4, -phi);
          stream.point(0, -phi);
          stream.point(-pi$4, -phi);
          stream.point(-pi$4, 0);
          stream.point(-pi$4, phi);
        } else if (abs(from[0] - to[0]) > epsilon$4) {
          var lambda = from[0] < to[0] ? pi$4 : -pi$4;
          phi = direction * lambda / 2;
          stream.point(-lambda, phi);
          stream.point(0, phi);
          stream.point(lambda, phi);
        } else {
          stream.point(to[0], to[1]);
        }
      }
      var clipCircle = function (radius, delta) {
        var cr = cos$1(radius),
            smallRadius = cr > 0,
            notHemisphere = abs(cr) > epsilon$4;
        function interpolate(from, to, direction, stream) {
          circleStream(stream, radius, delta, direction, from, to);
        }
        function visible(lambda, phi) {
          return cos$1(lambda) * cos$1(phi) > cr;
        }
        function clipLine(stream) {
          var point0, c0, v0, v00, clean;
          return {
            lineStart: function () {
              v00 = v0 = false;
              clean = 1;
            },
            point: function (lambda, phi) {
              var point1 = [lambda, phi],
                  point2,
                  v = visible(lambda, phi),
                  c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi$4 : -pi$4), phi) : 0;
              if (!point0 && (v00 = v0 = v)) stream.lineStart();
              if (v !== v0) {
                point2 = intersect(point0, point1);
                if (pointEqual(point0, point2) || pointEqual(point1, point2)) {
                  point1[0] += epsilon$4;
                  point1[1] += epsilon$4;
                  v = visible(point1[0], point1[1]);
                }
              }
              if (v !== v0) {
                clean = 0;
                if (v) {
                  stream.lineStart();
                  point2 = intersect(point1, point0);
                  stream.point(point2[0], point2[1]);
                } else {
                  point2 = intersect(point0, point1);
                  stream.point(point2[0], point2[1]);
                  stream.lineEnd();
                }
                point0 = point2;
              } else if (notHemisphere && point0 && smallRadius ^ v) {
                var t;
                if (!(c & c0) && (t = intersect(point1, point0, true))) {
                  clean = 0;
                  if (smallRadius) {
                    stream.lineStart();
                    stream.point(t[0][0], t[0][1]);
                    stream.point(t[1][0], t[1][1]);
                    stream.lineEnd();
                  } else {
                    stream.point(t[1][0], t[1][1]);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(t[0][0], t[0][1]);
                  }
                }
              }
              if (v && (!point0 || !pointEqual(point0, point1))) {
                stream.point(point1[0], point1[1]);
              }
              point0 = point1, v0 = v, c0 = c;
            },
            lineEnd: function () {
              if (v0) stream.lineEnd();
              point0 = null;
            },
            clean: function () {
              return clean | (v00 && v0) << 1;
            }
          };
        }
        function intersect(a, b, two) {
          var pa = cartesian(a),
              pb = cartesian(b);
          var n1 = [1, 0, 0],
              n2 = cartesianCross(pa, pb),
              n2n2 = cartesianDot(n2, n2),
              n1n2 = n2[0],
              determinant = n2n2 - n1n2 * n1n2;
          if (!determinant) return !two && a;
          var c1 = cr * n2n2 / determinant,
              c2 = -cr * n1n2 / determinant,
              n1xn2 = cartesianCross(n1, n2),
              A = cartesianScale(n1, c1),
              B = cartesianScale(n2, c2);
          cartesianAddInPlace(A, B);
          var u = n1xn2,
              w = cartesianDot(A, u),
              uu = cartesianDot(u, u),
              t2 = w * w - uu * (cartesianDot(A, A) - 1);
          if (t2 < 0) return;
          var t = sqrt$1(t2),
              q = cartesianScale(u, (-w - t) / uu);
          cartesianAddInPlace(q, A);
          q = spherical(q);
          if (!two) return q;
          var lambda0 = a[0],
              lambda1 = b[0],
              phi0 = a[1],
              phi1 = b[1],
              z;
          if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
          var delta = lambda1 - lambda0,
              polar = abs(delta - pi$4) < epsilon$4,
              meridian = polar || delta < epsilon$4;
          if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;
          if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon$4 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi$4 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
            var q1 = cartesianScale(u, (-w + t) / uu);
            cartesianAddInPlace(q1, A);
            return [q, spherical(q1)];
          }
        }
        function code(lambda, phi) {
          var r = smallRadius ? radius : pi$4 - radius,
              code = 0;
          if (lambda < -r) code |= 1;else if (lambda > r) code |= 2;
          if (phi < -r) code |= 4;else if (phi > r) code |= 8;
          return code;
        }
        return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$4, radius - pi$4]);
      };
      var transform$1 = function (methods) {
        return { stream: transformer(methods) };
      };
      function transformer(methods) {
        return function (stream) {
          var s = new TransformStream();
          for (var key in methods) s[key] = methods[key];
          s.stream = stream;
          return s;
        };
      }
      function TransformStream() {}
      TransformStream.prototype = {
        constructor: TransformStream,
        point: function (x, y) {
          this.stream.point(x, y);
        },
        sphere: function () {
          this.stream.sphere();
        },
        lineStart: function () {
          this.stream.lineStart();
        },
        lineEnd: function () {
          this.stream.lineEnd();
        },
        polygonStart: function () {
          this.stream.polygonStart();
        },
        polygonEnd: function () {
          this.stream.polygonEnd();
        }
      };
      function fitExtent(projection, extent, object) {
        var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            clip = projection.clipExtent && projection.clipExtent();
        projection.scale(150).translate([0, 0]);
        if (clip != null) projection.clipExtent(null);
        geoStream(object, projection.stream(boundsStream$1));
        var b = boundsStream$1.result(),
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        if (clip != null) projection.clipExtent(clip);
        return projection.scale(k * 150).translate([x, y]);
      }
      function fitSize(projection, size, object) {
        return fitExtent(projection, [[0, 0], size], object);
      }
      var maxDepth = 16;
      var cosMinDistance = cos$1(30 * radians);
      var resample = function (project, delta2) {
        return +delta2 ? resample$1(project, delta2) : resampleNone(project);
      };
      function resampleNone(project) {
        return transformer({ point: function (x, y) {
            x = project(x, y);
            this.stream.point(x[0], x[1]);
          } });
      }
      function resample$1(project, delta2) {
        function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
          var dx = x1 - x0,
              dy = y1 - y0,
              d2 = dx * dx + dy * dy;
          if (d2 > 4 * delta2 && depth--) {
            var a = a0 + a1,
                b = b0 + b1,
                c = c0 + c1,
                m = sqrt$1(a * a + b * b + c * c),
                phi2 = asin$1(c /= m),
                lambda2 = abs(abs(c) - 1) < epsilon$4 || abs(lambda0 - lambda1) < epsilon$4 ? (lambda0 + lambda1) / 2 : atan2(b, a),
                p = project(lambda2, phi2),
                x2 = p[0],
                y2 = p[1],
                dx2 = x2 - x0,
                dy2 = y2 - y0,
                dz = dy * dx2 - dx * dy2;
            if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
              resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
              stream.point(x2, y2);
              resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
            }
          }
        }
        return function (stream) {
          var lambda00, x00, y00, a00, b00, c00, lambda0, x0, y0, a0, b0, c0;
          var resampleStream = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
              stream.polygonStart();
              resampleStream.lineStart = ringStart;
            },
            polygonEnd: function () {
              stream.polygonEnd();
              resampleStream.lineStart = lineStart;
            }
          };
          function point(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          }
          function lineStart() {
            x0 = NaN;
            resampleStream.point = linePoint;
            stream.lineStart();
          }
          function linePoint(lambda, phi) {
            var c = cartesian([lambda, phi]),
                p = project(lambda, phi);
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
            stream.point(x0, y0);
          }
          function lineEnd() {
            resampleStream.point = point;
            stream.lineEnd();
          }
          function ringStart() {
            lineStart();
            resampleStream.point = ringPoint;
            resampleStream.lineEnd = ringEnd;
          }
          function ringPoint(lambda, phi) {
            linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
            resampleStream.point = linePoint;
          }
          function ringEnd() {
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
            resampleStream.lineEnd = lineEnd;
            lineEnd();
          }
          return resampleStream;
        };
      }
      var transformRadians = transformer({ point: function (x, y) {
          this.stream.point(x * radians, y * radians);
        } });
      function projection(project) {
        return projectionMutator(function () {
          return project;
        })();
      }
      function projectionMutator(projectAt) {
        var project,
            k = 150,
            x = 480,
            y = 250,
            dx,
            dy,
            lambda = 0,
            phi = 0,
            deltaLambda = 0,
            deltaPhi = 0,
            deltaGamma = 0,
            rotate,
            projectRotate,
            theta = null,
            preclip = clipAntimeridian,
            x0 = null,
            y0,
            x1,
            y1,
            postclip = identity$7,
            delta2 = 0.5,
            projectResample = resample(projectTransform, delta2),
            cache,
            cacheStream;
        function projection(point) {
          point = projectRotate(point[0] * radians, point[1] * radians);
          return [point[0] * k + dx, dy - point[1] * k];
        }
        function invert(point) {
          point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
          return point && [point[0] * degrees$1, point[1] * degrees$1];
        }
        function projectTransform(x, y) {
          return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
        }
        projection.stream = function (stream) {
          return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
        };
        projection.clipAngle = function (_) {
          return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;
        };
        projection.clipExtent = function (_) {
          return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$7) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
        };
        projection.scale = function (_) {
          return arguments.length ? (k = +_, recenter()) : k;
        };
        projection.translate = function (_) {
          return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
        };
        projection.center = function (_) {
          return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];
        };
        projection.rotate = function (_) {
          return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];
        };
        projection.precision = function (_) {
          return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$1(delta2);
        };
        projection.fitExtent = function (extent, object) {
          return fitExtent(projection, extent, object);
        };
        projection.fitSize = function (size, object) {
          return fitSize(projection, size, object);
        };
        function recenter() {
          projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
          var center = project(lambda, phi);
          dx = x - center[0] * k;
          dy = y + center[1] * k;
          return reset();
        }
        function reset() {
          cache = cacheStream = null;
          return projection;
        }
        return function () {
          project = projectAt.apply(this, arguments);
          projection.invert = project.invert && invert;
          return recenter();
        };
      }
      function conicProjection(projectAt) {
        var phi0 = 0,
            phi1 = pi$4 / 3,
            m = projectionMutator(projectAt),
            p = m(phi0, phi1);
        p.parallels = function (_) {
          return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees$1, phi1 * degrees$1];
        };
        return p;
      }
      function cylindricalEqualAreaRaw(phi0) {
        var cosPhi0 = cos$1(phi0);
        function forward(lambda, phi) {
          return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
        }
        forward.invert = function (x, y) {
          return [x / cosPhi0, asin$1(y * cosPhi0)];
        };
        return forward;
      }
      function conicEqualAreaRaw(y0, y1) {
        var sy0 = sin$1(y0),
            n = (sy0 + sin$1(y1)) / 2;
        if (abs(n) < epsilon$4) return cylindricalEqualAreaRaw(y0);
        var c = 1 + sy0 * (2 * n - sy0),
            r0 = sqrt$1(c) / n;
        function project(x, y) {
          var r = sqrt$1(c - 2 * n * sin$1(y)) / n;
          return [r * sin$1(x *= n), r0 - r * cos$1(x)];
        }
        project.invert = function (x, y) {
          var r0y = r0 - y;
          return [atan2(x, abs(r0y)) / n * sign$1(r0y), asin$1((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
        };
        return project;
      }
      var conicEqualArea = function () {
        return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
      };
      var albers = function () {
        return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
      };
      function multiplex(streams) {
        var n = streams.length;
        return {
          point: function (x, y) {
            var i = -1;
            while (++i < n) streams[i].point(x, y);
          },
          sphere: function () {
            var i = -1;
            while (++i < n) streams[i].sphere();
          },
          lineStart: function () {
            var i = -1;
            while (++i < n) streams[i].lineStart();
          },
          lineEnd: function () {
            var i = -1;
            while (++i < n) streams[i].lineEnd();
          },
          polygonStart: function () {
            var i = -1;
            while (++i < n) streams[i].polygonStart();
          },
          polygonEnd: function () {
            var i = -1;
            while (++i < n) streams[i].polygonEnd();
          }
        };
      }
      var albersUsa = function () {
        var cache,
            cacheStream,
            lower48 = albers(),
            lower48Point,
            alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
            alaskaPoint,
            hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
            hawaiiPoint,
            point,
            pointStream = { point: function (x, y) {
            point = [x, y];
          } };
        function albersUsa(coordinates) {
          var x = coordinates[0],
              y = coordinates[1];
          return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
        }
        albersUsa.invert = function (coordinates) {
          var k = lower48.scale(),
              t = lower48.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k;
          return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function (stream) {
          return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
        };
        albersUsa.precision = function (_) {
          if (!arguments.length) return lower48.precision();
          lower48.precision(_), alaska.precision(_), hawaii.precision(_);
          return reset();
        };
        albersUsa.scale = function (_) {
          if (!arguments.length) return lower48.scale();
          lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
          return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function (_) {
          if (!arguments.length) return lower48.translate();
          var k = lower48.scale(),
              x = +_[0],
              y = +_[1];
          lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
          alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon$4, y + 0.120 * k + epsilon$4], [x - 0.214 * k - epsilon$4, y + 0.234 * k - epsilon$4]]).stream(pointStream);
          hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon$4, y + 0.166 * k + epsilon$4], [x - 0.115 * k - epsilon$4, y + 0.234 * k - epsilon$4]]).stream(pointStream);
          return reset();
        };
        albersUsa.fitExtent = function (extent, object) {
          return fitExtent(albersUsa, extent, object);
        };
        albersUsa.fitSize = function (size, object) {
          return fitSize(albersUsa, size, object);
        };
        function reset() {
          cache = cacheStream = null;
          return albersUsa;
        }
        return albersUsa.scale(1070);
      };
      function azimuthalRaw(scale) {
        return function (x, y) {
          var cx = cos$1(x),
              cy = cos$1(y),
              k = scale(cx * cy);
          return [k * cy * sin$1(x), k * sin$1(y)];
        };
      }
      function azimuthalInvert(angle) {
        return function (x, y) {
          var z = sqrt$1(x * x + y * y),
              c = angle(z),
              sc = sin$1(c),
              cc = cos$1(c);
          return [atan2(x * sc, z * cc), asin$1(z && y * sc / z)];
        };
      }
      var azimuthalEqualAreaRaw = azimuthalRaw(function (cxcy) {
        return sqrt$1(2 / (1 + cxcy));
      });
      azimuthalEqualAreaRaw.invert = azimuthalInvert(function (z) {
        return 2 * asin$1(z / 2);
      });
      var azimuthalEqualArea = function () {
        return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
      };
      var azimuthalEquidistantRaw = azimuthalRaw(function (c) {
        return (c = acos(c)) && c / sin$1(c);
      });
      azimuthalEquidistantRaw.invert = azimuthalInvert(function (z) {
        return z;
      });
      var azimuthalEquidistant = function () {
        return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
      };
      function mercatorRaw(lambda, phi) {
        return [lambda, log$1(tan((halfPi$3 + phi) / 2))];
      }
      mercatorRaw.invert = function (x, y) {
        return [x, 2 * atan(exp(y)) - halfPi$3];
      };
      var mercator = function () {
        return mercatorProjection(mercatorRaw).scale(961 / tau$4);
      };
      function mercatorProjection(project) {
        var m = projection(project),
            scale = m.scale,
            translate = m.translate,
            clipExtent = m.clipExtent,
            clipAuto;
        m.scale = function (_) {
          return arguments.length ? (scale(_), clipAuto && m.clipExtent(null), m) : scale();
        };
        m.translate = function (_) {
          return arguments.length ? (translate(_), clipAuto && m.clipExtent(null), m) : translate();
        };
        m.clipExtent = function (_) {
          if (!arguments.length) return clipAuto ? null : clipExtent();
          if (clipAuto = _ == null) {
            var k = pi$4 * scale(),
                t = translate();
            _ = [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]];
          }
          clipExtent(_);
          return m;
        };
        return m.clipExtent(null);
      }
      function tany(y) {
        return tan((halfPi$3 + y) / 2);
      }
      function conicConformalRaw(y0, y1) {
        var cy0 = cos$1(y0),
            n = y0 === y1 ? sin$1(y0) : log$1(cy0 / cos$1(y1)) / log$1(tany(y1) / tany(y0)),
            f = cy0 * pow$1(tany(y0), n) / n;
        if (!n) return mercatorRaw;
        function project(x, y) {
          if (f > 0) {
            if (y < -halfPi$3 + epsilon$4) y = -halfPi$3 + epsilon$4;
          } else {
            if (y > halfPi$3 - epsilon$4) y = halfPi$3 - epsilon$4;
          }
          var r = f / pow$1(tany(y), n);
          return [r * sin$1(n * x), f - r * cos$1(n * x)];
        }
        project.invert = function (x, y) {
          var fy = f - y,
              r = sign$1(n) * sqrt$1(x * x + fy * fy);
          return [atan2(x, abs(fy)) / n * sign$1(fy), 2 * atan(pow$1(f / r, 1 / n)) - halfPi$3];
        };
        return project;
      }
      var conicConformal = function () {
        return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
      };
      function equirectangularRaw(lambda, phi) {
        return [lambda, phi];
      }
      equirectangularRaw.invert = equirectangularRaw;
      var equirectangular = function () {
        return projection(equirectangularRaw).scale(152.63);
      };
      function conicEquidistantRaw(y0, y1) {
        var cy0 = cos$1(y0),
            n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
            g = cy0 / n + y0;
        if (abs(n) < epsilon$4) return equirectangularRaw;
        function project(x, y) {
          var gy = g - y,
              nx = n * x;
          return [gy * sin$1(nx), g - gy * cos$1(nx)];
        }
        project.invert = function (x, y) {
          var gy = g - y;
          return [atan2(x, abs(gy)) / n * sign$1(gy), g - sign$1(n) * sqrt$1(x * x + gy * gy)];
        };
        return project;
      }
      var conicEquidistant = function () {
        return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
      };
      function gnomonicRaw(x, y) {
        var cy = cos$1(y),
            k = cos$1(x) * cy;
        return [cy * sin$1(x) / k, sin$1(y) / k];
      }
      gnomonicRaw.invert = azimuthalInvert(atan);
      var gnomonic = function () {
        return projection(gnomonicRaw).scale(144.049).clipAngle(60);
      };
      function scaleTranslate(kx, ky, tx, ty) {
        return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity$7 : transformer({ point: function (x, y) {
            this.stream.point(x * kx + tx, y * ky + ty);
          } });
      }
      var identity$8 = function () {
        var k = 1,
            tx = 0,
            ty = 0,
            sx = 1,
            sy = 1,
            transform = identity$7,
            x0 = null,
            y0,
            x1,
            y1,
            clip = identity$7,
            cache,
            cacheStream,
            projection;
        function reset() {
          cache = cacheStream = null;
          return projection;
        }
        return projection = {
          stream: function (stream) {
            return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));
          },
          clipExtent: function (_) {
            return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$7) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
          },
          scale: function (_) {
            return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
          },
          translate: function (_) {
            return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
          },
          reflectX: function (_) {
            return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
          },
          reflectY: function (_) {
            return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
          },
          fitExtent: function (extent, object) {
            return fitExtent(projection, extent, object);
          },
          fitSize: function (size, object) {
            return fitSize(projection, size, object);
          }
        };
      };
      function orthographicRaw(x, y) {
        return [cos$1(y) * sin$1(x), sin$1(y)];
      }
      orthographicRaw.invert = azimuthalInvert(asin$1);
      var orthographic = function () {
        return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon$4);
      };
      function stereographicRaw(x, y) {
        var cy = cos$1(y),
            k = 1 + cos$1(x) * cy;
        return [cy * sin$1(x) / k, sin$1(y) / k];
      }
      stereographicRaw.invert = azimuthalInvert(function (z) {
        return 2 * atan(z);
      });
      var stereographic = function () {
        return projection(stereographicRaw).scale(250).clipAngle(142);
      };
      function transverseMercatorRaw(lambda, phi) {
        return [log$1(tan((halfPi$3 + phi) / 2)), -lambda];
      }
      transverseMercatorRaw.invert = function (x, y) {
        return [-y, 2 * atan(exp(x)) - halfPi$3];
      };
      var transverseMercator = function () {
        var m = mercatorProjection(transverseMercatorRaw),
            center = m.center,
            rotate = m.rotate;
        m.center = function (_) {
          return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
        };
        m.rotate = function (_) {
          return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
        };
        return rotate([0, 0, 90]).scale(159.155);
      };
      exports.version = version;
      exports.bisect = bisectRight;
      exports.bisectRight = bisectRight;
      exports.bisectLeft = bisectLeft;
      exports.ascending = ascending;
      exports.bisector = bisector;
      exports.descending = descending;
      exports.deviation = deviation;
      exports.extent = extent;
      exports.histogram = histogram;
      exports.thresholdFreedmanDiaconis = freedmanDiaconis;
      exports.thresholdScott = scott;
      exports.thresholdSturges = sturges;
      exports.max = max;
      exports.mean = mean;
      exports.median = median;
      exports.merge = merge;
      exports.min = min;
      exports.pairs = pairs;
      exports.permute = permute;
      exports.quantile = threshold;
      exports.range = range;
      exports.scan = scan;
      exports.shuffle = shuffle;
      exports.sum = sum;
      exports.ticks = ticks;
      exports.tickStep = tickStep;
      exports.transpose = transpose;
      exports.variance = variance;
      exports.zip = zip;
      exports.entries = entries;
      exports.keys = keys;
      exports.values = values;
      exports.map = map$1;
      exports.set = set;
      exports.nest = nest;
      exports.randomUniform = uniform;
      exports.randomNormal = normal;
      exports.randomLogNormal = logNormal;
      exports.randomBates = bates;
      exports.randomIrwinHall = irwinHall;
      exports.randomExponential = exponential;
      exports.easeLinear = linear;
      exports.easeQuad = quadInOut;
      exports.easeQuadIn = quadIn;
      exports.easeQuadOut = quadOut;
      exports.easeQuadInOut = quadInOut;
      exports.easeCubic = cubicInOut;
      exports.easeCubicIn = cubicIn;
      exports.easeCubicOut = cubicOut;
      exports.easeCubicInOut = cubicInOut;
      exports.easePoly = polyInOut;
      exports.easePolyIn = polyIn;
      exports.easePolyOut = polyOut;
      exports.easePolyInOut = polyInOut;
      exports.easeSin = sinInOut;
      exports.easeSinIn = sinIn;
      exports.easeSinOut = sinOut;
      exports.easeSinInOut = sinInOut;
      exports.easeExp = expInOut;
      exports.easeExpIn = expIn;
      exports.easeExpOut = expOut;
      exports.easeExpInOut = expInOut;
      exports.easeCircle = circleInOut;
      exports.easeCircleIn = circleIn;
      exports.easeCircleOut = circleOut;
      exports.easeCircleInOut = circleInOut;
      exports.easeBounce = bounceOut;
      exports.easeBounceIn = bounceIn;
      exports.easeBounceOut = bounceOut;
      exports.easeBounceInOut = bounceInOut;
      exports.easeBack = backInOut;
      exports.easeBackIn = backIn;
      exports.easeBackOut = backOut;
      exports.easeBackInOut = backInOut;
      exports.easeElastic = elasticOut;
      exports.easeElasticIn = elasticIn;
      exports.easeElasticOut = elasticOut;
      exports.easeElasticInOut = elasticInOut;
      exports.polygonArea = area;
      exports.polygonCentroid = centroid;
      exports.polygonHull = hull;
      exports.polygonContains = contains;
      exports.polygonLength = length$1;
      exports.path = path;
      exports.quadtree = quadtree;
      exports.queue = queue;
      exports.arc = arc;
      exports.area = area$1;
      exports.line = line;
      exports.pie = pie;
      exports.radialArea = radialArea;
      exports.radialLine = radialLine$1;
      exports.symbol = symbol;
      exports.symbols = symbols;
      exports.symbolCircle = circle;
      exports.symbolCross = cross$1;
      exports.symbolDiamond = diamond;
      exports.symbolSquare = square;
      exports.symbolStar = star;
      exports.symbolTriangle = triangle;
      exports.symbolWye = wye;
      exports.curveBasisClosed = basisClosed;
      exports.curveBasisOpen = basisOpen;
      exports.curveBasis = basis;
      exports.curveBundle = bundle;
      exports.curveCardinalClosed = cardinalClosed;
      exports.curveCardinalOpen = cardinalOpen;
      exports.curveCardinal = cardinal;
      exports.curveCatmullRomClosed = catmullRomClosed;
      exports.curveCatmullRomOpen = catmullRomOpen;
      exports.curveCatmullRom = catmullRom;
      exports.curveLinearClosed = linearClosed;
      exports.curveLinear = curveLinear;
      exports.curveMonotoneX = monotoneX;
      exports.curveMonotoneY = monotoneY;
      exports.curveNatural = natural;
      exports.curveStep = step;
      exports.curveStepAfter = stepAfter;
      exports.curveStepBefore = stepBefore;
      exports.stack = stack;
      exports.stackOffsetExpand = expand;
      exports.stackOffsetNone = none;
      exports.stackOffsetSilhouette = silhouette;
      exports.stackOffsetWiggle = wiggle;
      exports.stackOrderAscending = ascending$1;
      exports.stackOrderDescending = descending$2;
      exports.stackOrderInsideOut = insideOut;
      exports.stackOrderNone = none$1;
      exports.stackOrderReverse = reverse;
      exports.color = color;
      exports.rgb = rgb;
      exports.hsl = hsl;
      exports.lab = lab;
      exports.hcl = hcl;
      exports.cubehelix = cubehelix;
      exports.interpolate = interpolate;
      exports.interpolateArray = array$1;
      exports.interpolateDate = date;
      exports.interpolateNumber = interpolateNumber;
      exports.interpolateObject = object;
      exports.interpolateRound = interpolateRound;
      exports.interpolateString = interpolateString;
      exports.interpolateTransformCss = interpolateTransformCss;
      exports.interpolateTransformSvg = interpolateTransformSvg;
      exports.interpolateZoom = interpolateZoom;
      exports.interpolateRgb = interpolateRgb;
      exports.interpolateRgbBasis = rgbBasis;
      exports.interpolateRgbBasisClosed = rgbBasisClosed;
      exports.interpolateHsl = hsl$2;
      exports.interpolateHslLong = hslLong;
      exports.interpolateLab = lab$1;
      exports.interpolateHcl = hcl$2;
      exports.interpolateHclLong = hclLong;
      exports.interpolateCubehelix = cubehelix$2;
      exports.interpolateCubehelixLong = cubehelixLong;
      exports.interpolateBasis = basis$2;
      exports.interpolateBasisClosed = basisClosed$1;
      exports.quantize = quantize;
      exports.dispatch = dispatch;
      exports.dsvFormat = dsv;
      exports.csvParse = csvParse;
      exports.csvParseRows = csvParseRows;
      exports.csvFormat = csvFormat;
      exports.csvFormatRows = csvFormatRows;
      exports.tsvParse = tsvParse;
      exports.tsvParseRows = tsvParseRows;
      exports.tsvFormat = tsvFormat;
      exports.tsvFormatRows = tsvFormatRows;
      exports.request = request;
      exports.html = html;
      exports.json = json;
      exports.text = text;
      exports.xml = xml;
      exports.csv = csv$1;
      exports.tsv = tsv$1;
      exports.now = now;
      exports.timer = timer;
      exports.timerFlush = timerFlush;
      exports.timeout = timeout$1;
      exports.interval = interval$1;
      exports.timeInterval = newInterval;
      exports.timeMillisecond = millisecond;
      exports.timeMilliseconds = milliseconds;
      exports.timeSecond = second;
      exports.timeSeconds = seconds;
      exports.timeMinute = minute;
      exports.timeMinutes = minutes;
      exports.timeHour = hour;
      exports.timeHours = hours;
      exports.timeDay = day;
      exports.timeDays = days;
      exports.timeWeek = sunday;
      exports.timeWeeks = sundays;
      exports.timeSunday = sunday;
      exports.timeSundays = sundays;
      exports.timeMonday = monday;
      exports.timeMondays = mondays;
      exports.timeTuesday = tuesday;
      exports.timeTuesdays = tuesdays;
      exports.timeWednesday = wednesday;
      exports.timeWednesdays = wednesdays;
      exports.timeThursday = thursday;
      exports.timeThursdays = thursdays;
      exports.timeFriday = friday;
      exports.timeFridays = fridays;
      exports.timeSaturday = saturday;
      exports.timeSaturdays = saturdays;
      exports.timeMonth = month;
      exports.timeMonths = months;
      exports.timeYear = year;
      exports.timeYears = years;
      exports.utcMillisecond = millisecond;
      exports.utcMilliseconds = milliseconds;
      exports.utcSecond = second;
      exports.utcSeconds = seconds;
      exports.utcMinute = utcMinute;
      exports.utcMinutes = utcMinutes;
      exports.utcHour = utcHour;
      exports.utcHours = utcHours;
      exports.utcDay = utcDay;
      exports.utcDays = utcDays;
      exports.utcWeek = utcSunday;
      exports.utcWeeks = utcSundays;
      exports.utcSunday = utcSunday;
      exports.utcSundays = utcSundays;
      exports.utcMonday = utcMonday;
      exports.utcMondays = utcMondays;
      exports.utcTuesday = utcTuesday;
      exports.utcTuesdays = utcTuesdays;
      exports.utcWednesday = utcWednesday;
      exports.utcWednesdays = utcWednesdays;
      exports.utcThursday = utcThursday;
      exports.utcThursdays = utcThursdays;
      exports.utcFriday = utcFriday;
      exports.utcFridays = utcFridays;
      exports.utcSaturday = utcSaturday;
      exports.utcSaturdays = utcSaturdays;
      exports.utcMonth = utcMonth;
      exports.utcMonths = utcMonths;
      exports.utcYear = utcYear;
      exports.utcYears = utcYears;
      exports.formatLocale = formatLocale;
      exports.formatDefaultLocale = defaultLocale;
      exports.formatSpecifier = formatSpecifier;
      exports.precisionFixed = precisionFixed;
      exports.precisionPrefix = precisionPrefix;
      exports.precisionRound = precisionRound;
      exports.isoFormat = formatIso;
      exports.isoParse = parseIso;
      exports.timeFormatLocale = formatLocale$1;
      exports.timeFormatDefaultLocale = defaultLocale$1;
      exports.scaleBand = band;
      exports.scalePoint = point$4;
      exports.scaleIdentity = identity$4;
      exports.scaleLinear = linear$2;
      exports.scaleLog = log;
      exports.scaleOrdinal = ordinal;
      exports.scaleImplicit = implicit;
      exports.scalePow = pow;
      exports.scaleSqrt = sqrt;
      exports.scaleQuantile = quantile$$1;
      exports.scaleQuantize = quantize$1;
      exports.scaleThreshold = threshold$1;
      exports.scaleTime = time;
      exports.scaleUtc = utcTime;
      exports.schemeCategory10 = category10;
      exports.schemeCategory20b = category20b;
      exports.schemeCategory20c = category20c;
      exports.schemeCategory20 = category20;
      exports.scaleSequential = sequential;
      exports.interpolateCubehelixDefault = cubehelix$3;
      exports.interpolateRainbow = rainbow$1;
      exports.interpolateWarm = warm;
      exports.interpolateCool = cool;
      exports.interpolateViridis = viridis;
      exports.interpolateMagma = magma;
      exports.interpolateInferno = inferno;
      exports.interpolatePlasma = plasma;
      exports.creator = creator;
      exports.customEvent = customEvent;
      exports.local = local;
      exports.matcher = matcher$1;
      exports.mouse = mouse;
      exports.namespace = namespace;
      exports.namespaces = namespaces;
      exports.select = select;
      exports.selectAll = selectAll;
      exports.selection = selection;
      exports.selector = selector;
      exports.selectorAll = selectorAll;
      exports.touch = touch;
      exports.touches = touches;
      exports.window = window;
      exports.active = active;
      exports.interrupt = interrupt;
      exports.transition = transition;
      exports.axisTop = axisTop;
      exports.axisRight = axisRight;
      exports.axisBottom = axisBottom;
      exports.axisLeft = axisLeft;
      exports.cluster = cluster;
      exports.hierarchy = hierarchy;
      exports.pack = index;
      exports.packSiblings = siblings;
      exports.packEnclose = enclose;
      exports.partition = partition;
      exports.stratify = stratify;
      exports.tree = tree;
      exports.treemap = index$1;
      exports.treemapBinary = binary;
      exports.treemapDice = treemapDice;
      exports.treemapSlice = treemapSlice;
      exports.treemapSliceDice = sliceDice;
      exports.treemapSquarify = squarify;
      exports.treemapResquarify = resquarify;
      exports.forceCenter = center$1;
      exports.forceCollide = collide;
      exports.forceLink = link;
      exports.forceManyBody = manyBody;
      exports.forceSimulation = simulation;
      exports.forceX = x$3;
      exports.forceY = y$3;
      exports.drag = drag;
      exports.dragDisable = dragDisable;
      exports.dragEnable = yesdrag;
      exports.voronoi = voronoi;
      exports.zoom = zoom;
      exports.zoomIdentity = identity$6;
      exports.zoomTransform = transform;
      exports.brush = brush;
      exports.brushX = brushX;
      exports.brushY = brushY;
      exports.brushSelection = brushSelection;
      exports.chord = chord;
      exports.ribbon = ribbon;
      exports.geoAlbers = albers;
      exports.geoAlbersUsa = albersUsa;
      exports.geoArea = area$2;
      exports.geoAzimuthalEqualArea = azimuthalEqualArea;
      exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
      exports.geoAzimuthalEquidistant = azimuthalEquidistant;
      exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
      exports.geoBounds = bounds;
      exports.geoCentroid = centroid$1;
      exports.geoCircle = circle$1;
      exports.geoClipExtent = extent$1;
      exports.geoConicConformal = conicConformal;
      exports.geoConicConformalRaw = conicConformalRaw;
      exports.geoConicEqualArea = conicEqualArea;
      exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
      exports.geoConicEquidistant = conicEquidistant;
      exports.geoConicEquidistantRaw = conicEquidistantRaw;
      exports.geoDistance = distance;
      exports.geoEquirectangular = equirectangular;
      exports.geoEquirectangularRaw = equirectangularRaw;
      exports.geoGnomonic = gnomonic;
      exports.geoGnomonicRaw = gnomonicRaw;
      exports.geoGraticule = graticule;
      exports.geoGraticule10 = graticule10;
      exports.geoIdentity = identity$8;
      exports.geoInterpolate = interpolate$2;
      exports.geoLength = length$2;
      exports.geoMercator = mercator;
      exports.geoMercatorRaw = mercatorRaw;
      exports.geoOrthographic = orthographic;
      exports.geoOrthographicRaw = orthographicRaw;
      exports.geoPath = index$3;
      exports.geoProjection = projection;
      exports.geoProjectionMutator = projectionMutator;
      exports.geoRotation = rotation;
      exports.geoStereographic = stereographic;
      exports.geoStereographicRaw = stereographicRaw;
      exports.geoStream = geoStream;
      exports.geoTransform = transform$1;
      exports.geoTransverseMercator = transverseMercator;
      exports.geoTransverseMercatorRaw = transverseMercatorRaw;
      Object.defineProperty(exports, '__esModule', { value: true });
    });
  })($__require('github:jspm/nodelibs-buffer@0.1.0.js').Buffer, $__require('github:jspm/nodelibs-process@0.1.2.js'));
});
System.registerDynamic("npm:d3@4.4.0.js", ["npm:d3@4.4.0/build/d3.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:d3@4.4.0/build/d3.js");
});
System.register('src/call-wrapper.js', ['npm:babel-runtime@5.8.38/helpers/create-class.js', 'npm:babel-runtime@5.8.38/helpers/class-call-check.js', 'npm:babel-runtime@5.8.38/core-js/object/create.js', 'npm:babel-runtime@5.8.38/core-js/object/assign.js', 'src/utils.js'], function (_export) {
    var _createClass, _classCallCheck, _Object$create, _Object$assign, delegate, nextId, CallWrapper;

    return {
        setters: [function (_npmBabelRuntime5838HelpersCreateClassJs) {
            _createClass = _npmBabelRuntime5838HelpersCreateClassJs['default'];
        }, function (_npmBabelRuntime5838HelpersClassCallCheckJs) {
            _classCallCheck = _npmBabelRuntime5838HelpersClassCallCheckJs['default'];
        }, function (_npmBabelRuntime5838CoreJsObjectCreateJs) {
            _Object$create = _npmBabelRuntime5838CoreJsObjectCreateJs['default'];
        }, function (_npmBabelRuntime5838CoreJsObjectAssignJs) {
            _Object$assign = _npmBabelRuntime5838CoreJsObjectAssignJs['default'];
        }, function (_srcUtilsJs) {
            delegate = _srcUtilsJs.delegate;
        }],
        execute: function () {
            'use strict';

            nextId = 0;

            CallWrapper = (function () {
                function CallWrapper(call, visualization) {
                    _classCallCheck(this, CallWrapper);

                    this._call = call;
                    this._visualization = visualization;

                    this.id = nextId++;
                    this.infos = [];
                    this._cached = _Object$create(null);

                    this._proxy = new Proxy(this, delegate(this, ['_call', '_visualization']));
                    return this._proxy;
                }

                _createClass(CallWrapper, [{
                    key: '_clearCache',
                    value: function _clearCache() {
                        var prop = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

                        if (prop !== null) {
                            delete this.cached[prop];
                        } else {
                            this._cached = _Object$assign(_Object$create(null), EVENT_WRAPPER_CACHED_DEFAULTS);
                        }
                    }
                }, {
                    key: 'level',
                    get: function get() {
                        if ('level' in this._cached) {
                            return this._cached.level;
                        }

                        if (this._call.parent === null) {
                            return this._cached.level = 1;
                        } else {
                            return this._cached.level = this.parent.level + 1;
                        }
                    }
                }, {
                    key: 'parent',
                    get: function get() {
                        if ('parent' in this._cached) {
                            return this._cached.parent;
                        } else {
                            return null; // TODO: may want to lazily wrap parent as well
                        }
                    }
                }, {
                    key: 'children',
                    get: function get() {
                        var _this = this;

                        if ('children' in this._cached) {
                            return this._cached.children;
                        }

                        this._cached.children = this._call.children.map(function (child) {
                            var ans = new CallWrapper(child, _this._visualization);
                            ans._cached.parent = _this._proxy;
                            return ans;
                        });
                        return this._cached.children;
                    }
                }]);

                return CallWrapper;
            })();

            _export('default', CallWrapper);
        }
    };
});
System.register('src/selection-wrapper.js', ['npm:babel-runtime@5.8.38/helpers/create-class.js', 'npm:babel-runtime@5.8.38/helpers/class-call-check.js', 'src/utils.js'], function (_export) {
    var _createClass, _classCallCheck, delegate, SelectionWrapper;

    return {
        setters: [function (_npmBabelRuntime5838HelpersCreateClassJs) {
            _createClass = _npmBabelRuntime5838HelpersCreateClassJs['default'];
        }, function (_npmBabelRuntime5838HelpersClassCallCheckJs) {
            _classCallCheck = _npmBabelRuntime5838HelpersClassCallCheckJs['default'];
        }, function (_srcUtilsJs) {
            delegate = _srcUtilsJs.delegate;
        }],
        execute: function () {
            'use strict';

            SelectionWrapper = (function () {
                function SelectionWrapper(selection, visualization) {
                    _classCallCheck(this, SelectionWrapper);

                    this._selection = selection;
                    this._visualization = visualization;
                    this.swatchIndex = 1;

                    this._proxy = new Proxy(this, delegate(this, ['_selection', '_visualization']));
                    return this._proxy;
                }

                _createClass(SelectionWrapper, [{
                    key: 'refresh',
                    value: function refresh() {
                        this._visualization.update();
                    }
                }, {
                    key: 'query',
                    value: function query(predicate) {
                        return new SelectionWrapper(this._selection.filter(function (wrapped) {
                            return predicate(wrapped._call);
                        }), this._visualization);
                    }
                }, {
                    key: 'forEach',
                    value: function forEach(fn) {
                        this._selection.each(function (wrapped) {
                            return fn(wrapped._call);
                        });
                        return this;
                    }
                }, {
                    key: 'info',
                    value: function info(property) {
                        this._selection.each(function (wrapped) {
                            wrapped.infos.push(property(wrapped._call));
                        });
                        return this;
                    }
                }, {
                    key: 'clearInfos',
                    value: function clearInfos() {
                        this._selection.each(function (wrapped) {
                            wrapped.infos = [];
                        });
                        return this;
                    }
                }, {
                    key: 'collapse',
                    value: function collapse() {
                        var collapsed = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

                        this._selection.each(function (wrapped) {
                            wrapped.collapsed = collapsed;
                        });
                        return this;
                    }
                }, {
                    key: 'collapseAll',
                    value: function collapseAll() {
                        var collapsed = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

                        this._selection.each(function (wrapped) {
                            breadthFirstTraversal(wrapped, function (node) {
                                node.collapsed = collapsed;
                            });
                        });
                        return this;
                    }
                }, {
                    key: 'nextSwatch',
                    value: function nextSwatch() {
                        var index = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

                        if (index !== null) {
                            this.swatchIndex = index;
                        }
                        return this._selection.style('background-color', swatches(this.swatchIndex++ % 6));
                    }
                }]);

                return SelectionWrapper;
            })();

            _export('default', SelectionWrapper);
        }
    };
});
System.register("src/flame-graph.js", ["npm:babel-runtime@5.8.38/helpers/create-class.js", "npm:babel-runtime@5.8.38/helpers/class-call-check.js", "npm:babel-runtime@5.8.38/helpers/to-consumable-array.js", "npm:babel-runtime@5.8.38/core-js/weak-map.js", "npm:babel-runtime@5.8.38/core-js/object/create.js", "src/utils.js", "npm:d3@4.4.0.js", "src/call-wrapper.js", "src/selection-wrapper.js"], function (_export) {
    var _createClass, _classCallCheck, _toConsumableArray, _WeakMap, _Object$create, $, deepFreeze, breadthFirstTraversal, depthFirstTraversal, DOM, d3, CallWrapper, SelectionWrapper, FlameGraph, swatches;

    function markEditor(editor, fn) {
        if (fn.location == null) {
            return;
        }

        editor.markText({ line: fn.location.start.line - 1, ch: fn.location.start.column }, { line: fn.location.end.line - 1, ch: fn.location.end.column }, { className: 'highlight' });
    }

    function clearEditorMarks(editor) {
        editor.getAllMarks().forEach(function (mark) {
            return mark.clear();
        });
    }

    return {
        setters: [function (_npmBabelRuntime5838HelpersCreateClassJs) {
            _createClass = _npmBabelRuntime5838HelpersCreateClassJs["default"];
        }, function (_npmBabelRuntime5838HelpersClassCallCheckJs) {
            _classCallCheck = _npmBabelRuntime5838HelpersClassCallCheckJs["default"];
        }, function (_npmBabelRuntime5838HelpersToConsumableArrayJs) {
            _toConsumableArray = _npmBabelRuntime5838HelpersToConsumableArrayJs["default"];
        }, function (_npmBabelRuntime5838CoreJsWeakMapJs) {
            _WeakMap = _npmBabelRuntime5838CoreJsWeakMapJs["default"];
        }, function (_npmBabelRuntime5838CoreJsObjectCreateJs) {
            _Object$create = _npmBabelRuntime5838CoreJsObjectCreateJs["default"];
        }, function (_srcUtilsJs) {
            $ = _srcUtilsJs.$;
            deepFreeze = _srcUtilsJs.deepFreeze;
            breadthFirstTraversal = _srcUtilsJs.breadthFirstTraversal;
            depthFirstTraversal = _srcUtilsJs.depthFirstTraversal;
            DOM = _srcUtilsJs.DOM;
        }, function (_npmD3440Js) {
            d3 = _npmD3440Js;
        }, function (_srcCallWrapperJs) {
            CallWrapper = _srcCallWrapperJs["default"];
        }, function (_srcSelectionWrapperJs) {
            SelectionWrapper = _srcSelectionWrapperJs["default"];
        }],
        execute: function () {

            // binary chop
            // function wrap(width, padding) {
            //     let memo = {};
            //     return function() {
            //         let self = d3.select(this),
            //             textLength = self.node().getComputedTextLength(),
            //             text = self.text(),
            //             origText = text;

            //         if (memo.hasOwnProperty(origText)) {
            //             self.text(memo[origText]);
            //         } else {
            //             while (textLength > (width - (2 * padding)) && text.length > 0) {
            //                 text = text.slice(0, -1);
            //                 self.text(text + '…');
            //                 textLength = self.node().getComputedTextLength();
            //             }
            //             memo[origText] = self.text();
            //         }
            //     };
            // }

            "use strict";

            window.d3 = d3;

            FlameGraph = (function () {
                function FlameGraph(container, editor, calls) {
                    var _this = this;

                    _classCallCheck(this, FlameGraph);

                    this.currentFunction = null;
                    this.container = container;
                    this.editor = editor;

                    this.rootCall = new CallWrapper(calls, this);
                    this.flatCalls = [];
                    depthFirstTraversal(this.rootCall, function (call) {
                        _this.flatCalls.push(call);
                    });

                    this.callToElement = new _WeakMap();
                    this.elementToCall = new _WeakMap();
                    this._cached = _Object$create(null);

                    this.styles = {
                        "default": {
                            maxWidth: null,
                            paddingLeft: 5,
                            paddingRight: 5,
                            paddingTop: 5,
                            paddingBottom: 5,
                            marginBottom: 3,
                            marginRight: 0
                        },
                        label: {
                            fontFamily: 'Cooper Hewitt, Helvetica, Arial, sans-serif',
                            fontSize: '14px',
                            paddingBottom: 1
                        },
                        info: {
                            fontFamily: 'Bookerly, Input Serif, serif',
                            fontSize: '8px',
                            paddingBottom: 2
                        },
                        stack: {
                            fontWeight: 600
                        },
                        collapsed: {
                            width: 3,
                            minHeight: 3,
                            marginBottom: 2,
                            marginLeft: 1,
                            marginRight: 0
                        }
                    };
                    deepFreeze(this.styles);
                }

                _createClass(FlameGraph, [{
                    key: "_clearCache",
                    value: function _clearCache() {
                        this._cached = _Object$create(null);
                    }
                }, {
                    key: "_clearCallsCache",
                    value: function _clearCallsCache() {
                        depthFirstTraversal(this.events, function (call) {
                            call._clearCache();
                        });
                    }
                }, {
                    key: "render",
                    value: function render() {
                        var _this2 = this;

                        var that = this;

                        breadthFirstTraversal(this.rootCall, function (call) {
                            var element = FlameGraph._makeElement(call);

                            _this2.callToElement.set(call, element);
                            _this2.elementToCall.set(element, call);

                            if (call.parent === null) {
                                _this2.container.appendChild(element);
                            } else {
                                var parentElement = _this2.callToElement.get(call.parent);
                                parentElement.querySelector('div.children').appendChild(element);
                            }
                        });

                        this.selection.on('mouseover', function (call) {
                            that.currentFunction = call;
                            markEditor(that.editor, that.currentFunction);
                            d3.select(that.callToElement.get(that.currentFunction)).classed('currentFunction', true);

                            var current = that.currentFunction;
                            while (current !== null) {
                                d3.select(that.callToElement.get(current)).classed('callStack', true);
                                current = current.parent;
                            }
                        }).on('mouseout', function (call) {
                            clearEditorMarks(that.editor);
                            d3.select(that.callToElement.get(that.currentFunction)).classed('currentFunction', false);

                            var current = that.currentFunction;
                            that.currentFunction = null;
                            while (current !== null) {
                                d3.select(that.callToElement.get(current)).classed('callStack', false);
                                current = current.parent;
                            }
                        });
                    }
                }, {
                    key: "update",
                    value: function update() {
                        var selection = this.selection;

                        selection.classed('collapsed', function (wrapper) {
                            return wrapper.collapsed;
                        });

                        var infos = selection.select('ul.infos').selectAll('li.info').data(function (wrapper) {
                            return wrapper.infos;
                        });

                        infos.enter().append('li').classed('info', true).merge(infos).text(function (info) {
                            return info;
                        }).exit().remove();
                    }
                }, {
                    key: "data",
                    get: function get() {
                        return new SelectionWrapper(this.selection, this);
                    }
                }, {
                    key: "selection",
                    get: function get() {
                        var _this3 = this;

                        if ('selection' in this._cached) {
                            return this._cached.selection;
                        } else {
                            var _ret = (function () {
                                var that = _this3;
                                return {
                                    v: _this3._cached.selection = d3.select(_this3.container).selectAll('div.contents').data(_this3.flatCalls, function (call) {
                                        return call ? call.id : that.elementToCall.get(this.parentElement).id;
                                    })
                                };
                            })();

                            if (typeof _ret === "object") return _ret.v;
                        }
                    }
                }], [{
                    key: "_makeElement",
                    value: function _makeElement(call) {
                        /**
                         * <div class="call">
                         *   <div class="contents">
                         *     <span class="label">ProgramExecution</span>
                         *     <ul class="infos">
                         *       <li class="info">runtime: 5s</li>
                         *     </ul>
                         *   </div>
                         *   <div class="children">
                         *     <div class="event">...</div>
                         *     ...
                         *   </div>
                         * </div>
                         */

                        var ans = DOM('div.call', FlameGraph._makeContent(call), DOM('div.children'));
                        ans.__call__ = call;
                        return ans;
                    }
                }, {
                    key: "_makeContent",
                    value: function _makeContent(call) {
                        /**
                         *   <div class="contents">
                         *     <div class="label">ProgramExecution</span>
                         *     <ul class="infos">
                         *       <li class="info">runtime: 5s</li>
                         *     </ul>
                         *   </div>
                         */

                        var label = DOM('div.label', call.fnName);
                        label.setAttribute('title', call.fnName);
                        var ans = DOM('div.contents', label, DOM.apply(undefined, ['ul.infos'].concat(_toConsumableArray(call.infos.map(function (info) {
                            return DOM('li.info', info);
                        })))));
                        ans.setAttribute('title', call.fnName);
                        return ans;
                    }
                }]);

                return FlameGraph;
            })();

            _export("default", FlameGraph);

            swatches = d3.scaleLinear().domain([1, 7]).range([d3.hcl(0, 30, 90), d3.hcl(360, 30, 90)]).interpolate(d3.interpolateHclLong);

            _export("swatches", swatches);
        }
    };
});
System.register('src/query-lib.js', ['src/utils.js'], function (_export) {
    'use strict';

    var deepEquals, swatchIndex;

    _export('oneOffFromBaseCase', oneOffFromBaseCase);

    _export('baseCase', baseCase);

    _export('rootCase', rootCase);

    _export('callsWithSameArgument', callsWithSameArgument);

    _export('nCallsFromParent', nCallsFromParent);

    _export('nextSwatch', nextSwatch);

    function oneOffFromBaseCase(fnName) {
        return query(function (call) {
            return call.fnName === fnName && call.children.every(function (child) {
                return child.fnName !== fnName || baseCase(fnName)(child);
            });
        });
    }

    function baseCase(fnName) {
        return function (call) {
            return call.fnName === fnName && call.children.every(function (child) {
                return child.fnName !== fnName;
            });
        };
    }

    function rootCase(fnName) {
        return function (call) {
            return call.fnName === fnName && call.parent.fnName !== fnName;
        };
    }

    function callsWithSameArgument(fnName) {
        var sameArg = {};
        var argSets = [];
        forEachCall(function (call) {
            var c = argSets.find(function (c) {
                return deepEquals(c.args, call.args);
            });
            if (c !== undefined) {
                sameArg[c.uid] = true;
                sameArg[call.uid] = true;
            } else {
                sameArg[call.uid] = false;
                argSets.push(call);
            }
        }, function (call) {
            return call.fnName === fnName;
        });
        return function (call) {
            return sameArg[call.uid];
        };
    }

    function nCallsFromParent(fnName, n) {
        var sameParent = {};
        forEachCall(function (call) {
            if (call.parent !== null && !sameParent.hasOwnProperty(call.parent.uid)) {
                sameParent[call.parent.uid] = 1;
            } else if (call.parent !== null) {
                sameParent[call.parent.uid]++;
            }
        }, function (call) {
            return call.fnName === fnName;
        });
        return function (call) {
            return call.parent !== null && call.fnName === fnName && sameParent[call.parent.uid] === n;
        };
    }

    function nextSwatch(query) {
        var index = swatchIndex++;
        query.select('rect').style('fill', swatches(index % 6));
    }

    return {
        setters: [function (_srcUtilsJs) {
            deepEquals = _srcUtilsJs.deepEquals;
        }],
        execute: function () {
            swatchIndex = 1;
        }
    };
});
System.register("src/coderunnerworker.js!github:casperlamboo/plugin-worker@master.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      const codeStr = "!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError(\"Mixed dependency cycle detected\");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,\"object\"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},{id:r.name});t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error(\"Unable to load dependency \"+e+\".\");return(!t||t.declarative)&&r&&r.__useDefault?r[\"default\"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError(\"Module \"+e+\" not declared as a dependency.\")},t,n);void 0!==c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if((\"object\"==typeof r||\"function\"==typeof r)&&r!==e)if(m)for(var n in r)\"default\"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)\"default\"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t[\"default\"]=r,x(t,\"__useDefault\",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if(\"@node/\"==e.substr(0,6))return I[e]=s(D(e.substr(6)));var r=v[e];if(!r)throw\"Module \"+e+\" not present.\";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,\"__esModule\",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},\"a\")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},\"a\",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D=\"undefined\"!=typeof System&&System._nodeRequire||\"undefined\"!=typeof require&&\"undefined\"!=typeof require.resolve&&\"undefined\"!=typeof process&&process.platform&&require,I={\"@empty\":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l[\"default\"]:l})}}}(\"undefined\"!=typeof self?self:global)\n\n([\"1\"], [], false, function($__System) {\nvar require = this.require, exports = this.exports, module = this.module;\n$__System.registerDynamic('2', ['3'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var $ = $__require('3');\n  module.exports = function defineProperty(it, key, desc) {\n    return $.setDesc(it, key, desc);\n  };\n});\n$__System.registerDynamic(\"4\", [\"2\"], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = { \"default\": $__require(\"2\"), __esModule: true };\n});\n$__System.registerDynamic(\"5\", [\"4\"], true, function ($__require, exports, module) {\n  /* */\n  \"use strict\";\n\n  var global = this || self,\n      GLOBAL = global;\n  var _Object$defineProperty = $__require(\"4\")[\"default\"];\n  exports[\"default\"] = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        _Object$defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n  exports.__esModule = true;\n});\n$__System.registerDynamic('6', ['7', '8', '9', 'a'], true, function ($__require, exports, module) {\n    var global = this || self,\n        GLOBAL = global;\n    /* */\n    var classof = $__require('7'),\n        ITERATOR = $__require('8')('iterator'),\n        Iterators = $__require('9');\n    module.exports = $__require('a').getIteratorMethod = function (it) {\n        if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];\n    };\n});\n$__System.registerDynamic('b', ['c', '6', 'a'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var anObject = $__require('c'),\n      get = $__require('6');\n  module.exports = $__require('a').getIterator = function (it) {\n    var iterFn = get(it);\n    if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');\n    return anObject(iterFn.call(it));\n  };\n});\n$__System.registerDynamic('d', ['e', 'f', 'b'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  $__require('e');\n  $__require('f');\n  module.exports = $__require('b');\n});\n$__System.registerDynamic(\"10\", [\"d\"], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = { \"default\": $__require(\"d\"), __esModule: true };\n});\n$__System.registerDynamic(\"11\", [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = function () {/* empty */};\n});\n$__System.registerDynamic(\"12\", [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = function (done, value) {\n    return { value: value, done: !!done };\n  };\n});\n$__System.registerDynamic('13', ['11', '12', '9', '14', '15'], true, function ($__require, exports, module) {\n  /* */\n  'use strict';\n\n  var global = this || self,\n      GLOBAL = global;\n  var addToUnscopables = $__require('11'),\n      step = $__require('12'),\n      Iterators = $__require('9'),\n      toIObject = $__require('14');\n  module.exports = $__require('15')(Array, 'Array', function (iterated, kind) {\n    this._t = toIObject(iterated);\n    this._i = 0;\n    this._k = kind;\n  }, function () {\n    var O = this._t,\n        kind = this._k,\n        index = this._i++;\n    if (!O || index >= O.length) {\n      this._t = undefined;\n      return step(1);\n    }\n    if (kind == 'keys') return step(0, index);\n    if (kind == 'values') return step(0, O[index]);\n    return step(0, [index, O[index]]);\n  }, 'values');\n  Iterators.Arguments = Iterators.Array;\n  addToUnscopables('keys');\n  addToUnscopables('values');\n  addToUnscopables('entries');\n});\n$__System.registerDynamic('e', ['13', '9'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  $__require('13');\n  var Iterators = $__require('9');\n  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;\n});\n$__System.registerDynamic(\"16\", [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  // 7.1.4 ToInteger\n  var ceil = Math.ceil,\n      floor = Math.floor;\n  module.exports = function (it) {\n    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n  };\n});\n$__System.registerDynamic('17', ['16', '18'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var toInteger = $__require('16'),\n      defined = $__require('18');\n  module.exports = function (TO_STRING) {\n    return function (that, pos) {\n      var s = String(defined(that)),\n          i = toInteger(pos),\n          l = s.length,\n          a,\n          b;\n      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n      a = s.charCodeAt(i);\n      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n    };\n  };\n});\n$__System.registerDynamic(\"19\", [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = true;\n});\n$__System.registerDynamic('1a', ['1b'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = $__require('1b');\n});\n$__System.registerDynamic(\"1c\", [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = function (bitmap, value) {\n    return {\n      enumerable: !(bitmap & 1),\n      configurable: !(bitmap & 2),\n      writable: !(bitmap & 4),\n      value: value\n    };\n  };\n});\n$__System.registerDynamic('1d', ['1e'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = !$__require('1e')(function () {\n    return Object.defineProperty({}, 'a', { get: function () {\n        return 7;\n      } }).a != 7;\n  });\n});\n$__System.registerDynamic('1b', ['3', '1c', '1d'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var $ = $__require('3'),\n      createDesc = $__require('1c');\n  module.exports = $__require('1d') ? function (object, key, value) {\n    return $.setDesc(object, key, createDesc(1, value));\n  } : function (object, key, value) {\n    object[key] = value;\n    return object;\n  };\n});\n$__System.registerDynamic('1f', ['3', '1c', '20', '1b', '8'], true, function ($__require, exports, module) {\n  /* */\n  'use strict';\n\n  var global = this || self,\n      GLOBAL = global;\n  var $ = $__require('3'),\n      descriptor = $__require('1c'),\n      setToStringTag = $__require('20'),\n      IteratorPrototype = {};\n  $__require('1b')(IteratorPrototype, $__require('8')('iterator'), function () {\n    return this;\n  });\n  module.exports = function (Constructor, NAME, next) {\n    Constructor.prototype = $.create(IteratorPrototype, { next: descriptor(1, next) });\n    setToStringTag(Constructor, NAME + ' Iterator');\n  };\n});\n$__System.registerDynamic(\"21\", [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var hasOwnProperty = {}.hasOwnProperty;\n  module.exports = function (it, key) {\n    return hasOwnProperty.call(it, key);\n  };\n});\n$__System.registerDynamic('20', ['3', '21', '8'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var def = $__require('3').setDesc,\n      has = $__require('21'),\n      TAG = $__require('8')('toStringTag');\n  module.exports = function (it, tag, stat) {\n    if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {\n      configurable: true,\n      value: tag\n    });\n  };\n});\n$__System.registerDynamic('15', ['19', '22', '1a', '1b', '21', '9', '1f', '20', '3', '8'], true, function ($__require, exports, module) {\n  /* */\n  'use strict';\n\n  var global = this || self,\n      GLOBAL = global;\n  var LIBRARY = $__require('19'),\n      $export = $__require('22'),\n      redefine = $__require('1a'),\n      hide = $__require('1b'),\n      has = $__require('21'),\n      Iterators = $__require('9'),\n      $iterCreate = $__require('1f'),\n      setToStringTag = $__require('20'),\n      getProto = $__require('3').getProto,\n      ITERATOR = $__require('8')('iterator'),\n      BUGGY = !([].keys && 'next' in [].keys()),\n      FF_ITERATOR = '@@iterator',\n      KEYS = 'keys',\n      VALUES = 'values';\n  var returnThis = function () {\n    return this;\n  };\n  module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n    $iterCreate(Constructor, NAME, next);\n    var getMethod = function (kind) {\n      if (!BUGGY && kind in proto) return proto[kind];\n      switch (kind) {\n        case KEYS:\n          return function keys() {\n            return new Constructor(this, kind);\n          };\n        case VALUES:\n          return function values() {\n            return new Constructor(this, kind);\n          };\n      }\n      return function entries() {\n        return new Constructor(this, kind);\n      };\n    };\n    var TAG = NAME + ' Iterator',\n        DEF_VALUES = DEFAULT == VALUES,\n        VALUES_BUG = false,\n        proto = Base.prototype,\n        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],\n        $default = $native || getMethod(DEFAULT),\n        methods,\n        key;\n    if ($native) {\n      var IteratorPrototype = getProto($default.call(new Base()));\n      setToStringTag(IteratorPrototype, TAG, true);\n      if (!LIBRARY && has(proto, FF_ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n      if (DEF_VALUES && $native.name !== VALUES) {\n        VALUES_BUG = true;\n        $default = function values() {\n          return $native.call(this);\n        };\n      }\n    }\n    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n      hide(proto, ITERATOR, $default);\n    }\n    Iterators[NAME] = $default;\n    Iterators[TAG] = returnThis;\n    if (DEFAULT) {\n      methods = {\n        values: DEF_VALUES ? $default : getMethod(VALUES),\n        keys: IS_SET ? $default : getMethod(KEYS),\n        entries: !DEF_VALUES ? $default : getMethod('entries')\n      };\n      if (FORCED) for (key in methods) {\n        if (!(key in proto)) redefine(proto, key, methods[key]);\n      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n    }\n    return methods;\n  };\n});\n$__System.registerDynamic('f', ['17', '15'], true, function ($__require, exports, module) {\n  /* */\n  'use strict';\n\n  var global = this || self,\n      GLOBAL = global;\n  var $at = $__require('17')(true);\n  $__require('15')(String, 'String', function (iterated) {\n    this._t = String(iterated);\n    this._i = 0;\n  }, function () {\n    var O = this._t,\n        index = this._i,\n        point;\n    if (index >= O.length) return {\n      value: undefined,\n      done: true\n    };\n    point = $at(O, index);\n    this._i += point.length;\n    return {\n      value: point,\n      done: false\n    };\n  });\n});\n$__System.registerDynamic('7', ['23', '8'], true, function ($__require, exports, module) {\n    var global = this || self,\n        GLOBAL = global;\n    /* */\n    var cof = $__require('23'),\n        TAG = $__require('8')('toStringTag'),\n        ARG = cof(function () {\n        return arguments;\n    }()) == 'Arguments';\n    module.exports = function (it) {\n        var O, T, B;\n        return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n    };\n});\n$__System.registerDynamic('24', ['25'], true, function ($__require, exports, module) {\n    var global = this || self,\n        GLOBAL = global;\n    /* */\n    var global = $__require('25'),\n        SHARED = '__core-js_shared__',\n        store = global[SHARED] || (global[SHARED] = {});\n    module.exports = function (key) {\n        return store[key] || (store[key] = {});\n    };\n});\n$__System.registerDynamic('26', [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var id = 0,\n      px = Math.random();\n  module.exports = function (key) {\n    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n  };\n});\n$__System.registerDynamic('8', ['24', '26', '25'], true, function ($__require, exports, module) {\n    var global = this || self,\n        GLOBAL = global;\n    /* */\n    var store = $__require('24')('wks'),\n        uid = $__require('26'),\n        Symbol = $__require('25').Symbol;\n    module.exports = function (name) {\n        return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));\n    };\n});\n$__System.registerDynamic(\"9\", [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = {};\n});\n$__System.registerDynamic('27', ['7', '8', '9', 'a'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var classof = $__require('7'),\n      ITERATOR = $__require('8')('iterator'),\n      Iterators = $__require('9');\n  module.exports = $__require('a').isIterable = function (it) {\n    var O = Object(it);\n    return O[ITERATOR] !== undefined || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));\n  };\n});\n$__System.registerDynamic('28', ['e', 'f', '27'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  $__require('e');\n  $__require('f');\n  module.exports = $__require('27');\n});\n$__System.registerDynamic(\"29\", [\"28\"], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = { \"default\": $__require(\"28\"), __esModule: true };\n});\n$__System.registerDynamic(\"2a\", [\"10\", \"29\"], true, function ($__require, exports, module) {\n  /* */\n  \"use strict\";\n\n  var global = this || self,\n      GLOBAL = global;\n  var _getIterator = $__require(\"10\")[\"default\"];\n  var _isIterable = $__require(\"29\")[\"default\"];\n  exports[\"default\"] = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n      try {\n        for (var _i = _getIterator(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n      return _arr;\n    }\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (_isIterable(Object(arr))) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  }();\n  exports.__esModule = true;\n});\n$__System.registerDynamic('2b', ['2c', '2d'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var toObject = $__require('2c');\n  $__require('2d')('keys', function ($keys) {\n    return function keys(it) {\n      return $keys(toObject(it));\n    };\n  });\n});\n$__System.registerDynamic('2e', ['2b', 'a'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  $__require('2b');\n  module.exports = $__require('a').Object.keys;\n});\n$__System.registerDynamic(\"2f\", [\"2e\"], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = { \"default\": $__require(\"2e\"), __esModule: true };\n});\n$__System.registerDynamic('30', ['14', '3'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var toIObject = $__require('14'),\n      getNames = $__require('3').getNames,\n      toString = {}.toString;\n  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\n  var getWindowNames = function (it) {\n    try {\n      return getNames(it);\n    } catch (e) {\n      return windowNames.slice();\n    }\n  };\n  module.exports.get = function getOwnPropertyNames(it) {\n    if (windowNames && toString.call(it) == '[object Window]') return getWindowNames(it);\n    return getNames(toIObject(it));\n  };\n});\n$__System.registerDynamic('31', ['2d', '30'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  $__require('2d')('getOwnPropertyNames', function () {\n    return $__require('30').get;\n  });\n});\n$__System.registerDynamic('32', ['3', '31'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var $ = $__require('3');\n  $__require('31');\n  module.exports = function getOwnPropertyNames(it) {\n    return $.getNames(it);\n  };\n});\n$__System.registerDynamic(\"33\", [\"32\"], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = { \"default\": $__require(\"32\"), __esModule: true };\n});\n$__System.registerDynamic('34', ['35', '2d'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var isObject = $__require('35');\n  $__require('2d')('freeze', function ($freeze) {\n    return function freeze(it) {\n      return $freeze && isObject(it) ? $freeze(it) : it;\n    };\n  });\n});\n$__System.registerDynamic('36', ['34', 'a'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  $__require('34');\n  module.exports = $__require('a').Object.freeze;\n});\n$__System.registerDynamic(\"37\", [\"36\"], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = { \"default\": $__require(\"36\"), __esModule: true };\n});\n$__System.register('38', ['33', '37', '39', '3a', '3b', '2f'], function (_export) {\n  var _Object$getOwnPropertyNames, _Object$freeze, _classCallCheck, _get, _inherits, _Object$keys, AbstractError, AssertionError, memoMeasureX, memoMeasureY;\n\n  function assert(test, message) {\n    if (!test) {\n      throw new AssertionError(message);\n    }\n  }\n\n  function $(query) {\n    return document.querySelector(query);\n  }\n\n  function clear(node) {\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n  }\n\n  function deepEquals(a, b) {\n    if (typeof a !== typeof b) {\n      return false;\n    } else if (typeof a === 'object') {\n      return _Object$keys(a).every(function (key) {\n        return deepEquals(a[key], b[key]);\n      }) && _Object$keys(b).every(function (key) {\n        return deepEquals(a[key], b[key]);\n      });\n    } else {\n      return a === b;\n    }\n  }\n\n  // @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n  // To make obj fully immutable, freeze each object in obj.\n  // To do so, we use this function.\n\n  function deepFreeze(obj) {\n\n    // Retrieve the property names defined on obj\n    var propNames = _Object$getOwnPropertyNames(obj);\n\n    // Freeze properties before freezing self\n    propNames.forEach(function (name) {\n      var prop = obj[name];\n\n      // Freeze prop if it is an object\n      if (typeof prop == 'object' && prop !== null) deepFreeze(prop);\n    });\n\n    // Freeze self (no-op if already frozen)\n    return _Object$freeze(obj);\n  }\n\n  function measureX(text, fontStack, fontSize) {\n    if ([text, fontStack, fontSize].toString() in memoMeasureX) {\n      return memoMeasureX[[text, fontStack, fontSize]];\n    }\n\n    var measure = $('#measure');\n    measure.textContent = text;\n    measure.style.fontFamily = fontStack;\n    measure.style.fontSize = fontSize;\n\n    var ans = measure.getBoundingClientRect().width;\n    memoMeasureX[[text, fontStack, fontSize]] = ans;\n    return ans;\n  }\n\n  function measureY(text, fontStack, fontSize) {\n    if ([text, fontStack, fontSize].toString() in memoMeasureY) {\n      return memoMeasureY[[text, fontStack, fontSize]];\n    }\n\n    var measure = $('#measure');\n    measure.textContent = text;\n    measure.style.fontFamily = fontStack;\n    measure.style.fontSize = fontSize;\n\n    var ans = measure.getBoundingClientRect().height;\n    memoMeasureY[[text, fontStack, fontSize]] = ans;\n    return ans;\n  }\n\n  function depthFirstTraversal(tree, fn) {\n    var stack = [tree];\n    while (stack.length !== 0) {\n      var current = stack.pop();\n      stack = stack.concat(current.children);\n      fn(current);\n    }\n  }\n\n  function breadthFirstTraversal(tree, fn) {\n    var queue = [tree];\n    while (queue.length !== 0) {\n      var current = queue.shift();\n      queue = queue.concat(current.children);\n      fn(current);\n    }\n  }\n\n  function delegate(object, parentProperties) {\n    return {\n      get: function get(target, property, receiver) {\n        if (property in target) {\n          return target[property];\n        } else {\n          var currentParentIdx = 0;\n          while (currentParentIdx < parentProperties.length && !(property in object[parentProperties[currentParentIdx]])) {\n            currentParentIdx++;\n          }\n\n          if (currentParentIdx < parentProperties.length) {\n            return object[parentProperties[currentParentIdx]][property];\n          }\n        }\n      },\n\n      has: function has(target, property) {\n        if (property in target) {\n          return true;\n        } else {\n          var currentParentIdx = 0;\n          while (currentParentIdx < parentProperties.length && !(property in object[parentProperties[currentParentIdx]])) {\n            currentParentIdx++;\n          }\n\n          return currentParentIdx < parentProperties.length;\n        }\n      }\n    };\n  }\n\n  function DOM(nodeType) {\n    nodeType = nodeType.split('.');\n    var element = document.createElement(nodeType[0]);\n\n    if (nodeType.length > 1) {\n      element.classList.add(nodeType[1]);\n    }\n\n    for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      children[_key - 1] = arguments[_key];\n    }\n\n    children.map(function (child) {\n      return typeof child === 'string' ? document.createTextNode(child) : child;\n    }).forEach(function (child) {\n      return element.appendChild(child);\n    });\n\n    return element;\n  }\n\n  return {\n    setters: [function (_2) {\n      _Object$getOwnPropertyNames = _2['default'];\n    }, function (_3) {\n      _Object$freeze = _3['default'];\n    }, function (_) {\n      _classCallCheck = _['default'];\n    }, function (_a) {\n      _get = _a['default'];\n    }, function (_b) {\n      _inherits = _b['default'];\n    }, function (_f) {\n      _Object$keys = _f['default'];\n    }],\n    execute: function () {\n      'use strict';\n\n      _export('assert', assert);\n\n      _export('$', $);\n\n      _export('clear', clear);\n\n      _export('deepEquals', deepEquals);\n\n      _export('deepFreeze', deepFreeze);\n\n      _export('measureX', measureX);\n\n      _export('measureY', measureY);\n\n      _export('depthFirstTraversal', depthFirstTraversal);\n\n      _export('breadthFirstTraversal', breadthFirstTraversal);\n\n      _export('delegate', delegate);\n\n      _export('DOM', DOM);\n\n      AbstractError = function AbstractError(methodName) {\n        _classCallCheck(this, AbstractError);\n\n        this.methodName = methodName;\n        this.message = methodName + ' is not implemented.';\n      };\n\n      _export('AbstractError', AbstractError);\n\n      AssertionError = (function (_Error) {\n        _inherits(AssertionError, _Error);\n\n        function AssertionError() {\n          _classCallCheck(this, AssertionError);\n\n          _get(Object.getPrototypeOf(AssertionError.prototype), 'constructor', this).apply(this, arguments);\n        }\n\n        return AssertionError;\n      })(Error);\n\n      _export('AssertionError', AssertionError);\n\n      memoMeasureX = {};\n      memoMeasureY = {};\n    }\n  };\n});\n\n$__System.register(\"3c\", [\"5\", \"38\", \"39\", \"3a\", \"3b\", \"2a\", \"2f\", \"3e\", \"3d\"], function (_export) {\n    var _createClass, AbstractError, assert, deepEquals, _classCallCheck, _get, _inherits, _slicedToArray, _Object$keys, _Object$assign, print, OPERATION_BUDGET, OperationBudgetExceeded, Serializable, _ExecutionTrace, ExecutionState, _FnCall, uninstrumented;\n\n    function serializableReplacer(key, value) {\n        if (value instanceof Serializable) {\n            return value.serialize();\n        } else {\n            return value;\n        }\n    }\n\n    function serializableReviver() {\n        var classes = arguments.length <= 0 || arguments[0] === undefined ? {\n            'ExecutionTrace': function ExecutionTrace() {\n                return new _ExecutionTrace();\n            },\n            'FnCall': function FnCall() {\n                return new _FnCall();\n            }\n        } : arguments[0];\n\n        return function (key, value) {\n            var ans = value;\n            _Object$keys(classes).forEach(function (className) {\n                if (value != null && value.hasOwnProperty('_type') && value._type === className) {\n                    var constr = classes[className];\n                    ans = constr(value);\n                    assert(ans instanceof Serializable, className + \" is not a subclass of Serializable\");\n                    ans.deserialize(value);\n                }\n            });\n\n            return ans;\n        };\n    }\n\n    function ENTER(fnName, fn, args, receiver, location) {\n        if (--state.operationBudget === 0) {\n            throw new OperationBudgetExceeded(location);\n        }\n\n        if (!trace.functions.hasOwnProperty(fnName)) {\n            trace.functions[fnName] = fn;\n        }\n\n        var call = new _FnCall(fnName, state.currentCall, args, receiver, location);\n        if (_Object$keys(trace.calls).length === 0) {\n            trace.rootCall = call;\n        }\n        call.cache();\n        state.currentCall = call;\n    }\n\n    function LOOP(location) {\n        if (--state.operationBudget === 0) {\n            throw new OperationBudgetExceeded(location);\n        }\n    }\n\n    function LEAVE(returnValue, loc) {\n        state.currentCall.returnValue = returnValue;\n        state.currentCall = state.currentCall.parent;\n        return returnValue;\n    }\n\n    function THROW(error, loc) {\n        return error;\n    }\n\n    function CATCH(error, loc, fnLoc) {\n        while (!deepEquals(state.currentCall.location, fnLoc)) {\n            state.currentCall.throws = error;\n            state.currentCall = state.currentCall.parent;\n        }\n    }\n\n    function CLEAR() {\n        trace = new _ExecutionTrace();\n        state = new ExecutionState();\n    }\n\n    function MONKEYPATCH() {\n        uninstrumented['Array.map'] = Array.prototype.map;\n        uninstrumented['Array.filter'] = Array.prototype.filter;\n        uninstrumented['Array.reduce'] = Array.prototype.reduce;\n        uninstrumented['Array.forEach'] = Array.prototype.forEach;\n        uninstrumented['console.log'] = console.log;\n\n        _Object$keys(uninstrumented).forEach(function (key) {\n            var _key$split = key.split('.');\n\n            var _key$split2 = _slicedToArray(_key$split, 2);\n\n            var className = _key$split2[0];\n            var methodName = _key$split2[1];\n\n            if (className === 'Array') {\n                Array.prototype[methodName] = wrapBuiltin(key, uninstrumented[key]);\n            } else if (className === 'console' && methodName === 'log') {\n                var wrapped = function wrapped() {\n                    ENTER('console.log', uninstrumented['console.log'], arguments, null);\n                    LOG(Array.prototype.slice.call(arguments));\n                    return LEAVE(uninstrumented['console.log'].apply(console, arguments));\n                };\n                console[methodName] = wrapped;\n            }\n        });\n    }\n\n    function wrapBuiltin(name, uninstrumented) {\n        return function () {\n            ENTER(name, uninstrumented, arguments, null);\n            return LEAVE(uninstrumented.apply(this, arguments));\n        };\n    }\n\n    function RESETMONKEYPATCH() {\n        uninstrumented['Array.forEach'].call(_Object$keys(uninstrumented), function (key) {\n            var _key$split3 = key.split('.');\n\n            var _key$split32 = _slicedToArray(_key$split3, 2);\n\n            var className = _key$split32[0];\n            var methodName = _key$split32[1];\n\n            if (className === 'Array') {\n                Array.prototype[methodName] = uninstrumented[key];\n            } else if (className === 'console' && methodName === 'log') {\n                console[methodName] = uninstrumented[key];\n            }\n        });\n    }\n\n    function TAG(key, optValue) {\n        var optCondition = arguments.length <= 2 || arguments[2] === undefined ? function () {\n            return true;\n        } : arguments[2];\n\n        if (optCondition()) {\n            state.currentCall.tags[key] = optValue;\n        }\n    }\n\n    function LOG() {\n        print.apply(undefined, arguments);\n    }\n\n    return {\n        setters: [function (_2) {\n            _createClass = _2[\"default\"];\n        }, function (_3) {\n            AbstractError = _3.AbstractError;\n            assert = _3.assert;\n            deepEquals = _3.deepEquals;\n        }, function (_) {\n            _classCallCheck = _[\"default\"];\n        }, function (_a) {\n            _get = _a[\"default\"];\n        }, function (_b) {\n            _inherits = _b[\"default\"];\n        }, function (_a2) {\n            _slicedToArray = _a2[\"default\"];\n        }, function (_f) {\n            _Object$keys = _f[\"default\"];\n        }, function (_e) {\n            _Object$assign = _e[\"default\"];\n        }, function (_d) {\n            print = _d.print;\n        }],\n        execute: function () {\n            \"use strict\";\n\n            _export(\"serializableReplacer\", serializableReplacer);\n\n            _export(\"serializableReviver\", serializableReviver);\n\n            _export(\"ENTER\", ENTER);\n\n            _export(\"LOOP\", LOOP);\n\n            _export(\"LEAVE\", LEAVE);\n\n            _export(\"THROW\", THROW);\n\n            _export(\"CATCH\", CATCH);\n\n            _export(\"CLEAR\", CLEAR);\n\n            _export(\"MONKEYPATCH\", MONKEYPATCH);\n\n            _export(\"RESETMONKEYPATCH\", RESETMONKEYPATCH);\n\n            _export(\"TAG\", TAG);\n\n            _export(\"LOG\", LOG);\n\n            OPERATION_BUDGET = 200;\n\n            OperationBudgetExceeded = (function (_Error) {\n                _inherits(OperationBudgetExceeded, _Error);\n\n                function OperationBudgetExceeded(location) {\n                    _classCallCheck(this, OperationBudgetExceeded);\n\n                    _get(Object.getPrototypeOf(OperationBudgetExceeded.prototype), \"constructor\", this).call(this, \"operation budget exceeded at \" + JSON.stringify(location));\n                    this.location = location;\n                    this.message = \"operation budget exceeded at \" + JSON.stringify(location);\n                }\n\n                return OperationBudgetExceeded;\n            })(Error);\n\n            _export(\"OperationBudgetExceeded\", OperationBudgetExceeded);\n\n            Serializable = (function () {\n                function Serializable() {\n                    _classCallCheck(this, Serializable);\n                }\n\n                _createClass(Serializable, [{\n                    key: \"serialize\",\n                    value: function serialize() {\n                        throw new AbstractError('Serializable.serialize');\n                    }\n                }, {\n                    key: \"deserialize\",\n                    value: function deserialize() {\n                        throw new AbstractError('Serializable.deserialize');\n                    }\n                }]);\n\n                return Serializable;\n            })();\n\n            _ExecutionTrace = (function (_Serializable) {\n                _inherits(_ExecutionTrace, _Serializable);\n\n                function _ExecutionTrace() {\n                    _classCallCheck(this, _ExecutionTrace);\n\n                    _get(Object.getPrototypeOf(_ExecutionTrace.prototype), \"constructor\", this).call(this);\n                    this.functions = {};\n                    this.calls = {};\n                    this.rootCall = null;\n                }\n\n                _createClass(_ExecutionTrace, [{\n                    key: \"serialize\",\n                    value: function serialize() {\n                        var _this = this;\n\n                        var serializedFunctions = {};\n                        _Object$keys(this.functions).forEach(function (key) {\n                            serializedFunctions[key] = _this.functions[key] === null ? _this.functions[key] : _this.functions[key].toString();\n                        });\n\n                        var serializedCalls = _Object$keys(this.calls).map(function (key) {\n                            return _this.calls[key];\n                        }).reduce(function (agg, b) {\n                            return agg.concat(b);\n                        }, []).sort(function (a, b) {\n                            return a.uid < b.uid ? -1 : a.uid === b.uid ? 0 : 1;\n                        });\n\n                        return {\n                            _type: 'ExecutionTrace',\n                            functions: serializedFunctions,\n                            calls: serializedCalls,\n                            rootCall: this.rootCall !== null ? this.rootCall.uid : null\n                        };\n                    }\n                }, {\n                    key: \"deserialize\",\n                    value: function deserialize(data) {\n                        var deserializedFunctions = {};\n                        // Object.keys(data.functions)\n                        //     .forEach(key => {\n                        //         deserializedFunctions[key] = eval(data.functions[key]);\n                        //     });\n\n                        var deserializedCalls = {};\n                        data.calls.forEach(function (call) {\n                            if (!deserializedCalls.hasOwnProperty(call.fnName)) {\n                                deserializedCalls[call.fnName] = [];\n                            }\n                            deserializedCalls[call.fnName].push(call);\n                        });\n\n                        this.functions = deserializedFunctions;\n                        this.calls = deserializedCalls;\n                        this.rootCall = data.rootCall === null ? null : this._lookupUid(data.rootCall);\n                    }\n                }]);\n\n                return _ExecutionTrace;\n            })(Serializable);\n\n            _export(\"ExecutionTrace\", _ExecutionTrace);\n\n            ExecutionState = function ExecutionState() {\n                _classCallCheck(this, ExecutionState);\n\n                this.operationBudget = OPERATION_BUDGET;\n                this.currentCall = null;\n                this.nextUid = 0;\n            };\n\n            _export(\"ExecutionState\", ExecutionState);\n\n            _FnCall = (function (_Serializable2) {\n                _inherits(_FnCall, _Serializable2);\n\n                function _FnCall(fnName, parent, args, receiver, location) {\n                    _classCallCheck(this, _FnCall);\n\n                    _get(Object.getPrototypeOf(_FnCall.prototype), \"constructor\", this).call(this);\n                    this.location = location;\n                    this.isError = false;\n                    this.tags = {};\n                    this.fnName = fnName.replace(new RegExp('[$]', 'g'), '.');\n                    this.args = Array.prototype.slice.call(args);\n                    if (receiver !== undefined) {\n                        this.receiver = _Object$assign({}, receiver);\n                    }\n\n                    this.uid = state.nextUid++;\n\n                    this.parent = parent;\n                    this.children = [];\n                    if (this.parent !== null) {\n                        this.parent.children.push(this);\n                    }\n                }\n\n                _createClass(_FnCall, [{\n                    key: \"cache\",\n                    value: function cache() {\n                        if (!trace.calls.hasOwnProperty(this.fnName)) {\n                            trace.calls[this.fnName] = [];\n                        }\n                        trace.calls[this.fnName].push(this);\n                    }\n                }, {\n                    key: \"serialize\",\n                    value: function serialize() {\n                        return {\n                            _type: 'FnCall',\n                            fnName: this.fnName,\n                            args: this.args,\n                            uid: this.uid,\n                            location: this.location,\n                            returnValue: this.returnValue,\n                            throws: JSON.stringify(this.throws),\n                            isError: this.isError,\n                            tags: this.tags,\n                            receiver: this.receiver, // TODO: this is terrible :(\n                            parent: this.parent === null ? null : this.parent.uid,\n                            children: this.children.map(function (child) {\n                                return child.uid;\n                            })\n                        };\n                    }\n                }, {\n                    key: \"deserialize\",\n                    value: function deserialize(data) {\n                        // this.fnName = data.fnName;\n                        // this.args = data.args;\n                        this.uid = data.uid;\n                        this.location = data.location;\n                        this.isError = data.isError;\n                        this.parent = data.parent === null ? null : this._lookupUid(data.parent);\n                        this.tags = data.tags;\n                        if (data.hasOwnProperty('receiver')) {\n                            this.receiver = data.receiver;\n                        }\n                        this.returnValue = data.returnValue;\n                        if (data.hasOwnProperty('throws')) {\n                            this.throws = JSON.parse(data.throws);\n                        }\n                        // this.children = data.children.map(child => this._lookupUid(child));\n                        if (this.parent !== null) {\n                            this.parent.children.push(this);\n                        }\n                    }\n                }, {\n                    key: \"fn\",\n                    get: function get() {\n                        return functions[this.fnName];\n                    }\n                }, {\n                    key: \"level\",\n                    get: function get() {\n                        if (this.parent === null) {\n                            return 0;\n                        }\n\n                        if (!this.hasOwnProperty('_level')) {\n                            this._level = this.parent.level + 1;\n                        }\n                        return this._level;\n                    }\n                }]);\n\n                return _FnCall;\n            })(Serializable);\n\n            _export(\"FnCall\", _FnCall);\n\n            self.trace = new _ExecutionTrace();\n            self.state = new ExecutionState();\n\n            uninstrumented = {};\n        }\n    };\n});\n\n$__System.registerDynamic(\"39\", [], true, function ($__require, exports, module) {\n  /* */\n  \"use strict\";\n\n  var global = this || self,\n      GLOBAL = global;\n  exports[\"default\"] = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  exports.__esModule = true;\n});\n$__System.registerDynamic('14', ['3f', '18'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var IObject = $__require('3f'),\n      defined = $__require('18');\n  module.exports = function (it) {\n    return IObject(defined(it));\n  };\n});\n$__System.registerDynamic('2d', ['22', 'a', '1e'], true, function ($__require, exports, module) {\n    var global = this || self,\n        GLOBAL = global;\n    /* */\n    var $export = $__require('22'),\n        core = $__require('a'),\n        fails = $__require('1e');\n    module.exports = function (KEY, exec) {\n        var fn = (core.Object || {})[KEY] || Object[KEY],\n            exp = {};\n        exp[KEY] = exec(fn);\n        $export($export.S + $export.F * fails(function () {\n            fn(1);\n        }), 'Object', exp);\n    };\n});\n$__System.registerDynamic('40', ['14', '2d'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var toIObject = $__require('14');\n  $__require('2d')('getOwnPropertyDescriptor', function ($getOwnPropertyDescriptor) {\n    return function getOwnPropertyDescriptor(it, key) {\n      return $getOwnPropertyDescriptor(toIObject(it), key);\n    };\n  });\n});\n$__System.registerDynamic('41', ['3', '40'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var $ = $__require('3');\n  $__require('40');\n  module.exports = function getOwnPropertyDescriptor(it, key) {\n    return $.getDesc(it, key);\n  };\n});\n$__System.registerDynamic(\"42\", [\"41\"], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = { \"default\": $__require(\"41\"), __esModule: true };\n});\n$__System.registerDynamic(\"3a\", [\"42\"], true, function ($__require, exports, module) {\n  /* */\n  \"use strict\";\n\n  var global = this || self,\n      GLOBAL = global;\n  var _Object$getOwnPropertyDescriptor = $__require(\"42\")[\"default\"];\n  exports[\"default\"] = function get(_x, _x2, _x3) {\n    var _again = true;\n    _function: while (_again) {\n      var object = _x,\n          property = _x2,\n          receiver = _x3;\n      _again = false;\n      if (object === null) object = Function.prototype;\n      var desc = _Object$getOwnPropertyDescriptor(object, property);\n      if (desc === undefined) {\n        var parent = Object.getPrototypeOf(object);\n        if (parent === null) {\n          return undefined;\n        } else {\n          _x = parent;\n          _x2 = property;\n          _x3 = receiver;\n          _again = true;\n          desc = parent = undefined;\n          continue _function;\n        }\n      } else if (\"value\" in desc) {\n        return desc.value;\n      } else {\n        var getter = desc.get;\n        if (getter === undefined) {\n          return undefined;\n        }\n        return getter.call(receiver);\n      }\n    }\n  };\n  exports.__esModule = true;\n});\n$__System.registerDynamic('43', ['3'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var $ = $__require('3');\n  module.exports = function create(P, D) {\n    return $.create(P, D);\n  };\n});\n$__System.registerDynamic(\"44\", [\"43\"], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = { \"default\": $__require(\"43\"), __esModule: true };\n});\n$__System.registerDynamic('35', [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = function (it) {\n    return typeof it === 'object' ? it !== null : typeof it === 'function';\n  };\n});\n$__System.registerDynamic('c', ['35'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var isObject = $__require('35');\n  module.exports = function (it) {\n    if (!isObject(it)) throw TypeError(it + ' is not an object!');\n    return it;\n  };\n});\n$__System.registerDynamic('45', ['3', '35', 'c', '46'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var getDesc = $__require('3').getDesc,\n      isObject = $__require('35'),\n      anObject = $__require('c');\n  var check = function (O, proto) {\n    anObject(O);\n    if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n  };\n  module.exports = {\n    set: Object.setPrototypeOf || ('__proto__' in {} ? function (test, buggy, set) {\n      try {\n        set = $__require('46')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) {\n        buggy = true;\n      }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n    check: check\n  };\n});\n$__System.registerDynamic('47', ['22', '45'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var $export = $__require('22');\n  $export($export.S, 'Object', { setPrototypeOf: $__require('45').set });\n});\n$__System.registerDynamic('48', ['47', 'a'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  $__require('47');\n  module.exports = $__require('a').Object.setPrototypeOf;\n});\n$__System.registerDynamic(\"49\", [\"48\"], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = { \"default\": $__require(\"48\"), __esModule: true };\n});\n$__System.registerDynamic(\"3b\", [\"44\", \"49\"], true, function ($__require, exports, module) {\n  /* */\n  \"use strict\";\n\n  var global = this || self,\n      GLOBAL = global;\n  var _Object$create = $__require(\"44\")[\"default\"];\n  var _Object$setPrototypeOf = $__require(\"49\")[\"default\"];\n  exports[\"default\"] = function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n    subClass.prototype = _Object$create(superClass && superClass.prototype, { constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      } });\n    if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n  exports.__esModule = true;\n});\n$__System.registerDynamic('25', [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n});\n$__System.registerDynamic('4a', [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = function (it) {\n    if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n    return it;\n  };\n});\n$__System.registerDynamic('46', ['4a'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var aFunction = $__require('4a');\n  module.exports = function (fn, that, length) {\n    aFunction(fn);\n    if (that === undefined) return fn;\n    switch (length) {\n      case 1:\n        return function (a) {\n          return fn.call(that, a);\n        };\n      case 2:\n        return function (a, b) {\n          return fn.call(that, a, b);\n        };\n      case 3:\n        return function (a, b, c) {\n          return fn.call(that, a, b, c);\n        };\n    }\n    return function () {\n      return fn.apply(that, arguments);\n    };\n  };\n});\n$__System.registerDynamic('22', ['25', 'a', '46'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var global = $__require('25'),\n      core = $__require('a'),\n      ctx = $__require('46'),\n      PROTOTYPE = 'prototype';\n  var $export = function (type, name, source) {\n    var IS_FORCED = type & $export.F,\n        IS_GLOBAL = type & $export.G,\n        IS_STATIC = type & $export.S,\n        IS_PROTO = type & $export.P,\n        IS_BIND = type & $export.B,\n        IS_WRAP = type & $export.W,\n        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),\n        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],\n        key,\n        own,\n        out;\n    if (IS_GLOBAL) source = name;\n    for (key in source) {\n      own = !IS_FORCED && target && key in target;\n      if (own && key in exports) continue;\n      out = own ? target[key] : source[key];\n      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function (C) {\n        var F = function (param) {\n          return this instanceof C ? new C(param) : C(param);\n        };\n        F[PROTOTYPE] = C[PROTOTYPE];\n        return F;\n      }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n      if (IS_PROTO) (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n    }\n  };\n  $export.F = 1;\n  $export.G = 2;\n  $export.S = 4;\n  $export.P = 8;\n  $export.B = 16;\n  $export.W = 32;\n  module.exports = $export;\n});\n$__System.registerDynamic(\"3\", [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var $Object = Object;\n  module.exports = {\n    create: $Object.create,\n    getProto: $Object.getPrototypeOf,\n    isEnum: {}.propertyIsEnumerable,\n    getDesc: $Object.getOwnPropertyDescriptor,\n    setDesc: $Object.defineProperty,\n    setDescs: $Object.defineProperties,\n    getKeys: $Object.keys,\n    getNames: $Object.getOwnPropertyNames,\n    getSymbols: $Object.getOwnPropertySymbols,\n    each: [].forEach\n  };\n});\n$__System.registerDynamic(\"18\", [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  // 7.2.1 RequireObjectCoercible(argument)\n  module.exports = function (it) {\n    if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n    return it;\n  };\n});\n$__System.registerDynamic('2c', ['18'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var defined = $__require('18');\n  module.exports = function (it) {\n    return Object(defined(it));\n  };\n});\n$__System.registerDynamic(\"23\", [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var toString = {}.toString;\n\n  module.exports = function (it) {\n    return toString.call(it).slice(8, -1);\n  };\n});\n$__System.registerDynamic('3f', ['23'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var cof = $__require('23');\n  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n    return cof(it) == 'String' ? it.split('') : Object(it);\n  };\n});\n$__System.registerDynamic(\"1e\", [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = function (exec) {\n    try {\n      return !!exec();\n    } catch (e) {\n      return true;\n    }\n  };\n});\n$__System.registerDynamic('4b', ['3', '2c', '3f', '1e'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var $ = $__require('3'),\n      toObject = $__require('2c'),\n      IObject = $__require('3f');\n  module.exports = $__require('1e')(function () {\n    var a = Object.assign,\n        A = {},\n        B = {},\n        S = Symbol(),\n        K = 'abcdefghijklmnopqrst';\n    A[S] = 7;\n    K.split('').forEach(function (k) {\n      B[k] = k;\n    });\n    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;\n  }) ? function assign(target, source) {\n    var T = toObject(target),\n        $$ = arguments,\n        $$len = $$.length,\n        index = 1,\n        getKeys = $.getKeys,\n        getSymbols = $.getSymbols,\n        isEnum = $.isEnum;\n    while ($$len > index) {\n      var S = IObject($$[index++]),\n          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),\n          length = keys.length,\n          j = 0,\n          key;\n      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n    }\n    return T;\n  } : Object.assign;\n});\n$__System.registerDynamic('4c', ['22', '4b'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var $export = $__require('22');\n  $export($export.S + $export.F, 'Object', { assign: $__require('4b') });\n});\n$__System.registerDynamic('a', [], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  var core = module.exports = { version: '1.2.6' };\n  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n});\n$__System.registerDynamic('4d', ['4c', 'a'], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  $__require('4c');\n  module.exports = $__require('a').Object.assign;\n});\n$__System.registerDynamic(\"3e\", [\"4d\"], true, function ($__require, exports, module) {\n  var global = this || self,\n      GLOBAL = global;\n  /* */\n  module.exports = { \"default\": $__require(\"4d\"), __esModule: true };\n});\n$__System.register('3d', ['39', '3a', '3b', '3e'], function (_export) {\n    var _classCallCheck, _get, _inherits, _Object$assign, WorkerEvent, Message, ErrorMessage, InfoMessage, WarningMessage;\n\n    function print() {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        var msg = _Object$assign({}, new Message(args));\n        self.postMessage(msg);\n    }\n\n    function err() {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n        }\n\n        self.postMessage(new ErrorMessage(args));\n    }\n\n    function info() {\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n        }\n\n        self.postMessage(new InfoMessage(args));\n    }\n\n    function warn() {\n        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n            args[_key4] = arguments[_key4];\n        }\n\n        self.postMessage(new WarningMessage(args));\n    }\n\n    return {\n        setters: [function (_) {\n            _classCallCheck = _['default'];\n        }, function (_a) {\n            _get = _a['default'];\n        }, function (_b) {\n            _inherits = _b['default'];\n        }, function (_e) {\n            _Object$assign = _e['default'];\n        }],\n        execute: function () {\n            'use strict';\n\n            _export('print', print);\n\n            _export('err', err);\n\n            _export('info', info);\n\n            _export('warn', warn);\n\n            WorkerEvent = function WorkerEvent(name, data) {\n                _classCallCheck(this, WorkerEvent);\n\n                this.name = name;\n                _Object$assign(this, data);\n            };\n\n            _export('WorkerEvent', WorkerEvent);\n\n            Message = (function (_WorkerEvent) {\n                _inherits(Message, _WorkerEvent);\n\n                function Message(data) {\n                    _classCallCheck(this, Message);\n\n                    _get(Object.getPrototypeOf(Message.prototype), 'constructor', this).call(this, 'LOG', { data: data });\n                }\n\n                return Message;\n            })(WorkerEvent);\n\n            _export('Message', Message);\n\n            ErrorMessage = (function (_Message) {\n                _inherits(ErrorMessage, _Message);\n\n                function ErrorMessage(data) {\n                    _classCallCheck(this, ErrorMessage);\n\n                    _get(Object.getPrototypeOf(ErrorMessage.prototype), 'constructor', this).call(this, data);\n                    this.name = 'ERROR';\n                }\n\n                return ErrorMessage;\n            })(Message);\n\n            _export('ErrorMessage', ErrorMessage);\n\n            InfoMessage = (function (_Message2) {\n                _inherits(InfoMessage, _Message2);\n\n                function InfoMessage(data) {\n                    _classCallCheck(this, InfoMessage);\n\n                    _get(Object.getPrototypeOf(InfoMessage.prototype), 'constructor', this).call(this, data);\n                    this.name = 'INFO';\n                }\n\n                return InfoMessage;\n            })(Message);\n\n            _export('InfoMessage', InfoMessage);\n\n            WarningMessage = (function (_Message3) {\n                _inherits(WarningMessage, _Message3);\n\n                function WarningMessage(data) {\n                    _classCallCheck(this, WarningMessage);\n\n                    _get(Object.getPrototypeOf(WarningMessage.prototype), 'constructor', this).call(this, data);\n                    this.name = 'WARNING';\n                }\n\n                return WarningMessage;\n            })(Message);\n\n            _export('WarningMessage', WarningMessage);\n        }\n    };\n});\n\n$__System.register(\"1\", [\"3e\", \"3c\", \"3d\"], function (_export) {\n    var _Object$assign, lib, info, err, WorkerEvent;\n\n    function start(code, map) {\n        'use strict';\n        try {\n            MONKEYPATCH();\n            eval(code);\n            RESETMONKEYPATCH();\n            self.postMessage(new WorkerEvent('DONE', {\n                trace: JSON.stringify(self.trace, serializableReplacer)\n            }));\n            self.close();\n        } catch (e) {\n            while (state.currentCall !== null) {\n                state.currentCall.throws = e;\n                state.currentCall = state.currentCall.parent;\n            }\n\n            RESETMONKEYPATCH();\n            self.postMessage(new WorkerEvent('DONE', {\n                trace: JSON.stringify(self.trace, serializableReplacer),\n                error: e.toString != null ? e.toString() : JSON.stringify(e)\n            }));\n        }\n    }\n    return {\n        setters: [function (_e) {\n            _Object$assign = _e[\"default\"];\n        }, function (_c) {\n            lib = _c;\n        }, function (_d) {\n            info = _d.info;\n            err = _d.err;\n            WorkerEvent = _d.WorkerEvent;\n        }],\n        execute: function () {\n            \"use strict\";\n\n            _Object$assign(self, lib);\n\n            self.addEventListener('message', function (e) {\n                info('EVENT', e.data.name);\n                switch (e.data.name) {\n                    case 'INITIALIZE':\n                        start(e.data.code, e.data.map);\n                        break;\n                }\n            });\n        }\n    };\n});\n\n})\n(function(factory) {\n  coderunnerworker = factory();\n});";
      const blob = new Blob([codeStr]);
      const blobURL = self.URL.createObjectURL(blob);

      _export("default", function () {
        return new Worker(blobURL);
      });

      ;
    }
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/object/define-property.js', ['npm:core-js@1.2.7/library/modules/$.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('npm:core-js@1.2.7/library/modules/$.js');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/define-property.js", ["npm:core-js@1.2.7/library/fn/object/define-property.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/object/define-property.js"), __esModule: true };
});
System.registerDynamic("npm:babel-runtime@5.8.38/helpers/create-class.js", ["npm:babel-runtime@5.8.38/core-js/object/define-property.js"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$defineProperty = $__require("npm:babel-runtime@5.8.38/core-js/object/define-property.js")["default"];
  exports["default"] = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  exports.__esModule = true;
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/core.get-iterator-method.js', ['npm:core-js@1.2.7/library/modules/$.classof.js', 'npm:core-js@1.2.7/library/modules/$.wks.js', 'npm:core-js@1.2.7/library/modules/$.iterators.js', 'npm:core-js@1.2.7/library/modules/$.core.js'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var classof = $__require('npm:core-js@1.2.7/library/modules/$.classof.js'),
        ITERATOR = $__require('npm:core-js@1.2.7/library/modules/$.wks.js')('iterator'),
        Iterators = $__require('npm:core-js@1.2.7/library/modules/$.iterators.js');
    module.exports = $__require('npm:core-js@1.2.7/library/modules/$.core.js').getIteratorMethod = function (it) {
        if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
    };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/core.get-iterator.js', ['npm:core-js@1.2.7/library/modules/$.an-object.js', 'npm:core-js@1.2.7/library/modules/core.get-iterator-method.js', 'npm:core-js@1.2.7/library/modules/$.core.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var anObject = $__require('npm:core-js@1.2.7/library/modules/$.an-object.js'),
      get = $__require('npm:core-js@1.2.7/library/modules/core.get-iterator-method.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.core.js').getIterator = function (it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/get-iterator.js', ['npm:core-js@1.2.7/library/modules/web.dom.iterable.js', 'npm:core-js@1.2.7/library/modules/es6.string.iterator.js', 'npm:core-js@1.2.7/library/modules/core.get-iterator.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('npm:core-js@1.2.7/library/modules/web.dom.iterable.js');
  $__require('npm:core-js@1.2.7/library/modules/es6.string.iterator.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/core.get-iterator.js');
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/get-iterator.js", ["npm:core-js@1.2.7/library/fn/get-iterator.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/get-iterator.js"), __esModule: true };
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.add-to-unscopables.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function () {/* empty */};
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.iter-step.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (done, value) {
    return { value: value, done: !!done };
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/es6.array.iterator.js', ['npm:core-js@1.2.7/library/modules/$.add-to-unscopables.js', 'npm:core-js@1.2.7/library/modules/$.iter-step.js', 'npm:core-js@1.2.7/library/modules/$.iterators.js', 'npm:core-js@1.2.7/library/modules/$.to-iobject.js', 'npm:core-js@1.2.7/library/modules/$.iter-define.js'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var addToUnscopables = $__require('npm:core-js@1.2.7/library/modules/$.add-to-unscopables.js'),
      step = $__require('npm:core-js@1.2.7/library/modules/$.iter-step.js'),
      Iterators = $__require('npm:core-js@1.2.7/library/modules/$.iterators.js'),
      toIObject = $__require('npm:core-js@1.2.7/library/modules/$.to-iobject.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.iter-define.js')(Array, 'Array', function (iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function () {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys') return step(0, index);
    if (kind == 'values') return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/web.dom.iterable.js', ['npm:core-js@1.2.7/library/modules/es6.array.iterator.js', 'npm:core-js@1.2.7/library/modules/$.iterators.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('npm:core-js@1.2.7/library/modules/es6.array.iterator.js');
  var Iterators = $__require('npm:core-js@1.2.7/library/modules/$.iterators.js');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.to-integer.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.1.4 ToInteger
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.string-at.js', ['npm:core-js@1.2.7/library/modules/$.to-integer.js', 'npm:core-js@1.2.7/library/modules/$.defined.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toInteger = $__require('npm:core-js@1.2.7/library/modules/$.to-integer.js'),
      defined = $__require('npm:core-js@1.2.7/library/modules/$.defined.js');
  module.exports = function (TO_STRING) {
    return function (that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.library.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = true;
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.redefine.js', ['npm:core-js@1.2.7/library/modules/$.hide.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.hide.js');
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.property-desc.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.descriptors.js', ['npm:core-js@1.2.7/library/modules/$.fails.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = !$__require('npm:core-js@1.2.7/library/modules/$.fails.js')(function () {
    return Object.defineProperty({}, 'a', { get: function () {
        return 7;
      } }).a != 7;
  });
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.hide.js', ['npm:core-js@1.2.7/library/modules/$.js', 'npm:core-js@1.2.7/library/modules/$.property-desc.js', 'npm:core-js@1.2.7/library/modules/$.descriptors.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('npm:core-js@1.2.7/library/modules/$.js'),
      createDesc = $__require('npm:core-js@1.2.7/library/modules/$.property-desc.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.descriptors.js') ? function (object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.iter-create.js', ['npm:core-js@1.2.7/library/modules/$.js', 'npm:core-js@1.2.7/library/modules/$.property-desc.js', 'npm:core-js@1.2.7/library/modules/$.set-to-string-tag.js', 'npm:core-js@1.2.7/library/modules/$.hide.js', 'npm:core-js@1.2.7/library/modules/$.wks.js'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('npm:core-js@1.2.7/library/modules/$.js'),
      descriptor = $__require('npm:core-js@1.2.7/library/modules/$.property-desc.js'),
      setToStringTag = $__require('npm:core-js@1.2.7/library/modules/$.set-to-string-tag.js'),
      IteratorPrototype = {};
  $__require('npm:core-js@1.2.7/library/modules/$.hide.js')(IteratorPrototype, $__require('npm:core-js@1.2.7/library/modules/$.wks.js')('iterator'), function () {
    return this;
  });
  module.exports = function (Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, { next: descriptor(1, next) });
    setToStringTag(Constructor, NAME + ' Iterator');
  };
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.has.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function (it, key) {
    return hasOwnProperty.call(it, key);
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.set-to-string-tag.js', ['npm:core-js@1.2.7/library/modules/$.js', 'npm:core-js@1.2.7/library/modules/$.has.js', 'npm:core-js@1.2.7/library/modules/$.wks.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var def = $__require('npm:core-js@1.2.7/library/modules/$.js').setDesc,
      has = $__require('npm:core-js@1.2.7/library/modules/$.has.js'),
      TAG = $__require('npm:core-js@1.2.7/library/modules/$.wks.js')('toStringTag');
  module.exports = function (it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
      configurable: true,
      value: tag
    });
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.iter-define.js', ['npm:core-js@1.2.7/library/modules/$.library.js', 'npm:core-js@1.2.7/library/modules/$.export.js', 'npm:core-js@1.2.7/library/modules/$.redefine.js', 'npm:core-js@1.2.7/library/modules/$.hide.js', 'npm:core-js@1.2.7/library/modules/$.has.js', 'npm:core-js@1.2.7/library/modules/$.iterators.js', 'npm:core-js@1.2.7/library/modules/$.iter-create.js', 'npm:core-js@1.2.7/library/modules/$.set-to-string-tag.js', 'npm:core-js@1.2.7/library/modules/$.js', 'npm:core-js@1.2.7/library/modules/$.wks.js'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var LIBRARY = $__require('npm:core-js@1.2.7/library/modules/$.library.js'),
      $export = $__require('npm:core-js@1.2.7/library/modules/$.export.js'),
      redefine = $__require('npm:core-js@1.2.7/library/modules/$.redefine.js'),
      hide = $__require('npm:core-js@1.2.7/library/modules/$.hide.js'),
      has = $__require('npm:core-js@1.2.7/library/modules/$.has.js'),
      Iterators = $__require('npm:core-js@1.2.7/library/modules/$.iterators.js'),
      $iterCreate = $__require('npm:core-js@1.2.7/library/modules/$.iter-create.js'),
      setToStringTag = $__require('npm:core-js@1.2.7/library/modules/$.set-to-string-tag.js'),
      getProto = $__require('npm:core-js@1.2.7/library/modules/$.js').getProto,
      ITERATOR = $__require('npm:core-js@1.2.7/library/modules/$.wks.js')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function () {
    return this;
  };
  module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base()));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) redefine(proto, key, methods[key]);
      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/es6.string.iterator.js', ['npm:core-js@1.2.7/library/modules/$.string-at.js', 'npm:core-js@1.2.7/library/modules/$.iter-define.js'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $at = $__require('npm:core-js@1.2.7/library/modules/$.string-at.js')(true);
  $__require('npm:core-js@1.2.7/library/modules/$.iter-define.js')(String, 'String', function (iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function () {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length) return {
      value: undefined,
      done: true
    };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.classof.js', ['npm:core-js@1.2.7/library/modules/$.cof.js', 'npm:core-js@1.2.7/library/modules/$.wks.js'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var cof = $__require('npm:core-js@1.2.7/library/modules/$.cof.js'),
        TAG = $__require('npm:core-js@1.2.7/library/modules/$.wks.js')('toStringTag'),
        ARG = cof(function () {
        return arguments;
    }()) == 'Arguments';
    module.exports = function (it) {
        var O, T, B;
        return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
    };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.shared.js', ['npm:core-js@1.2.7/library/modules/$.global.js'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var global = $__require('npm:core-js@1.2.7/library/modules/$.global.js'),
        SHARED = '__core-js_shared__',
        store = global[SHARED] || (global[SHARED] = {});
    module.exports = function (key) {
        return store[key] || (store[key] = {});
    };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.uid.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var id = 0,
      px = Math.random();
  module.exports = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.wks.js', ['npm:core-js@1.2.7/library/modules/$.shared.js', 'npm:core-js@1.2.7/library/modules/$.uid.js', 'npm:core-js@1.2.7/library/modules/$.global.js'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var store = $__require('npm:core-js@1.2.7/library/modules/$.shared.js')('wks'),
        uid = $__require('npm:core-js@1.2.7/library/modules/$.uid.js'),
        Symbol = $__require('npm:core-js@1.2.7/library/modules/$.global.js').Symbol;
    module.exports = function (name) {
        return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
    };
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.iterators.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = {};
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/core.is-iterable.js', ['npm:core-js@1.2.7/library/modules/$.classof.js', 'npm:core-js@1.2.7/library/modules/$.wks.js', 'npm:core-js@1.2.7/library/modules/$.iterators.js', 'npm:core-js@1.2.7/library/modules/$.core.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var classof = $__require('npm:core-js@1.2.7/library/modules/$.classof.js'),
      ITERATOR = $__require('npm:core-js@1.2.7/library/modules/$.wks.js')('iterator'),
      Iterators = $__require('npm:core-js@1.2.7/library/modules/$.iterators.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.core.js').isIterable = function (it) {
    var O = Object(it);
    return O[ITERATOR] !== undefined || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/is-iterable.js', ['npm:core-js@1.2.7/library/modules/web.dom.iterable.js', 'npm:core-js@1.2.7/library/modules/es6.string.iterator.js', 'npm:core-js@1.2.7/library/modules/core.is-iterable.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('npm:core-js@1.2.7/library/modules/web.dom.iterable.js');
  $__require('npm:core-js@1.2.7/library/modules/es6.string.iterator.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/core.is-iterable.js');
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/is-iterable.js", ["npm:core-js@1.2.7/library/fn/is-iterable.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/is-iterable.js"), __esModule: true };
});
System.registerDynamic("npm:babel-runtime@5.8.38/helpers/sliced-to-array.js", ["npm:babel-runtime@5.8.38/core-js/get-iterator.js", "npm:babel-runtime@5.8.38/core-js/is-iterable.js"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _getIterator = $__require("npm:babel-runtime@5.8.38/core-js/get-iterator.js")["default"];
  var _isIterable = $__require("npm:babel-runtime@5.8.38/core-js/is-iterable.js")["default"];
  exports["default"] = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = _getIterator(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (_isIterable(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  exports.__esModule = true;
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/es6.object.keys.js', ['npm:core-js@1.2.7/library/modules/$.to-object.js', 'npm:core-js@1.2.7/library/modules/$.object-sap.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toObject = $__require('npm:core-js@1.2.7/library/modules/$.to-object.js');
  $__require('npm:core-js@1.2.7/library/modules/$.object-sap.js')('keys', function ($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/object/keys.js', ['npm:core-js@1.2.7/library/modules/es6.object.keys.js', 'npm:core-js@1.2.7/library/modules/$.core.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('npm:core-js@1.2.7/library/modules/es6.object.keys.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.core.js').Object.keys;
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/keys.js", ["npm:core-js@1.2.7/library/fn/object/keys.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/object/keys.js"), __esModule: true };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.get-names.js', ['npm:core-js@1.2.7/library/modules/$.to-iobject.js', 'npm:core-js@1.2.7/library/modules/$.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toIObject = $__require('npm:core-js@1.2.7/library/modules/$.to-iobject.js'),
      getNames = $__require('npm:core-js@1.2.7/library/modules/$.js').getNames,
      toString = {}.toString;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function (it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]') return getWindowNames(it);
    return getNames(toIObject(it));
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/es6.object.get-own-property-names.js', ['npm:core-js@1.2.7/library/modules/$.object-sap.js', 'npm:core-js@1.2.7/library/modules/$.get-names.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('npm:core-js@1.2.7/library/modules/$.object-sap.js')('getOwnPropertyNames', function () {
    return $__require('npm:core-js@1.2.7/library/modules/$.get-names.js').get;
  });
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/object/get-own-property-names.js', ['npm:core-js@1.2.7/library/modules/$.js', 'npm:core-js@1.2.7/library/modules/es6.object.get-own-property-names.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('npm:core-js@1.2.7/library/modules/$.js');
  $__require('npm:core-js@1.2.7/library/modules/es6.object.get-own-property-names.js');
  module.exports = function getOwnPropertyNames(it) {
    return $.getNames(it);
  };
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/get-own-property-names.js", ["npm:core-js@1.2.7/library/fn/object/get-own-property-names.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/object/get-own-property-names.js"), __esModule: true };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/es6.object.freeze.js', ['npm:core-js@1.2.7/library/modules/$.is-object.js', 'npm:core-js@1.2.7/library/modules/$.object-sap.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('npm:core-js@1.2.7/library/modules/$.is-object.js');
  $__require('npm:core-js@1.2.7/library/modules/$.object-sap.js')('freeze', function ($freeze) {
    return function freeze(it) {
      return $freeze && isObject(it) ? $freeze(it) : it;
    };
  });
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/object/freeze.js', ['npm:core-js@1.2.7/library/modules/es6.object.freeze.js', 'npm:core-js@1.2.7/library/modules/$.core.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('npm:core-js@1.2.7/library/modules/es6.object.freeze.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.core.js').Object.freeze;
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/freeze.js", ["npm:core-js@1.2.7/library/fn/object/freeze.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/object/freeze.js"), __esModule: true };
});
System.register('src/utils.js', ['npm:babel-runtime@5.8.38/helpers/class-call-check.js', 'npm:babel-runtime@5.8.38/helpers/get.js', 'npm:babel-runtime@5.8.38/helpers/inherits.js', 'npm:babel-runtime@5.8.38/core-js/object/keys.js', 'npm:babel-runtime@5.8.38/core-js/object/get-own-property-names.js', 'npm:babel-runtime@5.8.38/core-js/object/freeze.js'], function (_export) {
  var _classCallCheck, _get, _inherits, _Object$keys, _Object$getOwnPropertyNames, _Object$freeze, AbstractError, AssertionError, memoMeasureX, memoMeasureY;

  function assert(test, message) {
    if (!test) {
      throw new AssertionError(message);
    }
  }

  function $(query) {
    return document.querySelector(query);
  }

  function clear(node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  }

  function deepEquals(a, b) {
    if (typeof a !== typeof b) {
      return false;
    } else if (typeof a === 'object') {
      return _Object$keys(a).every(function (key) {
        return deepEquals(a[key], b[key]);
      }) && _Object$keys(b).every(function (key) {
        return deepEquals(a[key], b[key]);
      });
    } else {
      return a === b;
    }
  }

  // @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
  // To make obj fully immutable, freeze each object in obj.
  // To do so, we use this function.

  function deepFreeze(obj) {

    // Retrieve the property names defined on obj
    var propNames = _Object$getOwnPropertyNames(obj);

    // Freeze properties before freezing self
    propNames.forEach(function (name) {
      var prop = obj[name];

      // Freeze prop if it is an object
      if (typeof prop == 'object' && prop !== null) deepFreeze(prop);
    });

    // Freeze self (no-op if already frozen)
    return _Object$freeze(obj);
  }

  function measureX(text, fontStack, fontSize) {
    if ([text, fontStack, fontSize].toString() in memoMeasureX) {
      return memoMeasureX[[text, fontStack, fontSize]];
    }

    var measure = $('#measure');
    measure.textContent = text;
    measure.style.fontFamily = fontStack;
    measure.style.fontSize = fontSize;

    var ans = measure.getBoundingClientRect().width;
    memoMeasureX[[text, fontStack, fontSize]] = ans;
    return ans;
  }

  function measureY(text, fontStack, fontSize) {
    if ([text, fontStack, fontSize].toString() in memoMeasureY) {
      return memoMeasureY[[text, fontStack, fontSize]];
    }

    var measure = $('#measure');
    measure.textContent = text;
    measure.style.fontFamily = fontStack;
    measure.style.fontSize = fontSize;

    var ans = measure.getBoundingClientRect().height;
    memoMeasureY[[text, fontStack, fontSize]] = ans;
    return ans;
  }

  function depthFirstTraversal(tree, fn) {
    var stack = [tree];
    while (stack.length !== 0) {
      var current = stack.pop();
      stack = stack.concat(current.children);
      fn(current);
    }
  }

  function breadthFirstTraversal(tree, fn) {
    var queue = [tree];
    while (queue.length !== 0) {
      var current = queue.shift();
      queue = queue.concat(current.children);
      fn(current);
    }
  }

  function delegate(object, parentProperties) {
    return {
      get: function get(target, property, receiver) {
        if (property in target) {
          return target[property];
        } else {
          var currentParentIdx = 0;
          while (currentParentIdx < parentProperties.length && !(property in object[parentProperties[currentParentIdx]])) {
            currentParentIdx++;
          }

          if (currentParentIdx < parentProperties.length) {
            return object[parentProperties[currentParentIdx]][property];
          }
        }
      },

      has: function has(target, property) {
        if (property in target) {
          return true;
        } else {
          var currentParentIdx = 0;
          while (currentParentIdx < parentProperties.length && !(property in object[parentProperties[currentParentIdx]])) {
            currentParentIdx++;
          }

          return currentParentIdx < parentProperties.length;
        }
      }
    };
  }

  function DOM(nodeType) {
    nodeType = nodeType.split('.');
    var element = document.createElement(nodeType[0]);

    if (nodeType.length > 1) {
      element.classList.add(nodeType[1]);
    }

    for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      children[_key - 1] = arguments[_key];
    }

    children.map(function (child) {
      return typeof child === 'string' ? document.createTextNode(child) : child;
    }).forEach(function (child) {
      return element.appendChild(child);
    });

    return element;
  }

  return {
    setters: [function (_npmBabelRuntime5838HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5838HelpersClassCallCheckJs['default'];
    }, function (_npmBabelRuntime5838HelpersGetJs) {
      _get = _npmBabelRuntime5838HelpersGetJs['default'];
    }, function (_npmBabelRuntime5838HelpersInheritsJs) {
      _inherits = _npmBabelRuntime5838HelpersInheritsJs['default'];
    }, function (_npmBabelRuntime5838CoreJsObjectKeysJs) {
      _Object$keys = _npmBabelRuntime5838CoreJsObjectKeysJs['default'];
    }, function (_npmBabelRuntime5838CoreJsObjectGetOwnPropertyNamesJs) {
      _Object$getOwnPropertyNames = _npmBabelRuntime5838CoreJsObjectGetOwnPropertyNamesJs['default'];
    }, function (_npmBabelRuntime5838CoreJsObjectFreezeJs) {
      _Object$freeze = _npmBabelRuntime5838CoreJsObjectFreezeJs['default'];
    }],
    execute: function () {
      'use strict';

      _export('assert', assert);

      _export('$', $);

      _export('clear', clear);

      _export('deepEquals', deepEquals);

      _export('deepFreeze', deepFreeze);

      _export('measureX', measureX);

      _export('measureY', measureY);

      _export('depthFirstTraversal', depthFirstTraversal);

      _export('breadthFirstTraversal', breadthFirstTraversal);

      _export('delegate', delegate);

      _export('DOM', DOM);

      AbstractError = function AbstractError(methodName) {
        _classCallCheck(this, AbstractError);

        this.methodName = methodName;
        this.message = methodName + ' is not implemented.';
      };

      _export('AbstractError', AbstractError);

      AssertionError = (function (_Error) {
        _inherits(AssertionError, _Error);

        function AssertionError() {
          _classCallCheck(this, AssertionError);

          _get(Object.getPrototypeOf(AssertionError.prototype), 'constructor', this).apply(this, arguments);
        }

        return AssertionError;
      })(Error);

      _export('AssertionError', AssertionError);

      memoMeasureX = {};
      memoMeasureY = {};
    }
  };
});
System.registerDynamic("npm:babel-runtime@5.8.38/helpers/class-call-check.js", [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  exports["default"] = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  exports.__esModule = true;
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.to-iobject.js', ['npm:core-js@1.2.7/library/modules/$.iobject.js', 'npm:core-js@1.2.7/library/modules/$.defined.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var IObject = $__require('npm:core-js@1.2.7/library/modules/$.iobject.js'),
      defined = $__require('npm:core-js@1.2.7/library/modules/$.defined.js');
  module.exports = function (it) {
    return IObject(defined(it));
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.object-sap.js', ['npm:core-js@1.2.7/library/modules/$.export.js', 'npm:core-js@1.2.7/library/modules/$.core.js', 'npm:core-js@1.2.7/library/modules/$.fails.js'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('npm:core-js@1.2.7/library/modules/$.export.js'),
        core = $__require('npm:core-js@1.2.7/library/modules/$.core.js'),
        fails = $__require('npm:core-js@1.2.7/library/modules/$.fails.js');
    module.exports = function (KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY],
            exp = {};
        exp[KEY] = exec(fn);
        $export($export.S + $export.F * fails(function () {
            fn(1);
        }), 'Object', exp);
    };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/es6.object.get-own-property-descriptor.js', ['npm:core-js@1.2.7/library/modules/$.to-iobject.js', 'npm:core-js@1.2.7/library/modules/$.object-sap.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toIObject = $__require('npm:core-js@1.2.7/library/modules/$.to-iobject.js');
  $__require('npm:core-js@1.2.7/library/modules/$.object-sap.js')('getOwnPropertyDescriptor', function ($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/object/get-own-property-descriptor.js', ['npm:core-js@1.2.7/library/modules/$.js', 'npm:core-js@1.2.7/library/modules/es6.object.get-own-property-descriptor.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('npm:core-js@1.2.7/library/modules/$.js');
  $__require('npm:core-js@1.2.7/library/modules/es6.object.get-own-property-descriptor.js');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/get-own-property-descriptor.js", ["npm:core-js@1.2.7/library/fn/object/get-own-property-descriptor.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/object/get-own-property-descriptor.js"), __esModule: true };
});
System.registerDynamic("npm:babel-runtime@5.8.38/helpers/get.js", ["npm:babel-runtime@5.8.38/core-js/object/get-own-property-descriptor.js"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$getOwnPropertyDescriptor = $__require("npm:babel-runtime@5.8.38/core-js/object/get-own-property-descriptor.js")["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null) object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/object/create.js', ['npm:core-js@1.2.7/library/modules/$.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('npm:core-js@1.2.7/library/modules/$.js');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/create.js", ["npm:core-js@1.2.7/library/fn/object/create.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/object/create.js"), __esModule: true };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.is-object.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.an-object.js', ['npm:core-js@1.2.7/library/modules/$.is-object.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('npm:core-js@1.2.7/library/modules/$.is-object.js');
  module.exports = function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.set-proto.js', ['npm:core-js@1.2.7/library/modules/$.js', 'npm:core-js@1.2.7/library/modules/$.is-object.js', 'npm:core-js@1.2.7/library/modules/$.an-object.js', 'npm:core-js@1.2.7/library/modules/$.ctx.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var getDesc = $__require('npm:core-js@1.2.7/library/modules/$.js').getDesc,
      isObject = $__require('npm:core-js@1.2.7/library/modules/$.is-object.js'),
      anObject = $__require('npm:core-js@1.2.7/library/modules/$.an-object.js');
  var check = function (O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function (test, buggy, set) {
      try {
        set = $__require('npm:core-js@1.2.7/library/modules/$.ctx.js')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/es6.object.set-prototype-of.js', ['npm:core-js@1.2.7/library/modules/$.export.js', 'npm:core-js@1.2.7/library/modules/$.set-proto.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('npm:core-js@1.2.7/library/modules/$.export.js');
  $export($export.S, 'Object', { setPrototypeOf: $__require('npm:core-js@1.2.7/library/modules/$.set-proto.js').set });
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/object/set-prototype-of.js', ['npm:core-js@1.2.7/library/modules/es6.object.set-prototype-of.js', 'npm:core-js@1.2.7/library/modules/$.core.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('npm:core-js@1.2.7/library/modules/es6.object.set-prototype-of.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.core.js').Object.setPrototypeOf;
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/set-prototype-of.js", ["npm:core-js@1.2.7/library/fn/object/set-prototype-of.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/object/set-prototype-of.js"), __esModule: true };
});
System.registerDynamic("npm:babel-runtime@5.8.38/helpers/inherits.js", ["npm:babel-runtime@5.8.38/core-js/object/create.js", "npm:babel-runtime@5.8.38/core-js/object/set-prototype-of.js"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$create = $__require("npm:babel-runtime@5.8.38/core-js/object/create.js")["default"];
  var _Object$setPrototypeOf = $__require("npm:babel-runtime@5.8.38/core-js/object/set-prototype-of.js")["default"];
  exports["default"] = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, { constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      } });
    if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.global.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.a-function.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.ctx.js', ['npm:core-js@1.2.7/library/modules/$.a-function.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var aFunction = $__require('npm:core-js@1.2.7/library/modules/$.a-function.js');
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };
      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.export.js', ['npm:core-js@1.2.7/library/modules/$.global.js', 'npm:core-js@1.2.7/library/modules/$.core.js', 'npm:core-js@1.2.7/library/modules/$.ctx.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var global = $__require('npm:core-js@1.2.7/library/modules/$.global.js'),
      core = $__require('npm:core-js@1.2.7/library/modules/$.core.js'),
      ctx = $__require('npm:core-js@1.2.7/library/modules/$.ctx.js'),
      PROTOTYPE = 'prototype';
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports) continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function (C) {
        var F = function (param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO) (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.defined.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.to-object.js', ['npm:core-js@1.2.7/library/modules/$.defined.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var defined = $__require('npm:core-js@1.2.7/library/modules/$.defined.js');
  module.exports = function (it) {
    return Object(defined(it));
  };
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.cof.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toString = {}.toString;

  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.iobject.js', ['npm:core-js@1.2.7/library/modules/$.cof.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var cof = $__require('npm:core-js@1.2.7/library/modules/$.cof.js');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
});
System.registerDynamic("npm:core-js@1.2.7/library/modules/$.fails.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.object-assign.js', ['npm:core-js@1.2.7/library/modules/$.js', 'npm:core-js@1.2.7/library/modules/$.to-object.js', 'npm:core-js@1.2.7/library/modules/$.iobject.js', 'npm:core-js@1.2.7/library/modules/$.fails.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('npm:core-js@1.2.7/library/modules/$.js'),
      toObject = $__require('npm:core-js@1.2.7/library/modules/$.to-object.js'),
      IObject = $__require('npm:core-js@1.2.7/library/modules/$.iobject.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.fails.js')(function () {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
    return T;
  } : Object.assign;
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/es6.object.assign.js', ['npm:core-js@1.2.7/library/modules/$.export.js', 'npm:core-js@1.2.7/library/modules/$.object-assign.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('npm:core-js@1.2.7/library/modules/$.export.js');
  $export($export.S + $export.F, 'Object', { assign: $__require('npm:core-js@1.2.7/library/modules/$.object-assign.js') });
});
System.registerDynamic('npm:core-js@1.2.7/library/modules/$.core.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var core = module.exports = { version: '1.2.6' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
System.registerDynamic('npm:core-js@1.2.7/library/fn/object/assign.js', ['npm:core-js@1.2.7/library/modules/es6.object.assign.js', 'npm:core-js@1.2.7/library/modules/$.core.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('npm:core-js@1.2.7/library/modules/es6.object.assign.js');
  module.exports = $__require('npm:core-js@1.2.7/library/modules/$.core.js').Object.assign;
});
System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/assign.js", ["npm:core-js@1.2.7/library/fn/object/assign.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("npm:core-js@1.2.7/library/fn/object/assign.js"), __esModule: true };
});
System.register('src/worker-utils.js', ['npm:babel-runtime@5.8.38/helpers/class-call-check.js', 'npm:babel-runtime@5.8.38/helpers/get.js', 'npm:babel-runtime@5.8.38/helpers/inherits.js', 'npm:babel-runtime@5.8.38/core-js/object/assign.js'], function (_export) {
    var _classCallCheck, _get, _inherits, _Object$assign, WorkerEvent, Message, ErrorMessage, InfoMessage, WarningMessage;

    function print() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var msg = _Object$assign({}, new Message(args));
        self.postMessage(msg);
    }

    function err() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
        }

        self.postMessage(new ErrorMessage(args));
    }

    function info() {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
        }

        self.postMessage(new InfoMessage(args));
    }

    function warn() {
        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
        }

        self.postMessage(new WarningMessage(args));
    }

    return {
        setters: [function (_npmBabelRuntime5838HelpersClassCallCheckJs) {
            _classCallCheck = _npmBabelRuntime5838HelpersClassCallCheckJs['default'];
        }, function (_npmBabelRuntime5838HelpersGetJs) {
            _get = _npmBabelRuntime5838HelpersGetJs['default'];
        }, function (_npmBabelRuntime5838HelpersInheritsJs) {
            _inherits = _npmBabelRuntime5838HelpersInheritsJs['default'];
        }, function (_npmBabelRuntime5838CoreJsObjectAssignJs) {
            _Object$assign = _npmBabelRuntime5838CoreJsObjectAssignJs['default'];
        }],
        execute: function () {
            'use strict';

            _export('print', print);

            _export('err', err);

            _export('info', info);

            _export('warn', warn);

            WorkerEvent = function WorkerEvent(name, data) {
                _classCallCheck(this, WorkerEvent);

                this.name = name;
                _Object$assign(this, data);
            };

            _export('WorkerEvent', WorkerEvent);

            Message = (function (_WorkerEvent) {
                _inherits(Message, _WorkerEvent);

                function Message(data) {
                    _classCallCheck(this, Message);

                    _get(Object.getPrototypeOf(Message.prototype), 'constructor', this).call(this, 'LOG', { data: data });
                }

                return Message;
            })(WorkerEvent);

            _export('Message', Message);

            ErrorMessage = (function (_Message) {
                _inherits(ErrorMessage, _Message);

                function ErrorMessage(data) {
                    _classCallCheck(this, ErrorMessage);

                    _get(Object.getPrototypeOf(ErrorMessage.prototype), 'constructor', this).call(this, data);
                    this.name = 'ERROR';
                }

                return ErrorMessage;
            })(Message);

            _export('ErrorMessage', ErrorMessage);

            InfoMessage = (function (_Message2) {
                _inherits(InfoMessage, _Message2);

                function InfoMessage(data) {
                    _classCallCheck(this, InfoMessage);

                    _get(Object.getPrototypeOf(InfoMessage.prototype), 'constructor', this).call(this, data);
                    this.name = 'INFO';
                }

                return InfoMessage;
            })(Message);

            _export('InfoMessage', InfoMessage);

            WarningMessage = (function (_Message3) {
                _inherits(WarningMessage, _Message3);

                function WarningMessage(data) {
                    _classCallCheck(this, WarningMessage);

                    _get(Object.getPrototypeOf(WarningMessage.prototype), 'constructor', this).call(this, data);
                    this.name = 'WARNING';
                }

                return WarningMessage;
            })(Message);

            _export('WarningMessage', WarningMessage);
        }
    };
});
System.register("src/instrument-lib.js", ["npm:babel-runtime@5.8.38/helpers/get.js", "npm:babel-runtime@5.8.38/helpers/inherits.js", "npm:babel-runtime@5.8.38/helpers/class-call-check.js", "npm:babel-runtime@5.8.38/helpers/create-class.js", "npm:babel-runtime@5.8.38/helpers/sliced-to-array.js", "npm:babel-runtime@5.8.38/core-js/object/keys.js", "npm:babel-runtime@5.8.38/core-js/object/assign.js", "src/utils.js", "src/worker-utils.js"], function (_export) {
    var _get, _inherits, _classCallCheck, _createClass, _slicedToArray, _Object$keys, _Object$assign, AbstractError, assert, deepEquals, print, OPERATION_BUDGET, OperationBudgetExceeded, Serializable, _ExecutionTrace, ExecutionState, _FnCall, uninstrumented;

    function serializableReplacer(key, value) {
        if (value instanceof Serializable) {
            return value.serialize();
        } else {
            return value;
        }
    }

    function serializableReviver() {
        var classes = arguments.length <= 0 || arguments[0] === undefined ? {
            'ExecutionTrace': function ExecutionTrace() {
                return new _ExecutionTrace();
            },
            'FnCall': function FnCall() {
                return new _FnCall();
            }
        } : arguments[0];

        return function (key, value) {
            var ans = value;
            _Object$keys(classes).forEach(function (className) {
                if (value != null && value.hasOwnProperty('_type') && value._type === className) {
                    var constr = classes[className];
                    ans = constr(value);
                    assert(ans instanceof Serializable, className + " is not a subclass of Serializable");
                    ans.deserialize(value);
                }
            });

            return ans;
        };
    }

    function ENTER(fnName, fn, args, receiver, location) {
        if (--state.operationBudget === 0) {
            throw new OperationBudgetExceeded(location);
        }

        if (!trace.functions.hasOwnProperty(fnName)) {
            trace.functions[fnName] = fn;
        }

        var call = new _FnCall(fnName, state.currentCall, args, receiver, location);
        if (_Object$keys(trace.calls).length === 0) {
            trace.rootCall = call;
        }
        call.cache();
        state.currentCall = call;
    }

    function LOOP(location) {
        if (--state.operationBudget === 0) {
            throw new OperationBudgetExceeded(location);
        }
    }

    function LEAVE(returnValue, loc) {
        state.currentCall.returnValue = returnValue;
        state.currentCall = state.currentCall.parent;
        return returnValue;
    }

    function THROW(error, loc) {
        return error;
    }

    function CATCH(error, loc, fnLoc) {
        while (!deepEquals(state.currentCall.location, fnLoc)) {
            state.currentCall.throws = error;
            state.currentCall = state.currentCall.parent;
        }
    }

    function CLEAR() {
        trace = new _ExecutionTrace();
        state = new ExecutionState();
    }

    function MONKEYPATCH() {
        uninstrumented['Array.map'] = Array.prototype.map;
        uninstrumented['Array.filter'] = Array.prototype.filter;
        uninstrumented['Array.reduce'] = Array.prototype.reduce;
        uninstrumented['Array.forEach'] = Array.prototype.forEach;
        uninstrumented['console.log'] = console.log;

        _Object$keys(uninstrumented).forEach(function (key) {
            var _key$split = key.split('.');

            var _key$split2 = _slicedToArray(_key$split, 2);

            var className = _key$split2[0];
            var methodName = _key$split2[1];

            if (className === 'Array') {
                Array.prototype[methodName] = wrapBuiltin(key, uninstrumented[key]);
            } else if (className === 'console' && methodName === 'log') {
                var wrapped = function wrapped() {
                    ENTER('console.log', uninstrumented['console.log'], arguments, null);
                    LOG(Array.prototype.slice.call(arguments));
                    return LEAVE(uninstrumented['console.log'].apply(console, arguments));
                };
                console[methodName] = wrapped;
            }
        });
    }

    function wrapBuiltin(name, uninstrumented) {
        return function () {
            ENTER(name, uninstrumented, arguments, null);
            return LEAVE(uninstrumented.apply(this, arguments));
        };
    }

    function RESETMONKEYPATCH() {
        uninstrumented['Array.forEach'].call(_Object$keys(uninstrumented), function (key) {
            var _key$split3 = key.split('.');

            var _key$split32 = _slicedToArray(_key$split3, 2);

            var className = _key$split32[0];
            var methodName = _key$split32[1];

            if (className === 'Array') {
                Array.prototype[methodName] = uninstrumented[key];
            } else if (className === 'console' && methodName === 'log') {
                console[methodName] = uninstrumented[key];
            }
        });
    }

    function TAG(key, optValue) {
        var optCondition = arguments.length <= 2 || arguments[2] === undefined ? function () {
            return true;
        } : arguments[2];

        if (optCondition()) {
            state.currentCall.tags[key] = optValue;
        }
    }

    function LOG() {
        print.apply(undefined, arguments);
    }

    return {
        setters: [function (_npmBabelRuntime5838HelpersGetJs) {
            _get = _npmBabelRuntime5838HelpersGetJs["default"];
        }, function (_npmBabelRuntime5838HelpersInheritsJs) {
            _inherits = _npmBabelRuntime5838HelpersInheritsJs["default"];
        }, function (_npmBabelRuntime5838HelpersClassCallCheckJs) {
            _classCallCheck = _npmBabelRuntime5838HelpersClassCallCheckJs["default"];
        }, function (_npmBabelRuntime5838HelpersCreateClassJs) {
            _createClass = _npmBabelRuntime5838HelpersCreateClassJs["default"];
        }, function (_npmBabelRuntime5838HelpersSlicedToArrayJs) {
            _slicedToArray = _npmBabelRuntime5838HelpersSlicedToArrayJs["default"];
        }, function (_npmBabelRuntime5838CoreJsObjectKeysJs) {
            _Object$keys = _npmBabelRuntime5838CoreJsObjectKeysJs["default"];
        }, function (_npmBabelRuntime5838CoreJsObjectAssignJs) {
            _Object$assign = _npmBabelRuntime5838CoreJsObjectAssignJs["default"];
        }, function (_srcUtilsJs) {
            AbstractError = _srcUtilsJs.AbstractError;
            assert = _srcUtilsJs.assert;
            deepEquals = _srcUtilsJs.deepEquals;
        }, function (_srcWorkerUtilsJs) {
            print = _srcWorkerUtilsJs.print;
        }],
        execute: function () {
            "use strict";

            _export("serializableReplacer", serializableReplacer);

            _export("serializableReviver", serializableReviver);

            _export("ENTER", ENTER);

            _export("LOOP", LOOP);

            _export("LEAVE", LEAVE);

            _export("THROW", THROW);

            _export("CATCH", CATCH);

            _export("CLEAR", CLEAR);

            _export("MONKEYPATCH", MONKEYPATCH);

            _export("RESETMONKEYPATCH", RESETMONKEYPATCH);

            _export("TAG", TAG);

            _export("LOG", LOG);

            OPERATION_BUDGET = 200;

            OperationBudgetExceeded = (function (_Error) {
                _inherits(OperationBudgetExceeded, _Error);

                function OperationBudgetExceeded(location) {
                    _classCallCheck(this, OperationBudgetExceeded);

                    _get(Object.getPrototypeOf(OperationBudgetExceeded.prototype), "constructor", this).call(this, "operation budget exceeded at " + JSON.stringify(location));
                    this.location = location;
                    this.message = "operation budget exceeded at " + JSON.stringify(location);
                }

                return OperationBudgetExceeded;
            })(Error);

            _export("OperationBudgetExceeded", OperationBudgetExceeded);

            Serializable = (function () {
                function Serializable() {
                    _classCallCheck(this, Serializable);
                }

                _createClass(Serializable, [{
                    key: "serialize",
                    value: function serialize() {
                        throw new AbstractError('Serializable.serialize');
                    }
                }, {
                    key: "deserialize",
                    value: function deserialize() {
                        throw new AbstractError('Serializable.deserialize');
                    }
                }]);

                return Serializable;
            })();

            _ExecutionTrace = (function (_Serializable) {
                _inherits(_ExecutionTrace, _Serializable);

                function _ExecutionTrace() {
                    _classCallCheck(this, _ExecutionTrace);

                    _get(Object.getPrototypeOf(_ExecutionTrace.prototype), "constructor", this).call(this);
                    this.functions = {};
                    this.calls = {};
                    this.rootCall = null;
                }

                _createClass(_ExecutionTrace, [{
                    key: "serialize",
                    value: function serialize() {
                        var _this = this;

                        var serializedFunctions = {};
                        _Object$keys(this.functions).forEach(function (key) {
                            serializedFunctions[key] = _this.functions[key] === null ? _this.functions[key] : _this.functions[key].toString();
                        });

                        var serializedCalls = _Object$keys(this.calls).map(function (key) {
                            return _this.calls[key];
                        }).reduce(function (agg, b) {
                            return agg.concat(b);
                        }, []).sort(function (a, b) {
                            return a.uid < b.uid ? -1 : a.uid === b.uid ? 0 : 1;
                        });

                        return {
                            _type: 'ExecutionTrace',
                            functions: serializedFunctions,
                            calls: serializedCalls,
                            rootCall: this.rootCall !== null ? this.rootCall.uid : null
                        };
                    }
                }, {
                    key: "deserialize",
                    value: function deserialize(data) {
                        var deserializedFunctions = {};
                        // Object.keys(data.functions)
                        //     .forEach(key => {
                        //         deserializedFunctions[key] = eval(data.functions[key]);
                        //     });

                        var deserializedCalls = {};
                        data.calls.forEach(function (call) {
                            if (!deserializedCalls.hasOwnProperty(call.fnName)) {
                                deserializedCalls[call.fnName] = [];
                            }
                            deserializedCalls[call.fnName].push(call);
                        });

                        this.functions = deserializedFunctions;
                        this.calls = deserializedCalls;
                        this.rootCall = data.rootCall === null ? null : this._lookupUid(data.rootCall);
                    }
                }]);

                return _ExecutionTrace;
            })(Serializable);

            _export("ExecutionTrace", _ExecutionTrace);

            ExecutionState = function ExecutionState() {
                _classCallCheck(this, ExecutionState);

                this.operationBudget = OPERATION_BUDGET;
                this.currentCall = null;
                this.nextUid = 0;
            };

            _export("ExecutionState", ExecutionState);

            _FnCall = (function (_Serializable2) {
                _inherits(_FnCall, _Serializable2);

                function _FnCall(fnName, parent, args, receiver, location) {
                    _classCallCheck(this, _FnCall);

                    _get(Object.getPrototypeOf(_FnCall.prototype), "constructor", this).call(this);
                    this.location = location;
                    this.isError = false;
                    this.tags = {};
                    this.fnName = fnName.replace(new RegExp('[$]', 'g'), '.');
                    this.args = Array.prototype.slice.call(args);
                    if (receiver !== undefined) {
                        this.receiver = _Object$assign({}, receiver);
                    }

                    this.uid = state.nextUid++;

                    this.parent = parent;
                    this.children = [];
                    if (this.parent !== null) {
                        this.parent.children.push(this);
                    }
                }

                _createClass(_FnCall, [{
                    key: "cache",
                    value: function cache() {
                        if (!trace.calls.hasOwnProperty(this.fnName)) {
                            trace.calls[this.fnName] = [];
                        }
                        trace.calls[this.fnName].push(this);
                    }
                }, {
                    key: "serialize",
                    value: function serialize() {
                        return {
                            _type: 'FnCall',
                            fnName: this.fnName,
                            args: this.args,
                            uid: this.uid,
                            location: this.location,
                            returnValue: this.returnValue,
                            throws: JSON.stringify(this.throws),
                            isError: this.isError,
                            tags: this.tags,
                            receiver: this.receiver, // TODO: this is terrible :(
                            parent: this.parent === null ? null : this.parent.uid,
                            children: this.children.map(function (child) {
                                return child.uid;
                            })
                        };
                    }
                }, {
                    key: "deserialize",
                    value: function deserialize(data) {
                        // this.fnName = data.fnName;
                        // this.args = data.args;
                        this.uid = data.uid;
                        this.location = data.location;
                        this.isError = data.isError;
                        this.parent = data.parent === null ? null : this._lookupUid(data.parent);
                        this.tags = data.tags;
                        if (data.hasOwnProperty('receiver')) {
                            this.receiver = data.receiver;
                        }
                        this.returnValue = data.returnValue;
                        if (data.hasOwnProperty('throws')) {
                            this.throws = JSON.parse(data.throws);
                        }
                        // this.children = data.children.map(child => this._lookupUid(child));
                        if (this.parent !== null) {
                            this.parent.children.push(this);
                        }
                    }
                }, {
                    key: "fn",
                    get: function get() {
                        return functions[this.fnName];
                    }
                }, {
                    key: "level",
                    get: function get() {
                        if (this.parent === null) {
                            return 0;
                        }

                        if (!this.hasOwnProperty('_level')) {
                            this._level = this.parent.level + 1;
                        }
                        return this._level;
                    }
                }]);

                return _FnCall;
            })(Serializable);

            _export("FnCall", _FnCall);

            self.trace = new _ExecutionTrace();
            self.state = new ExecutionState();

            uninstrumented = {};
        }
    };
});
System.registerDynamic('npm:recast@0.11.18/lib/parser.js', ['github:jspm/nodelibs-assert@0.1.0.js', 'npm:recast@0.11.18/lib/types.js', 'npm:recast@0.11.18/lib/patcher.js', 'npm:recast@0.11.18/lib/options.js', 'npm:recast@0.11.18/lib/lines.js', 'npm:recast@0.11.18/lib/comments.js', 'npm:recast@0.11.18/lib/util.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var assert = $__require('github:jspm/nodelibs-assert@0.1.0.js');
  var types = $__require('npm:recast@0.11.18/lib/types.js');
  var n = types.namedTypes;
  var b = types.builders;
  var isObject = types.builtInTypes.object;
  var isArray = types.builtInTypes.array;
  var isFunction = types.builtInTypes.function;
  var Patcher = $__require('npm:recast@0.11.18/lib/patcher.js').Patcher;
  var normalizeOptions = $__require('npm:recast@0.11.18/lib/options.js').normalize;
  var fromString = $__require('npm:recast@0.11.18/lib/lines.js').fromString;
  var attachComments = $__require('npm:recast@0.11.18/lib/comments.js').attach;
  var util = $__require('npm:recast@0.11.18/lib/util.js');
  exports.parse = function parse(source, options) {
    options = normalizeOptions(options);
    var lines = fromString(source, options);
    var sourceWithoutTabs = lines.toString({
      tabWidth: options.tabWidth,
      reuseWhitespace: false,
      useTabs: false
    });
    var comments = [];
    var program = options.parser.parse(sourceWithoutTabs, {
      jsx: true,
      loc: true,
      locations: true,
      range: options.range,
      comment: true,
      onComment: comments,
      tolerant: options.tolerant,
      ecmaVersion: 6,
      sourceType: 'module'
    });
    util.fixFaultyLocations(program, lines);
    program.loc = program.loc || {
      start: lines.firstPos(),
      end: lines.lastPos()
    };
    program.loc.lines = lines;
    program.loc.indent = 0;
    var trueProgramLoc = util.getTrueLoc(program, lines);
    program.loc.start = trueProgramLoc.start;
    program.loc.end = trueProgramLoc.end;
    if (program.comments) {
      comments = program.comments;
      delete program.comments;
    }
    var file = program;
    if (file.type === "Program") {
      var file = b.file(program);
      file.loc = {
        lines: lines,
        indent: 0,
        start: lines.firstPos(),
        end: lines.lastPos()
      };
    } else if (file.type === "File") {
      program = file.program;
    }
    attachComments(comments, program.body.length ? file.program : file, lines);
    return new TreeCopier(lines).copy(file);
  };
  function TreeCopier(lines) {
    assert.ok(this instanceof TreeCopier);
    this.lines = lines;
    this.indent = 0;
  }
  var TCp = TreeCopier.prototype;
  TCp.copy = function (node) {
    if (isArray.check(node)) {
      return node.map(this.copy, this);
    }
    if (!isObject.check(node)) {
      return node;
    }
    util.fixFaultyLocations(node, this.lines);
    var copy = Object.create(Object.getPrototypeOf(node), { original: {
        value: node,
        configurable: false,
        enumerable: false,
        writable: true
      } });
    var loc = node.loc;
    var oldIndent = this.indent;
    var newIndent = oldIndent;
    if (loc) {
      if (node.type === "Block" || node.type === "Line" || node.type === "CommentBlock" || node.type === "CommentLine" || this.lines.isPrecededOnlyByWhitespace(loc.start)) {
        newIndent = this.indent = loc.start.column;
      }
      loc.lines = this.lines;
      loc.indent = newIndent;
    }
    var keys = Object.keys(node);
    var keyCount = keys.length;
    for (var i = 0; i < keyCount; ++i) {
      var key = keys[i];
      if (key === "loc") {
        copy[key] = node[key];
      } else {
        copy[key] = this.copy(node[key]);
      }
    }
    this.indent = oldIndent;
    return copy;
  };
});
System.registerDynamic('npm:recast@0.11.18/lib/comments.js', ['github:jspm/nodelibs-assert@0.1.0.js', 'npm:recast@0.11.18/lib/types.js', 'npm:recast@0.11.18/lib/lines.js', 'npm:recast@0.11.18/lib/util.js', 'npm:private@0.1.6.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var assert = $__require('github:jspm/nodelibs-assert@0.1.0.js');
  var types = $__require('npm:recast@0.11.18/lib/types.js');
  var n = types.namedTypes;
  var isArray = types.builtInTypes.array;
  var isObject = types.builtInTypes.object;
  var linesModule = $__require('npm:recast@0.11.18/lib/lines.js');
  var fromString = linesModule.fromString;
  var Lines = linesModule.Lines;
  var concat = linesModule.concat;
  var util = $__require('npm:recast@0.11.18/lib/util.js');
  var comparePos = util.comparePos;
  var childNodesCacheKey = $__require('npm:private@0.1.6.js').makeUniqueKey();
  function getSortedChildNodes(node, lines, resultArray) {
    if (!node) {
      return;
    }
    util.fixFaultyLocations(node, lines);
    if (resultArray) {
      if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {
        for (var i = resultArray.length - 1; i >= 0; --i) {
          if (comparePos(resultArray[i].loc.end, node.loc.start) <= 0) {
            break;
          }
        }
        resultArray.splice(i + 1, 0, node);
        return;
      }
    } else if (node[childNodesCacheKey]) {
      return node[childNodesCacheKey];
    }
    var names;
    if (isArray.check(node)) {
      names = Object.keys(node);
    } else if (isObject.check(node)) {
      names = types.getFieldNames(node);
    } else {
      return;
    }
    if (!resultArray) {
      Object.defineProperty(node, childNodesCacheKey, {
        value: resultArray = [],
        enumerable: false
      });
    }
    for (var i = 0, nameCount = names.length; i < nameCount; ++i) {
      getSortedChildNodes(node[names[i]], lines, resultArray);
    }
    return resultArray;
  }
  function decorateComment(node, comment, lines) {
    var childNodes = getSortedChildNodes(node, lines);
    var left = 0,
        right = childNodes.length;
    while (left < right) {
      var middle = left + right >> 1;
      var child = childNodes[middle];
      if (comparePos(child.loc.start, comment.loc.start) <= 0 && comparePos(comment.loc.end, child.loc.end) <= 0) {
        decorateComment(comment.enclosingNode = child, comment, lines);
        return;
      }
      if (comparePos(child.loc.end, comment.loc.start) <= 0) {
        var precedingNode = child;
        left = middle + 1;
        continue;
      }
      if (comparePos(comment.loc.end, child.loc.start) <= 0) {
        var followingNode = child;
        right = middle;
        continue;
      }
      throw new Error("Comment location overlaps with node location");
    }
    if (precedingNode) {
      comment.precedingNode = precedingNode;
    }
    if (followingNode) {
      comment.followingNode = followingNode;
    }
  }
  exports.attach = function (comments, ast, lines) {
    if (!isArray.check(comments)) {
      return;
    }
    var tiesToBreak = [];
    comments.forEach(function (comment) {
      comment.loc.lines = lines;
      decorateComment(ast, comment, lines);
      var pn = comment.precedingNode;
      var en = comment.enclosingNode;
      var fn = comment.followingNode;
      if (pn && fn) {
        var tieCount = tiesToBreak.length;
        if (tieCount > 0) {
          var lastTie = tiesToBreak[tieCount - 1];
          assert.strictEqual(lastTie.precedingNode === comment.precedingNode, lastTie.followingNode === comment.followingNode);
          if (lastTie.followingNode !== comment.followingNode) {
            breakTies(tiesToBreak, lines);
          }
        }
        tiesToBreak.push(comment);
      } else if (pn) {
        breakTies(tiesToBreak, lines);
        addTrailingComment(pn, comment);
      } else if (fn) {
        breakTies(tiesToBreak, lines);
        addLeadingComment(fn, comment);
      } else if (en) {
        breakTies(tiesToBreak, lines);
        addDanglingComment(en, comment);
      } else {
        throw new Error("AST contains no nodes at all?");
      }
    });
    breakTies(tiesToBreak, lines);
    comments.forEach(function (comment) {
      delete comment.precedingNode;
      delete comment.enclosingNode;
      delete comment.followingNode;
    });
  };
  function breakTies(tiesToBreak, lines) {
    var tieCount = tiesToBreak.length;
    if (tieCount === 0) {
      return;
    }
    var pn = tiesToBreak[0].precedingNode;
    var fn = tiesToBreak[0].followingNode;
    var gapEndPos = fn.loc.start;
    for (var indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
      var comment = tiesToBreak[indexOfFirstLeadingComment - 1];
      assert.strictEqual(comment.precedingNode, pn);
      assert.strictEqual(comment.followingNode, fn);
      var gap = lines.sliceString(comment.loc.end, gapEndPos);
      if (/\S/.test(gap)) {
        break;
      }
      gapEndPos = comment.loc.start;
    }
    while (indexOfFirstLeadingComment <= tieCount && (comment = tiesToBreak[indexOfFirstLeadingComment]) && (comment.type === "Line" || comment.type === "CommentLine") && comment.loc.start.column > fn.loc.start.column) {
      ++indexOfFirstLeadingComment;
    }
    tiesToBreak.forEach(function (comment, i) {
      if (i < indexOfFirstLeadingComment) {
        addTrailingComment(pn, comment);
      } else {
        addLeadingComment(fn, comment);
      }
    });
    tiesToBreak.length = 0;
  }
  function addCommentHelper(node, comment) {
    var comments = node.comments || (node.comments = []);
    comments.push(comment);
  }
  function addLeadingComment(node, comment) {
    comment.leading = true;
    comment.trailing = false;
    addCommentHelper(node, comment);
  }
  function addDanglingComment(node, comment) {
    comment.leading = false;
    comment.trailing = false;
    addCommentHelper(node, comment);
  }
  function addTrailingComment(node, comment) {
    comment.leading = false;
    comment.trailing = true;
    addCommentHelper(node, comment);
  }
  function printLeadingComment(commentPath, print) {
    var comment = commentPath.getValue();
    n.Comment.assert(comment);
    var loc = comment.loc;
    var lines = loc && loc.lines;
    var parts = [print(commentPath)];
    if (comment.trailing) {
      parts.push("\n");
    } else if (lines instanceof Lines) {
      var trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end));
      if (trailingSpace.length === 1) {
        parts.push(trailingSpace);
      } else {
        parts.push(new Array(trailingSpace.length).join("\n"));
      }
    } else {
      parts.push("\n");
    }
    return concat(parts);
  }
  function printTrailingComment(commentPath, print) {
    var comment = commentPath.getValue(commentPath);
    n.Comment.assert(comment);
    var loc = comment.loc;
    var lines = loc && loc.lines;
    var parts = [];
    if (lines instanceof Lines) {
      var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();
      var leadingSpace = lines.slice(fromPos, loc.start);
      if (leadingSpace.length === 1) {
        parts.push(leadingSpace);
      } else {
        parts.push(new Array(leadingSpace.length).join("\n"));
      }
    }
    parts.push(print(commentPath));
    return concat(parts);
  }
  exports.printComments = function (path, print) {
    var value = path.getValue();
    var innerLines = print(path);
    var comments = n.Node.check(value) && types.getFieldValue(value, "comments");
    if (!comments || comments.length === 0) {
      return innerLines;
    }
    var leadingParts = [];
    var trailingParts = [innerLines];
    path.each(function (commentPath) {
      var comment = commentPath.getValue();
      var leading = types.getFieldValue(comment, "leading");
      var trailing = types.getFieldValue(comment, "trailing");
      if (leading || trailing && !(n.Statement.check(value) || comment.type === "Block" || comment.type === "CommentBlock")) {
        leadingParts.push(printLeadingComment(commentPath, print));
      } else if (trailing) {
        trailingParts.push(printTrailingComment(commentPath, print));
      }
    }, "comments");
    leadingParts.push.apply(leadingParts, trailingParts);
    return concat(leadingParts);
  };
});
System.registerDynamic('npm:esprima@3.1.2/dist/esprima.js', [], true, function ($__require, exports, module) {
	/* */
	"format cjs";

	var global = this || self,
	    GLOBAL = global;
	(function webpackUniversalModuleDefinition(root, factory) {
		/* istanbul ignore next */
		if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof undefined === 'function' && define.amd) define([], factory);
		/* istanbul ignore next */
		else if (typeof exports === 'object') exports["esprima"] = factory();else root["esprima"] = factory();
	})(this, function () {
		return (/******/function (modules) {
				// webpackBootstrap
				/******/ // The module cache
				/******/var installedModules = {};

				/******/ // The require function
				/******/function __webpack_require__(moduleId) {

					/******/ // Check if module is in cache
					/* istanbul ignore if */
					/******/if (installedModules[moduleId])
						/******/return installedModules[moduleId].exports;

					/******/ // Create a new module (and put it into the cache)
					/******/var module = installedModules[moduleId] = {
						/******/exports: {},
						/******/id: moduleId,
						/******/loaded: false
						/******/ };

					/******/ // Execute the module function
					/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

					/******/ // Flag the module as loaded
					/******/module.loaded = true;

					/******/ // Return the exports of the module
					/******/return module.exports;
					/******/
				}

				/******/ // expose the modules object (__webpack_modules__)
				/******/__webpack_require__.m = modules;

				/******/ // expose the module cache
				/******/__webpack_require__.c = installedModules;

				/******/ // __webpack_public_path__
				/******/__webpack_require__.p = "";

				/******/ // Load entry module and return exports
				/******/return __webpack_require__(0);
				/******/
			}(
			/************************************************************************/
			/******/[
			/* 0 */
			/***/function (module, exports, __webpack_require__) {

				/*
      Copyright JS Foundation and other contributors, https://js.foundation/
    	  Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    	    * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
				"use strict";

				var comment_handler_1 = __webpack_require__(1);
				var parser_1 = __webpack_require__(3);
				var jsx_parser_1 = __webpack_require__(11);
				var tokenizer_1 = __webpack_require__(15);
				function parse(code, options, delegate) {
					var commentHandler = null;
					var proxyDelegate = function (node, metadata) {
						if (delegate) {
							delegate(node, metadata);
						}
						if (commentHandler) {
							commentHandler.visit(node, metadata);
						}
					};
					var parserDelegate = typeof delegate === 'function' ? proxyDelegate : null;
					var collectComment = false;
					if (options) {
						collectComment = typeof options.comment === 'boolean' && options.comment;
						var attachComment = typeof options.attachComment === 'boolean' && options.attachComment;
						if (collectComment || attachComment) {
							commentHandler = new comment_handler_1.CommentHandler();
							commentHandler.attach = attachComment;
							options.comment = true;
							parserDelegate = proxyDelegate;
						}
					}
					var parser;
					if (options && typeof options.jsx === 'boolean' && options.jsx) {
						parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
					} else {
						parser = new parser_1.Parser(code, options, parserDelegate);
					}
					var ast = parser.parseProgram();
					if (collectComment) {
						ast.comments = commentHandler.comments;
					}
					if (parser.config.tokens) {
						ast.tokens = parser.tokens;
					}
					if (parser.config.tolerant) {
						ast.errors = parser.errorHandler.errors;
					}
					return ast;
				}
				exports.parse = parse;
				function tokenize(code, options, delegate) {
					var tokenizer = new tokenizer_1.Tokenizer(code, options);
					var tokens;
					tokens = [];
					try {
						while (true) {
							var token = tokenizer.getNextToken();
							if (!token) {
								break;
							}
							if (delegate) {
								token = delegate(token);
							}
							tokens.push(token);
						}
					} catch (e) {
						tokenizer.errorHandler.tolerate(e);
					}
					if (tokenizer.errorHandler.tolerant) {
						tokens.errors = tokenizer.errors();
					}
					return tokens;
				}
				exports.tokenize = tokenize;
				var syntax_1 = __webpack_require__(2);
				exports.Syntax = syntax_1.Syntax;
				// Sync with *.json manifests.
				exports.version = '3.1.2';

				/***/
			},
			/* 1 */
			/***/function (module, exports, __webpack_require__) {

				"use strict";

				var syntax_1 = __webpack_require__(2);
				var CommentHandler = function () {
					function CommentHandler() {
						this.attach = false;
						this.comments = [];
						this.stack = [];
						this.leading = [];
						this.trailing = [];
					}
					CommentHandler.prototype.insertInnerComments = function (node, metadata) {
						//  innnerComments for properties empty block
						//  `function a() {/** comments **\/}`
						if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
							var innerComments = [];
							for (var i = this.leading.length - 1; i >= 0; --i) {
								var entry = this.leading[i];
								if (metadata.end.offset >= entry.start) {
									innerComments.unshift(entry.comment);
									this.leading.splice(i, 1);
									this.trailing.splice(i, 1);
								}
							}
							if (innerComments.length) {
								node.innerComments = innerComments;
							}
						}
					};
					CommentHandler.prototype.findTrailingComments = function (node, metadata) {
						var trailingComments = [];
						if (this.trailing.length > 0) {
							for (var i = this.trailing.length - 1; i >= 0; --i) {
								var entry_1 = this.trailing[i];
								if (entry_1.start >= metadata.end.offset) {
									trailingComments.unshift(entry_1.comment);
								}
							}
							this.trailing.length = 0;
							return trailingComments;
						}
						var entry = this.stack[this.stack.length - 1];
						if (entry && entry.node.trailingComments) {
							var firstComment = entry.node.trailingComments[0];
							if (firstComment && firstComment.range[0] >= metadata.end.offset) {
								trailingComments = entry.node.trailingComments;
								delete entry.node.trailingComments;
							}
						}
						return trailingComments;
					};
					CommentHandler.prototype.findLeadingComments = function (node, metadata) {
						var leadingComments = [];
						var target;
						while (this.stack.length > 0) {
							var entry = this.stack[this.stack.length - 1];
							if (entry && entry.start >= metadata.start.offset) {
								target = this.stack.pop().node;
							} else {
								break;
							}
						}
						if (target) {
							var count = target.leadingComments ? target.leadingComments.length : 0;
							for (var i = count - 1; i >= 0; --i) {
								var comment = target.leadingComments[i];
								if (comment.range[1] <= metadata.start.offset) {
									leadingComments.unshift(comment);
									target.leadingComments.splice(i, 1);
								}
							}
							if (target.leadingComments && target.leadingComments.length === 0) {
								delete target.leadingComments;
							}
							return leadingComments;
						}
						for (var i = this.leading.length - 1; i >= 0; --i) {
							var entry = this.leading[i];
							if (entry.start <= metadata.start.offset) {
								leadingComments.unshift(entry.comment);
								this.leading.splice(i, 1);
							}
						}
						return leadingComments;
					};
					CommentHandler.prototype.visitNode = function (node, metadata) {
						if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
							return;
						}
						this.insertInnerComments(node, metadata);
						var trailingComments = this.findTrailingComments(node, metadata);
						var leadingComments = this.findLeadingComments(node, metadata);
						if (leadingComments.length > 0) {
							node.leadingComments = leadingComments;
						}
						if (trailingComments.length > 0) {
							node.trailingComments = trailingComments;
						}
						this.stack.push({
							node: node,
							start: metadata.start.offset
						});
					};
					CommentHandler.prototype.visitComment = function (node, metadata) {
						var type = node.type[0] === 'L' ? 'Line' : 'Block';
						var comment = {
							type: type,
							value: node.value
						};
						if (node.range) {
							comment.range = node.range;
						}
						if (node.loc) {
							comment.loc = node.loc;
						}
						this.comments.push(comment);
						if (this.attach) {
							var entry = {
								comment: {
									type: type,
									value: node.value,
									range: [metadata.start.offset, metadata.end.offset]
								},
								start: metadata.start.offset
							};
							if (node.loc) {
								entry.comment.loc = node.loc;
							}
							node.type = type;
							this.leading.push(entry);
							this.trailing.push(entry);
						}
					};
					CommentHandler.prototype.visit = function (node, metadata) {
						if (node.type === 'LineComment') {
							this.visitComment(node, metadata);
						} else if (node.type === 'BlockComment') {
							this.visitComment(node, metadata);
						} else if (this.attach) {
							this.visitNode(node, metadata);
						}
					};
					return CommentHandler;
				}();
				exports.CommentHandler = CommentHandler;

				/***/
			},
			/* 2 */
			/***/function (module, exports) {

				"use strict";

				exports.Syntax = {
					AssignmentExpression: 'AssignmentExpression',
					AssignmentPattern: 'AssignmentPattern',
					ArrayExpression: 'ArrayExpression',
					ArrayPattern: 'ArrayPattern',
					ArrowFunctionExpression: 'ArrowFunctionExpression',
					BlockStatement: 'BlockStatement',
					BinaryExpression: 'BinaryExpression',
					BreakStatement: 'BreakStatement',
					CallExpression: 'CallExpression',
					CatchClause: 'CatchClause',
					ClassBody: 'ClassBody',
					ClassDeclaration: 'ClassDeclaration',
					ClassExpression: 'ClassExpression',
					ConditionalExpression: 'ConditionalExpression',
					ContinueStatement: 'ContinueStatement',
					DoWhileStatement: 'DoWhileStatement',
					DebuggerStatement: 'DebuggerStatement',
					EmptyStatement: 'EmptyStatement',
					ExportAllDeclaration: 'ExportAllDeclaration',
					ExportDefaultDeclaration: 'ExportDefaultDeclaration',
					ExportNamedDeclaration: 'ExportNamedDeclaration',
					ExportSpecifier: 'ExportSpecifier',
					ExpressionStatement: 'ExpressionStatement',
					ForStatement: 'ForStatement',
					ForOfStatement: 'ForOfStatement',
					ForInStatement: 'ForInStatement',
					FunctionDeclaration: 'FunctionDeclaration',
					FunctionExpression: 'FunctionExpression',
					Identifier: 'Identifier',
					IfStatement: 'IfStatement',
					ImportDeclaration: 'ImportDeclaration',
					ImportDefaultSpecifier: 'ImportDefaultSpecifier',
					ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
					ImportSpecifier: 'ImportSpecifier',
					Literal: 'Literal',
					LabeledStatement: 'LabeledStatement',
					LogicalExpression: 'LogicalExpression',
					MemberExpression: 'MemberExpression',
					MetaProperty: 'MetaProperty',
					MethodDefinition: 'MethodDefinition',
					NewExpression: 'NewExpression',
					ObjectExpression: 'ObjectExpression',
					ObjectPattern: 'ObjectPattern',
					Program: 'Program',
					Property: 'Property',
					RestElement: 'RestElement',
					ReturnStatement: 'ReturnStatement',
					SequenceExpression: 'SequenceExpression',
					SpreadElement: 'SpreadElement',
					Super: 'Super',
					SwitchCase: 'SwitchCase',
					SwitchStatement: 'SwitchStatement',
					TaggedTemplateExpression: 'TaggedTemplateExpression',
					TemplateElement: 'TemplateElement',
					TemplateLiteral: 'TemplateLiteral',
					ThisExpression: 'ThisExpression',
					ThrowStatement: 'ThrowStatement',
					TryStatement: 'TryStatement',
					UnaryExpression: 'UnaryExpression',
					UpdateExpression: 'UpdateExpression',
					VariableDeclaration: 'VariableDeclaration',
					VariableDeclarator: 'VariableDeclarator',
					WhileStatement: 'WhileStatement',
					WithStatement: 'WithStatement',
					YieldExpression: 'YieldExpression'
				};

				/***/
			},
			/* 3 */
			/***/function (module, exports, __webpack_require__) {

				"use strict";

				var assert_1 = __webpack_require__(4);
				var messages_1 = __webpack_require__(5);
				var error_handler_1 = __webpack_require__(6);
				var token_1 = __webpack_require__(7);
				var scanner_1 = __webpack_require__(8);
				var syntax_1 = __webpack_require__(2);
				var Node = __webpack_require__(10);
				var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
				var Parser = function () {
					function Parser(code, options, delegate) {
						if (options === void 0) {
							options = {};
						}
						this.config = {
							range: typeof options.range === 'boolean' && options.range,
							loc: typeof options.loc === 'boolean' && options.loc,
							source: null,
							tokens: typeof options.tokens === 'boolean' && options.tokens,
							comment: typeof options.comment === 'boolean' && options.comment,
							tolerant: typeof options.tolerant === 'boolean' && options.tolerant
						};
						if (this.config.loc && options.source && options.source !== null) {
							this.config.source = String(options.source);
						}
						this.delegate = delegate;
						this.errorHandler = new error_handler_1.ErrorHandler();
						this.errorHandler.tolerant = this.config.tolerant;
						this.scanner = new scanner_1.Scanner(code, this.errorHandler);
						this.scanner.trackComment = this.config.comment;
						this.operatorPrecedence = {
							')': 0,
							';': 0,
							',': 0,
							'=': 0,
							']': 0,
							'||': 1,
							'&&': 2,
							'|': 3,
							'^': 4,
							'&': 5,
							'==': 6,
							'!=': 6,
							'===': 6,
							'!==': 6,
							'<': 7,
							'>': 7,
							'<=': 7,
							'>=': 7,
							'<<': 8,
							'>>': 8,
							'>>>': 8,
							'+': 9,
							'-': 9,
							'*': 11,
							'/': 11,
							'%': 11
						};
						this.sourceType = options && options.sourceType === 'module' ? 'module' : 'script';
						this.lookahead = null;
						this.hasLineTerminator = false;
						this.context = {
							allowIn: true,
							allowYield: true,
							firstCoverInitializedNameError: null,
							isAssignmentTarget: false,
							isBindingElement: false,
							inFunctionBody: false,
							inIteration: false,
							inSwitch: false,
							labelSet: {},
							strict: this.sourceType === 'module'
						};
						this.tokens = [];
						this.startMarker = {
							index: 0,
							lineNumber: this.scanner.lineNumber,
							lineStart: 0
						};
						this.lastMarker = {
							index: 0,
							lineNumber: this.scanner.lineNumber,
							lineStart: 0
						};
						this.nextToken();
						this.lastMarker = {
							index: this.scanner.index,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart
						};
					}
					Parser.prototype.throwError = function (messageFormat) {
						var values = [];
						for (var _i = 1; _i < arguments.length; _i++) {
							values[_i - 1] = arguments[_i];
						}
						var args = Array.prototype.slice.call(arguments, 1);
						var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
							assert_1.assert(idx < args.length, 'Message reference must be in range');
							return args[idx];
						});
						var index = this.lastMarker.index;
						var line = this.lastMarker.lineNumber;
						var column = this.lastMarker.index - this.lastMarker.lineStart + 1;
						throw this.errorHandler.createError(index, line, column, msg);
					};
					Parser.prototype.tolerateError = function (messageFormat) {
						var values = [];
						for (var _i = 1; _i < arguments.length; _i++) {
							values[_i - 1] = arguments[_i];
						}
						var args = Array.prototype.slice.call(arguments, 1);
						var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
							assert_1.assert(idx < args.length, 'Message reference must be in range');
							return args[idx];
						});
						var index = this.lastMarker.index;
						var line = this.scanner.lineNumber;
						var column = this.lastMarker.index - this.lastMarker.lineStart + 1;
						this.errorHandler.tolerateError(index, line, column, msg);
					};
					// Throw an exception because of the token.
					Parser.prototype.unexpectedTokenError = function (token, message) {
						var msg = message || messages_1.Messages.UnexpectedToken;
						var value;
						if (token) {
							if (!message) {
								msg = token.type === token_1.Token.EOF ? messages_1.Messages.UnexpectedEOS : token.type === token_1.Token.Identifier ? messages_1.Messages.UnexpectedIdentifier : token.type === token_1.Token.NumericLiteral ? messages_1.Messages.UnexpectedNumber : token.type === token_1.Token.StringLiteral ? messages_1.Messages.UnexpectedString : token.type === token_1.Token.Template ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
								if (token.type === token_1.Token.Keyword) {
									if (this.scanner.isFutureReservedWord(token.value)) {
										msg = messages_1.Messages.UnexpectedReserved;
									} else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
										msg = messages_1.Messages.StrictReservedWord;
									}
								}
							}
							value = token.type === token_1.Token.Template ? token.value.raw : token.value;
						} else {
							value = 'ILLEGAL';
						}
						msg = msg.replace('%0', value);
						if (token && typeof token.lineNumber === 'number') {
							var index = token.start;
							var line = token.lineNumber;
							var column = token.start - this.lastMarker.lineStart + 1;
							return this.errorHandler.createError(index, line, column, msg);
						} else {
							var index = this.lastMarker.index;
							var line = this.lastMarker.lineNumber;
							var column = index - this.lastMarker.lineStart + 1;
							return this.errorHandler.createError(index, line, column, msg);
						}
					};
					Parser.prototype.throwUnexpectedToken = function (token, message) {
						throw this.unexpectedTokenError(token, message);
					};
					Parser.prototype.tolerateUnexpectedToken = function (token, message) {
						this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
					};
					Parser.prototype.collectComments = function () {
						if (!this.config.comment) {
							this.scanner.scanComments();
						} else {
							var comments = this.scanner.scanComments();
							if (comments.length > 0 && this.delegate) {
								for (var i = 0; i < comments.length; ++i) {
									var e = comments[i];
									var node = void 0;
									node = {
										type: e.multiLine ? 'BlockComment' : 'LineComment',
										value: this.scanner.source.slice(e.slice[0], e.slice[1])
									};
									if (this.config.range) {
										node.range = e.range;
									}
									if (this.config.loc) {
										node.loc = e.loc;
									}
									var metadata = {
										start: {
											line: e.loc.start.line,
											column: e.loc.start.column,
											offset: e.range[0]
										},
										end: {
											line: e.loc.end.line,
											column: e.loc.end.column,
											offset: e.range[1]
										}
									};
									this.delegate(node, metadata);
								}
							}
						}
					};
					// From internal representation to an external structure
					Parser.prototype.getTokenRaw = function (token) {
						return this.scanner.source.slice(token.start, token.end);
					};
					Parser.prototype.convertToken = function (token) {
						var t;
						t = {
							type: token_1.TokenName[token.type],
							value: this.getTokenRaw(token)
						};
						if (this.config.range) {
							t.range = [token.start, token.end];
						}
						if (this.config.loc) {
							t.loc = {
								start: {
									line: this.startMarker.lineNumber,
									column: this.startMarker.index - this.startMarker.lineStart
								},
								end: {
									line: this.scanner.lineNumber,
									column: this.scanner.index - this.scanner.lineStart
								}
							};
						}
						if (token.regex) {
							t.regex = token.regex;
						}
						return t;
					};
					Parser.prototype.nextToken = function () {
						var token = this.lookahead;
						this.lastMarker.index = this.scanner.index;
						this.lastMarker.lineNumber = this.scanner.lineNumber;
						this.lastMarker.lineStart = this.scanner.lineStart;
						this.collectComments();
						this.startMarker.index = this.scanner.index;
						this.startMarker.lineNumber = this.scanner.lineNumber;
						this.startMarker.lineStart = this.scanner.lineStart;
						var next;
						next = this.scanner.lex();
						this.hasLineTerminator = token && next ? token.lineNumber !== next.lineNumber : false;
						if (next && this.context.strict && next.type === token_1.Token.Identifier) {
							if (this.scanner.isStrictModeReservedWord(next.value)) {
								next.type = token_1.Token.Keyword;
							}
						}
						this.lookahead = next;
						if (this.config.tokens && next.type !== token_1.Token.EOF) {
							this.tokens.push(this.convertToken(next));
						}
						return token;
					};
					Parser.prototype.nextRegexToken = function () {
						this.collectComments();
						var token = this.scanner.scanRegExp();
						if (this.config.tokens) {
							// Pop the previous token, '/' or '/='
							// This is added from the lookahead token.
							this.tokens.pop();
							this.tokens.push(this.convertToken(token));
						}
						// Prime the next lookahead.
						this.lookahead = token;
						this.nextToken();
						return token;
					};
					Parser.prototype.createNode = function () {
						return {
							index: this.startMarker.index,
							line: this.startMarker.lineNumber,
							column: this.startMarker.index - this.startMarker.lineStart
						};
					};
					Parser.prototype.startNode = function (token) {
						return {
							index: token.start,
							line: token.lineNumber,
							column: token.start - token.lineStart
						};
					};
					Parser.prototype.finalize = function (meta, node) {
						if (this.config.range) {
							node.range = [meta.index, this.lastMarker.index];
						}
						if (this.config.loc) {
							node.loc = {
								start: {
									line: meta.line,
									column: meta.column
								},
								end: {
									line: this.lastMarker.lineNumber,
									column: this.lastMarker.index - this.lastMarker.lineStart
								}
							};
							if (this.config.source) {
								node.loc.source = this.config.source;
							}
						}
						if (this.delegate) {
							var metadata = {
								start: {
									line: meta.line,
									column: meta.column,
									offset: meta.index
								},
								end: {
									line: this.lastMarker.lineNumber,
									column: this.lastMarker.index - this.lastMarker.lineStart,
									offset: this.lastMarker.index
								}
							};
							this.delegate(node, metadata);
						}
						return node;
					};
					// Expect the next token to match the specified punctuator.
					// If not, an exception will be thrown.
					Parser.prototype.expect = function (value) {
						var token = this.nextToken();
						if (token.type !== token_1.Token.Punctuator || token.value !== value) {
							this.throwUnexpectedToken(token);
						}
					};
					// Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
					Parser.prototype.expectCommaSeparator = function () {
						if (this.config.tolerant) {
							var token = this.lookahead;
							if (token.type === token_1.Token.Punctuator && token.value === ',') {
								this.nextToken();
							} else if (token.type === token_1.Token.Punctuator && token.value === ';') {
								this.nextToken();
								this.tolerateUnexpectedToken(token);
							} else {
								this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
							}
						} else {
							this.expect(',');
						}
					};
					// Expect the next token to match the specified keyword.
					// If not, an exception will be thrown.
					Parser.prototype.expectKeyword = function (keyword) {
						var token = this.nextToken();
						if (token.type !== token_1.Token.Keyword || token.value !== keyword) {
							this.throwUnexpectedToken(token);
						}
					};
					// Return true if the next token matches the specified punctuator.
					Parser.prototype.match = function (value) {
						return this.lookahead.type === token_1.Token.Punctuator && this.lookahead.value === value;
					};
					// Return true if the next token matches the specified keyword
					Parser.prototype.matchKeyword = function (keyword) {
						return this.lookahead.type === token_1.Token.Keyword && this.lookahead.value === keyword;
					};
					// Return true if the next token matches the specified contextual keyword
					// (where an identifier is sometimes a keyword depending on the context)
					Parser.prototype.matchContextualKeyword = function (keyword) {
						return this.lookahead.type === token_1.Token.Identifier && this.lookahead.value === keyword;
					};
					// Return true if the next token is an assignment operator
					Parser.prototype.matchAssign = function () {
						if (this.lookahead.type !== token_1.Token.Punctuator) {
							return false;
						}
						var op = this.lookahead.value;
						return op === '=' || op === '*=' || op === '**=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
					};
					// Cover grammar support.
					//
					// When an assignment expression position starts with an left parenthesis, the determination of the type
					// of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
					// or the first comma. This situation also defers the determination of all the expressions nested in the pair.
					//
					// There are three productions that can be parsed in a parentheses pair that needs to be determined
					// after the outermost pair is closed. They are:
					//
					//   1. AssignmentExpression
					//   2. BindingElements
					//   3. AssignmentTargets
					//
					// In order to avoid exponential backtracking, we use two flags to denote if the production can be
					// binding element or assignment target.
					//
					// The three productions have the relationship:
					//
					//   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
					//
					// with a single exception that CoverInitializedName when used directly in an Expression, generates
					// an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
					// first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
					//
					// isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
					// effect the current flags. This means the production the parser parses is only used as an expression. Therefore
					// the CoverInitializedName check is conducted.
					//
					// inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
					// the flags outside of the parser. This means the production the parser parses is used as a part of a potential
					// pattern. The CoverInitializedName check is deferred.
					Parser.prototype.isolateCoverGrammar = function (parseFunction) {
						var previousIsBindingElement = this.context.isBindingElement;
						var previousIsAssignmentTarget = this.context.isAssignmentTarget;
						var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
						this.context.isBindingElement = true;
						this.context.isAssignmentTarget = true;
						this.context.firstCoverInitializedNameError = null;
						var result = parseFunction.call(this);
						if (this.context.firstCoverInitializedNameError !== null) {
							this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
						}
						this.context.isBindingElement = previousIsBindingElement;
						this.context.isAssignmentTarget = previousIsAssignmentTarget;
						this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
						return result;
					};
					Parser.prototype.inheritCoverGrammar = function (parseFunction) {
						var previousIsBindingElement = this.context.isBindingElement;
						var previousIsAssignmentTarget = this.context.isAssignmentTarget;
						var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
						this.context.isBindingElement = true;
						this.context.isAssignmentTarget = true;
						this.context.firstCoverInitializedNameError = null;
						var result = parseFunction.call(this);
						this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
						this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
						this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
						return result;
					};
					Parser.prototype.consumeSemicolon = function () {
						if (this.match(';')) {
							this.nextToken();
						} else if (!this.hasLineTerminator) {
							if (this.lookahead.type !== token_1.Token.EOF && !this.match('}')) {
								this.throwUnexpectedToken(this.lookahead);
							}
							this.lastMarker.index = this.startMarker.index;
							this.lastMarker.lineNumber = this.startMarker.lineNumber;
							this.lastMarker.lineStart = this.startMarker.lineStart;
						}
					};
					// ECMA-262 12.2 Primary Expressions
					Parser.prototype.parsePrimaryExpression = function () {
						var node = this.createNode();
						var expr;
						var value, token, raw;
						switch (this.lookahead.type) {
							case token_1.Token.Identifier:
								if (this.sourceType === 'module' && this.lookahead.value === 'await') {
									this.tolerateUnexpectedToken(this.lookahead);
								}
								expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
								break;
							case token_1.Token.NumericLiteral:
							case token_1.Token.StringLiteral:
								if (this.context.strict && this.lookahead.octal) {
									this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
								}
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								token = this.nextToken();
								raw = this.getTokenRaw(token);
								expr = this.finalize(node, new Node.Literal(token.value, raw));
								break;
							case token_1.Token.BooleanLiteral:
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								token = this.nextToken();
								token.value = token.value === 'true';
								raw = this.getTokenRaw(token);
								expr = this.finalize(node, new Node.Literal(token.value, raw));
								break;
							case token_1.Token.NullLiteral:
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								token = this.nextToken();
								token.value = null;
								raw = this.getTokenRaw(token);
								expr = this.finalize(node, new Node.Literal(token.value, raw));
								break;
							case token_1.Token.Template:
								expr = this.parseTemplateLiteral();
								break;
							case token_1.Token.Punctuator:
								value = this.lookahead.value;
								switch (value) {
									case '(':
										this.context.isBindingElement = false;
										expr = this.inheritCoverGrammar(this.parseGroupExpression);
										break;
									case '[':
										expr = this.inheritCoverGrammar(this.parseArrayInitializer);
										break;
									case '{':
										expr = this.inheritCoverGrammar(this.parseObjectInitializer);
										break;
									case '/':
									case '/=':
										this.context.isAssignmentTarget = false;
										this.context.isBindingElement = false;
										this.scanner.index = this.startMarker.index;
										token = this.nextRegexToken();
										raw = this.getTokenRaw(token);
										expr = this.finalize(node, new Node.RegexLiteral(token.value, raw, token.regex));
										break;
									default:
										this.throwUnexpectedToken(this.nextToken());
								}
								break;
							case token_1.Token.Keyword:
								if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
									expr = this.parseIdentifierName();
								} else if (!this.context.strict && this.matchKeyword('let')) {
									expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
								} else {
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									if (this.matchKeyword('function')) {
										expr = this.parseFunctionExpression();
									} else if (this.matchKeyword('this')) {
										this.nextToken();
										expr = this.finalize(node, new Node.ThisExpression());
									} else if (this.matchKeyword('class')) {
										expr = this.parseClassExpression();
									} else {
										this.throwUnexpectedToken(this.nextToken());
									}
								}
								break;
							default:
								this.throwUnexpectedToken(this.nextToken());
						}
						return expr;
					};
					// ECMA-262 12.2.5 Array Initializer
					Parser.prototype.parseSpreadElement = function () {
						var node = this.createNode();
						this.expect('...');
						var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
						return this.finalize(node, new Node.SpreadElement(arg));
					};
					Parser.prototype.parseArrayInitializer = function () {
						var node = this.createNode();
						var elements = [];
						this.expect('[');
						while (!this.match(']')) {
							if (this.match(',')) {
								this.nextToken();
								elements.push(null);
							} else if (this.match('...')) {
								var element = this.parseSpreadElement();
								if (!this.match(']')) {
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									this.expect(',');
								}
								elements.push(element);
							} else {
								elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
								if (!this.match(']')) {
									this.expect(',');
								}
							}
						}
						this.expect(']');
						return this.finalize(node, new Node.ArrayExpression(elements));
					};
					// ECMA-262 12.2.6 Object Initializer
					Parser.prototype.parsePropertyMethod = function (params) {
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
						var previousStrict = this.context.strict;
						var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
						if (this.context.strict && params.firstRestricted) {
							this.tolerateUnexpectedToken(params.firstRestricted, params.message);
						}
						if (this.context.strict && params.stricted) {
							this.tolerateUnexpectedToken(params.stricted, params.message);
						}
						this.context.strict = previousStrict;
						return body;
					};
					Parser.prototype.parsePropertyMethodFunction = function () {
						var isGenerator = false;
						var node = this.createNode();
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = false;
						var params = this.parseFormalParameters();
						var method = this.parsePropertyMethod(params);
						this.context.allowYield = previousAllowYield;
						return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
					};
					Parser.prototype.parseObjectPropertyKey = function () {
						var node = this.createNode();
						var token = this.nextToken();
						var key = null;
						switch (token.type) {
							case token_1.Token.StringLiteral:
							case token_1.Token.NumericLiteral:
								if (this.context.strict && token.octal) {
									this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
								}
								var raw = this.getTokenRaw(token);
								key = this.finalize(node, new Node.Literal(token.value, raw));
								break;
							case token_1.Token.Identifier:
							case token_1.Token.BooleanLiteral:
							case token_1.Token.NullLiteral:
							case token_1.Token.Keyword:
								key = this.finalize(node, new Node.Identifier(token.value));
								break;
							case token_1.Token.Punctuator:
								if (token.value === '[') {
									key = this.isolateCoverGrammar(this.parseAssignmentExpression);
									this.expect(']');
								} else {
									this.throwUnexpectedToken(token);
								}
								break;
							default:
								this.throwUnexpectedToken(token);
						}
						return key;
					};
					Parser.prototype.isPropertyKey = function (key, value) {
						return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
					};
					Parser.prototype.parseObjectProperty = function (hasProto) {
						var node = this.createNode();
						var token = this.lookahead;
						var kind;
						var key;
						var value;
						var computed = false;
						var method = false;
						var shorthand = false;
						if (token.type === token_1.Token.Identifier) {
							this.nextToken();
							key = this.finalize(node, new Node.Identifier(token.value));
						} else if (this.match('*')) {
							this.nextToken();
						} else {
							computed = this.match('[');
							key = this.parseObjectPropertyKey();
						}
						var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
						if (token.type === token_1.Token.Identifier && token.value === 'get' && lookaheadPropertyKey) {
							kind = 'get';
							computed = this.match('[');
							key = this.parseObjectPropertyKey();
							this.context.allowYield = false;
							value = this.parseGetterMethod();
						} else if (token.type === token_1.Token.Identifier && token.value === 'set' && lookaheadPropertyKey) {
							kind = 'set';
							computed = this.match('[');
							key = this.parseObjectPropertyKey();
							value = this.parseSetterMethod();
						} else if (token.type === token_1.Token.Punctuator && token.value === '*' && lookaheadPropertyKey) {
							kind = 'init';
							computed = this.match('[');
							key = this.parseObjectPropertyKey();
							value = this.parseGeneratorMethod();
							method = true;
						} else {
							if (!key) {
								this.throwUnexpectedToken(this.lookahead);
							}
							kind = 'init';
							if (this.match(':')) {
								if (!computed && this.isPropertyKey(key, '__proto__')) {
									if (hasProto.value) {
										this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
									}
									hasProto.value = true;
								}
								this.nextToken();
								value = this.inheritCoverGrammar(this.parseAssignmentExpression);
							} else if (this.match('(')) {
								value = this.parsePropertyMethodFunction();
								method = true;
							} else if (token.type === token_1.Token.Identifier) {
								var id = this.finalize(node, new Node.Identifier(token.value));
								if (this.match('=')) {
									this.context.firstCoverInitializedNameError = this.lookahead;
									this.nextToken();
									shorthand = true;
									var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
									value = this.finalize(node, new Node.AssignmentPattern(id, init));
								} else {
									shorthand = true;
									value = id;
								}
							} else {
								this.throwUnexpectedToken(this.nextToken());
							}
						}
						return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
					};
					Parser.prototype.parseObjectInitializer = function () {
						var node = this.createNode();
						this.expect('{');
						var properties = [];
						var hasProto = { value: false };
						while (!this.match('}')) {
							properties.push(this.parseObjectProperty(hasProto));
							if (!this.match('}')) {
								this.expectCommaSeparator();
							}
						}
						this.expect('}');
						return this.finalize(node, new Node.ObjectExpression(properties));
					};
					// ECMA-262 12.2.9 Template Literals
					Parser.prototype.parseTemplateHead = function () {
						assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
						var node = this.createNode();
						var token = this.nextToken();
						var value = {
							raw: token.value.raw,
							cooked: token.value.cooked
						};
						return this.finalize(node, new Node.TemplateElement(value, token.tail));
					};
					Parser.prototype.parseTemplateElement = function () {
						if (this.lookahead.type !== token_1.Token.Template) {
							this.throwUnexpectedToken();
						}
						var node = this.createNode();
						var token = this.nextToken();
						var value = {
							raw: token.value.raw,
							cooked: token.value.cooked
						};
						return this.finalize(node, new Node.TemplateElement(value, token.tail));
					};
					Parser.prototype.parseTemplateLiteral = function () {
						var node = this.createNode();
						var expressions = [];
						var quasis = [];
						var quasi = this.parseTemplateHead();
						quasis.push(quasi);
						while (!quasi.tail) {
							expressions.push(this.parseExpression());
							quasi = this.parseTemplateElement();
							quasis.push(quasi);
						}
						return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
					};
					// ECMA-262 12.2.10 The Grouping Operator
					Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
						switch (expr.type) {
							case syntax_1.Syntax.Identifier:
							case syntax_1.Syntax.MemberExpression:
							case syntax_1.Syntax.RestElement:
							case syntax_1.Syntax.AssignmentPattern:
								break;
							case syntax_1.Syntax.SpreadElement:
								expr.type = syntax_1.Syntax.RestElement;
								this.reinterpretExpressionAsPattern(expr.argument);
								break;
							case syntax_1.Syntax.ArrayExpression:
								expr.type = syntax_1.Syntax.ArrayPattern;
								for (var i = 0; i < expr.elements.length; i++) {
									if (expr.elements[i] !== null) {
										this.reinterpretExpressionAsPattern(expr.elements[i]);
									}
								}
								break;
							case syntax_1.Syntax.ObjectExpression:
								expr.type = syntax_1.Syntax.ObjectPattern;
								for (var i = 0; i < expr.properties.length; i++) {
									this.reinterpretExpressionAsPattern(expr.properties[i].value);
								}
								break;
							case syntax_1.Syntax.AssignmentExpression:
								expr.type = syntax_1.Syntax.AssignmentPattern;
								delete expr.operator;
								this.reinterpretExpressionAsPattern(expr.left);
								break;
							default:
								// Allow other node type for tolerant parsing.
								break;
						}
					};
					Parser.prototype.parseGroupExpression = function () {
						var expr;
						this.expect('(');
						if (this.match(')')) {
							this.nextToken();
							if (!this.match('=>')) {
								this.expect('=>');
							}
							expr = {
								type: ArrowParameterPlaceHolder,
								params: []
							};
						} else {
							var startToken = this.lookahead;
							var params = [];
							if (this.match('...')) {
								expr = this.parseRestElement(params);
								this.expect(')');
								if (!this.match('=>')) {
									this.expect('=>');
								}
								expr = {
									type: ArrowParameterPlaceHolder,
									params: [expr]
								};
							} else {
								var arrow = false;
								this.context.isBindingElement = true;
								expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
								if (this.match(',')) {
									var expressions = [];
									this.context.isAssignmentTarget = false;
									expressions.push(expr);
									while (this.startMarker.index < this.scanner.length) {
										if (!this.match(',')) {
											break;
										}
										this.nextToken();
										if (this.match('...')) {
											if (!this.context.isBindingElement) {
												this.throwUnexpectedToken(this.lookahead);
											}
											expressions.push(this.parseRestElement(params));
											this.expect(')');
											if (!this.match('=>')) {
												this.expect('=>');
											}
											this.context.isBindingElement = false;
											for (var i = 0; i < expressions.length; i++) {
												this.reinterpretExpressionAsPattern(expressions[i]);
											}
											arrow = true;
											expr = {
												type: ArrowParameterPlaceHolder,
												params: expressions
											};
										} else {
											expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
										}
										if (arrow) {
											break;
										}
									}
									if (!arrow) {
										expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
									}
								}
								if (!arrow) {
									this.expect(')');
									if (this.match('=>')) {
										if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
											arrow = true;
											expr = {
												type: ArrowParameterPlaceHolder,
												params: [expr]
											};
										}
										if (!arrow) {
											if (!this.context.isBindingElement) {
												this.throwUnexpectedToken(this.lookahead);
											}
											if (expr.type === syntax_1.Syntax.SequenceExpression) {
												for (var i = 0; i < expr.expressions.length; i++) {
													this.reinterpretExpressionAsPattern(expr.expressions[i]);
												}
											} else {
												this.reinterpretExpressionAsPattern(expr);
											}
											var params_1 = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
											expr = {
												type: ArrowParameterPlaceHolder,
												params: params_1
											};
										}
									}
									this.context.isBindingElement = false;
								}
							}
						}
						return expr;
					};
					// ECMA-262 12.3 Left-Hand-Side Expressions
					Parser.prototype.parseArguments = function () {
						this.expect('(');
						var args = [];
						if (!this.match(')')) {
							while (true) {
								var expr = this.match('...') ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
								args.push(expr);
								if (this.match(')')) {
									break;
								}
								this.expectCommaSeparator();
							}
						}
						this.expect(')');
						return args;
					};
					Parser.prototype.isIdentifierName = function (token) {
						return token.type === token_1.Token.Identifier || token.type === token_1.Token.Keyword || token.type === token_1.Token.BooleanLiteral || token.type === token_1.Token.NullLiteral;
					};
					Parser.prototype.parseIdentifierName = function () {
						var node = this.createNode();
						var token = this.nextToken();
						if (!this.isIdentifierName(token)) {
							this.throwUnexpectedToken(token);
						}
						return this.finalize(node, new Node.Identifier(token.value));
					};
					Parser.prototype.parseNewExpression = function () {
						var node = this.createNode();
						var id = this.parseIdentifierName();
						assert_1.assert(id.name === 'new', 'New expression must start with `new`');
						var expr;
						if (this.match('.')) {
							this.nextToken();
							if (this.lookahead.type === token_1.Token.Identifier && this.context.inFunctionBody && this.lookahead.value === 'target') {
								var property = this.parseIdentifierName();
								expr = new Node.MetaProperty(id, property);
							} else {
								this.throwUnexpectedToken(this.lookahead);
							}
						} else {
							var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
							var args = this.match('(') ? this.parseArguments() : [];
							expr = new Node.NewExpression(callee, args);
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
						}
						return this.finalize(node, expr);
					};
					Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
						var startToken = this.lookahead;
						var previousAllowIn = this.context.allowIn;
						this.context.allowIn = true;
						var expr;
						if (this.matchKeyword('super') && this.context.inFunctionBody) {
							expr = this.createNode();
							this.nextToken();
							expr = this.finalize(expr, new Node.Super());
							if (!this.match('(') && !this.match('.') && !this.match('[')) {
								this.throwUnexpectedToken(this.lookahead);
							}
						} else {
							expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
						}
						while (true) {
							if (this.match('.')) {
								this.context.isBindingElement = false;
								this.context.isAssignmentTarget = true;
								this.expect('.');
								var property = this.parseIdentifierName();
								expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
							} else if (this.match('(')) {
								this.context.isBindingElement = false;
								this.context.isAssignmentTarget = false;
								var args = this.parseArguments();
								expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
							} else if (this.match('[')) {
								this.context.isBindingElement = false;
								this.context.isAssignmentTarget = true;
								this.expect('[');
								var property = this.isolateCoverGrammar(this.parseExpression);
								this.expect(']');
								expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
							} else if (this.lookahead.type === token_1.Token.Template && this.lookahead.head) {
								var quasi = this.parseTemplateLiteral();
								expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
							} else {
								break;
							}
						}
						this.context.allowIn = previousAllowIn;
						return expr;
					};
					Parser.prototype.parseSuper = function () {
						var node = this.createNode();
						this.expectKeyword('super');
						if (!this.match('[') && !this.match('.')) {
							this.throwUnexpectedToken(this.lookahead);
						}
						return this.finalize(node, new Node.Super());
					};
					Parser.prototype.parseLeftHandSideExpression = function () {
						assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
						var node = this.startNode(this.lookahead);
						var expr = this.matchKeyword('super') && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
						while (true) {
							if (this.match('[')) {
								this.context.isBindingElement = false;
								this.context.isAssignmentTarget = true;
								this.expect('[');
								var property = this.isolateCoverGrammar(this.parseExpression);
								this.expect(']');
								expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
							} else if (this.match('.')) {
								this.context.isBindingElement = false;
								this.context.isAssignmentTarget = true;
								this.expect('.');
								var property = this.parseIdentifierName();
								expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
							} else if (this.lookahead.type === token_1.Token.Template && this.lookahead.head) {
								var quasi = this.parseTemplateLiteral();
								expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
							} else {
								break;
							}
						}
						return expr;
					};
					// ECMA-262 12.4 Update Expressions
					Parser.prototype.parseUpdateExpression = function () {
						var expr;
						var startToken = this.lookahead;
						if (this.match('++') || this.match('--')) {
							var node = this.startNode(startToken);
							var token = this.nextToken();
							expr = this.inheritCoverGrammar(this.parseUnaryExpression);
							if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
								this.tolerateError(messages_1.Messages.StrictLHSPrefix);
							}
							if (!this.context.isAssignmentTarget) {
								this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
							}
							var prefix = true;
							expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
						} else {
							expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
							if (!this.hasLineTerminator && this.lookahead.type === token_1.Token.Punctuator) {
								if (this.match('++') || this.match('--')) {
									if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
										this.tolerateError(messages_1.Messages.StrictLHSPostfix);
									}
									if (!this.context.isAssignmentTarget) {
										this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
									}
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									var operator = this.nextToken().value;
									var prefix = false;
									expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
								}
							}
						}
						return expr;
					};
					// ECMA-262 12.5 Unary Operators
					Parser.prototype.parseUnaryExpression = function () {
						var expr;
						if (this.match('+') || this.match('-') || this.match('~') || this.match('!') || this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
							var node = this.startNode(this.lookahead);
							var token = this.nextToken();
							expr = this.inheritCoverGrammar(this.parseUnaryExpression);
							expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
							if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
								this.tolerateError(messages_1.Messages.StrictDelete);
							}
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
						} else {
							expr = this.parseUpdateExpression();
						}
						return expr;
					};
					Parser.prototype.parseExponentiationExpression = function () {
						var startToken = this.lookahead;
						var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
						if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
							this.nextToken();
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							var left = expr;
							var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
							expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
						}
						return expr;
					};
					// ECMA-262 12.6 Exponentiation Operators
					// ECMA-262 12.7 Multiplicative Operators
					// ECMA-262 12.8 Additive Operators
					// ECMA-262 12.9 Bitwise Shift Operators
					// ECMA-262 12.10 Relational Operators
					// ECMA-262 12.11 Equality Operators
					// ECMA-262 12.12 Binary Bitwise Operators
					// ECMA-262 12.13 Binary Logical Operators
					Parser.prototype.binaryPrecedence = function (token) {
						var op = token.value;
						var precedence;
						if (token.type === token_1.Token.Punctuator) {
							precedence = this.operatorPrecedence[op] || 0;
						} else if (token.type === token_1.Token.Keyword) {
							precedence = op === 'instanceof' || this.context.allowIn && op === 'in' ? 7 : 0;
						} else {
							precedence = 0;
						}
						return precedence;
					};
					Parser.prototype.parseBinaryExpression = function () {
						var startToken = this.lookahead;
						var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
						var token = this.lookahead;
						var prec = this.binaryPrecedence(token);
						if (prec > 0) {
							this.nextToken();
							token.prec = prec;
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							var markers = [startToken, this.lookahead];
							var left = expr;
							var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
							var stack = [left, token, right];
							while (true) {
								prec = this.binaryPrecedence(this.lookahead);
								if (prec <= 0) {
									break;
								}
								// Reduce: make a binary expression from the three topmost entries.
								while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
									right = stack.pop();
									var operator = stack.pop().value;
									left = stack.pop();
									markers.pop();
									var node = this.startNode(markers[markers.length - 1]);
									stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
								}
								// Shift.
								token = this.nextToken();
								token.prec = prec;
								stack.push(token);
								markers.push(this.lookahead);
								stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
							}
							// Final reduce to clean-up the stack.
							var i = stack.length - 1;
							expr = stack[i];
							markers.pop();
							while (i > 1) {
								var node = this.startNode(markers.pop());
								expr = this.finalize(node, new Node.BinaryExpression(stack[i - 1].value, stack[i - 2], expr));
								i -= 2;
							}
						}
						return expr;
					};
					// ECMA-262 12.14 Conditional Operator
					Parser.prototype.parseConditionalExpression = function () {
						var startToken = this.lookahead;
						var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
						if (this.match('?')) {
							this.nextToken();
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = true;
							var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
							this.context.allowIn = previousAllowIn;
							this.expect(':');
							var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
							expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
						}
						return expr;
					};
					// ECMA-262 12.15 Assignment Operators
					Parser.prototype.checkPatternParam = function (options, param) {
						switch (param.type) {
							case syntax_1.Syntax.Identifier:
								this.validateParam(options, param, param.name);
								break;
							case syntax_1.Syntax.RestElement:
								this.checkPatternParam(options, param.argument);
								break;
							case syntax_1.Syntax.AssignmentPattern:
								this.checkPatternParam(options, param.left);
								break;
							case syntax_1.Syntax.ArrayPattern:
								for (var i = 0; i < param.elements.length; i++) {
									if (param.elements[i] !== null) {
										this.checkPatternParam(options, param.elements[i]);
									}
								}
								break;
							case syntax_1.Syntax.YieldExpression:
								break;
							default:
								assert_1.assert(param.type === syntax_1.Syntax.ObjectPattern, 'Invalid type');
								for (var i = 0; i < param.properties.length; i++) {
									this.checkPatternParam(options, param.properties[i].value);
								}
								break;
						}
					};
					Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
						var params = [expr];
						var options;
						switch (expr.type) {
							case syntax_1.Syntax.Identifier:
								break;
							case ArrowParameterPlaceHolder:
								params = expr.params;
								break;
							default:
								return null;
						}
						options = {
							paramSet: {}
						};
						for (var i = 0; i < params.length; ++i) {
							var param = params[i];
							if (param.type === syntax_1.Syntax.AssignmentPattern) {
								if (param.right.type === syntax_1.Syntax.YieldExpression) {
									if (param.right.argument) {
										this.throwUnexpectedToken(this.lookahead);
									}
									param.right.type = syntax_1.Syntax.Identifier;
									param.right.name = 'yield';
									delete param.right.argument;
									delete param.right.delegate;
								}
							}
							this.checkPatternParam(options, param);
							params[i] = param;
						}
						if (this.context.strict || !this.context.allowYield) {
							for (var i = 0; i < params.length; ++i) {
								var param = params[i];
								if (param.type === syntax_1.Syntax.YieldExpression) {
									this.throwUnexpectedToken(this.lookahead);
								}
							}
						}
						if (options.message === messages_1.Messages.StrictParamDupe) {
							var token = this.context.strict ? options.stricted : options.firstRestricted;
							this.throwUnexpectedToken(token, options.message);
						}
						return {
							params: params,
							stricted: options.stricted,
							firstRestricted: options.firstRestricted,
							message: options.message
						};
					};
					Parser.prototype.parseAssignmentExpression = function () {
						var expr;
						if (!this.context.allowYield && this.matchKeyword('yield')) {
							expr = this.parseYieldExpression();
						} else {
							var startToken = this.lookahead;
							var token = startToken;
							expr = this.parseConditionalExpression();
							if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
								// ECMA-262 14.2 Arrow Function Definitions
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								var list = this.reinterpretAsCoverFormalsList(expr);
								if (list) {
									if (this.hasLineTerminator) {
										this.tolerateUnexpectedToken(this.lookahead);
									}
									this.context.firstCoverInitializedNameError = null;
									var previousStrict = this.context.strict;
									var previousAllowYield = this.context.allowYield;
									this.context.allowYield = true;
									var node = this.startNode(startToken);
									this.expect('=>');
									var body = this.match('{') ? this.parseFunctionSourceElements() : this.isolateCoverGrammar(this.parseAssignmentExpression);
									var expression = body.type !== syntax_1.Syntax.BlockStatement;
									if (this.context.strict && list.firstRestricted) {
										this.throwUnexpectedToken(list.firstRestricted, list.message);
									}
									if (this.context.strict && list.stricted) {
										this.tolerateUnexpectedToken(list.stricted, list.message);
									}
									expr = this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
									this.context.strict = previousStrict;
									this.context.allowYield = previousAllowYield;
								}
							} else {
								if (this.matchAssign()) {
									if (!this.context.isAssignmentTarget) {
										this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
									}
									if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
										var id = expr;
										if (this.scanner.isRestrictedWord(id.name)) {
											this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
										}
										if (this.scanner.isStrictModeReservedWord(id.name)) {
											this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
										}
									}
									if (!this.match('=')) {
										this.context.isAssignmentTarget = false;
										this.context.isBindingElement = false;
									} else {
										this.reinterpretExpressionAsPattern(expr);
									}
									token = this.nextToken();
									var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
									expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(token.value, expr, right));
									this.context.firstCoverInitializedNameError = null;
								}
							}
						}
						return expr;
					};
					// ECMA-262 12.16 Comma Operator
					Parser.prototype.parseExpression = function () {
						var startToken = this.lookahead;
						var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
						if (this.match(',')) {
							var expressions = [];
							expressions.push(expr);
							while (this.startMarker.index < this.scanner.length) {
								if (!this.match(',')) {
									break;
								}
								this.nextToken();
								expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
							}
							expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
						}
						return expr;
					};
					// ECMA-262 13.2 Block
					Parser.prototype.parseStatementListItem = function () {
						var statement = null;
						this.context.isAssignmentTarget = true;
						this.context.isBindingElement = true;
						if (this.lookahead.type === token_1.Token.Keyword) {
							switch (this.lookahead.value) {
								case 'export':
									if (this.sourceType !== 'module') {
										this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
									}
									statement = this.parseExportDeclaration();
									break;
								case 'import':
									if (this.sourceType !== 'module') {
										this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
									}
									statement = this.parseImportDeclaration();
									break;
								case 'const':
									statement = this.parseLexicalDeclaration({ inFor: false });
									break;
								case 'function':
									statement = this.parseFunctionDeclaration();
									break;
								case 'class':
									statement = this.parseClassDeclaration();
									break;
								case 'let':
									statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
									break;
								default:
									statement = this.parseStatement();
									break;
							}
						} else {
							statement = this.parseStatement();
						}
						return statement;
					};
					Parser.prototype.parseBlock = function () {
						var node = this.createNode();
						this.expect('{');
						var block = [];
						while (true) {
							if (this.match('}')) {
								break;
							}
							block.push(this.parseStatementListItem());
						}
						this.expect('}');
						return this.finalize(node, new Node.BlockStatement(block));
					};
					// ECMA-262 13.3.1 Let and Const Declarations
					Parser.prototype.parseLexicalBinding = function (kind, options) {
						var node = this.createNode();
						var params = [];
						var id = this.parsePattern(params, kind);
						// ECMA-262 12.2.1
						if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
							if (this.scanner.isRestrictedWord(id.name)) {
								this.tolerateError(messages_1.Messages.StrictVarName);
							}
						}
						var init = null;
						if (kind === 'const') {
							if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
								this.expect('=');
								init = this.isolateCoverGrammar(this.parseAssignmentExpression);
							}
						} else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match('=')) {
							this.expect('=');
							init = this.isolateCoverGrammar(this.parseAssignmentExpression);
						}
						return this.finalize(node, new Node.VariableDeclarator(id, init));
					};
					Parser.prototype.parseBindingList = function (kind, options) {
						var list = [this.parseLexicalBinding(kind, options)];
						while (this.match(',')) {
							this.nextToken();
							list.push(this.parseLexicalBinding(kind, options));
						}
						return list;
					};
					Parser.prototype.isLexicalDeclaration = function () {
						var previousIndex = this.scanner.index;
						var previousLineNumber = this.scanner.lineNumber;
						var previousLineStart = this.scanner.lineStart;
						this.collectComments();
						var next = this.scanner.lex();
						this.scanner.index = previousIndex;
						this.scanner.lineNumber = previousLineNumber;
						this.scanner.lineStart = previousLineStart;
						return next.type === token_1.Token.Identifier || next.type === token_1.Token.Punctuator && next.value === '[' || next.type === token_1.Token.Punctuator && next.value === '{' || next.type === token_1.Token.Keyword && next.value === 'let' || next.type === token_1.Token.Keyword && next.value === 'yield';
					};
					Parser.prototype.parseLexicalDeclaration = function (options) {
						var node = this.createNode();
						var kind = this.nextToken().value;
						assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
						var declarations = this.parseBindingList(kind, options);
						this.consumeSemicolon();
						return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
					};
					// ECMA-262 13.3.3 Destructuring Binding Patterns
					Parser.prototype.parseBindingRestElement = function (params, kind) {
						var node = this.createNode();
						this.expect('...');
						params.push(this.lookahead);
						var arg = this.parseVariableIdentifier(kind);
						return this.finalize(node, new Node.RestElement(arg));
					};
					Parser.prototype.parseArrayPattern = function (params, kind) {
						var node = this.createNode();
						this.expect('[');
						var elements = [];
						while (!this.match(']')) {
							if (this.match(',')) {
								this.nextToken();
								elements.push(null);
							} else {
								if (this.match('...')) {
									elements.push(this.parseBindingRestElement(params, kind));
									break;
								} else {
									elements.push(this.parsePatternWithDefault(params, kind));
								}
								if (!this.match(']')) {
									this.expect(',');
								}
							}
						}
						this.expect(']');
						return this.finalize(node, new Node.ArrayPattern(elements));
					};
					Parser.prototype.parsePropertyPattern = function (params, kind) {
						var node = this.createNode();
						var computed = false;
						var shorthand = false;
						var method = false;
						var key;
						var value;
						if (this.lookahead.type === token_1.Token.Identifier) {
							var keyToken = this.lookahead;
							key = this.parseVariableIdentifier();
							var init = this.finalize(node, new Node.Identifier(keyToken.value));
							if (this.match('=')) {
								params.push(keyToken);
								shorthand = true;
								this.nextToken();
								var expr = this.parseAssignmentExpression();
								value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
							} else if (!this.match(':')) {
								params.push(keyToken);
								shorthand = true;
								value = init;
							} else {
								this.expect(':');
								value = this.parsePatternWithDefault(params, kind);
							}
						} else {
							computed = this.match('[');
							key = this.parseObjectPropertyKey();
							this.expect(':');
							value = this.parsePatternWithDefault(params, kind);
						}
						return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
					};
					Parser.prototype.parseObjectPattern = function (params, kind) {
						var node = this.createNode();
						var properties = [];
						this.expect('{');
						while (!this.match('}')) {
							properties.push(this.parsePropertyPattern(params, kind));
							if (!this.match('}')) {
								this.expect(',');
							}
						}
						this.expect('}');
						return this.finalize(node, new Node.ObjectPattern(properties));
					};
					Parser.prototype.parsePattern = function (params, kind) {
						var pattern;
						if (this.match('[')) {
							pattern = this.parseArrayPattern(params, kind);
						} else if (this.match('{')) {
							pattern = this.parseObjectPattern(params, kind);
						} else {
							if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
								this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.UnexpectedToken);
							}
							params.push(this.lookahead);
							pattern = this.parseVariableIdentifier(kind);
						}
						return pattern;
					};
					Parser.prototype.parsePatternWithDefault = function (params, kind) {
						var startToken = this.lookahead;
						var pattern = this.parsePattern(params, kind);
						if (this.match('=')) {
							this.nextToken();
							var previousAllowYield = this.context.allowYield;
							this.context.allowYield = true;
							var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
							this.context.allowYield = previousAllowYield;
							pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
						}
						return pattern;
					};
					// ECMA-262 13.3.2 Variable Statement
					Parser.prototype.parseVariableIdentifier = function (kind) {
						var node = this.createNode();
						var token = this.nextToken();
						if (token.type === token_1.Token.Keyword && token.value === 'yield') {
							if (this.context.strict) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
							}
							if (!this.context.allowYield) {
								this.throwUnexpectedToken(token);
							}
						} else if (token.type !== token_1.Token.Identifier) {
							if (this.context.strict && token.type === token_1.Token.Keyword && this.scanner.isStrictModeReservedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
							} else {
								if (this.context.strict || token.value !== 'let' || kind !== 'var') {
									this.throwUnexpectedToken(token);
								}
							}
						} else if (this.sourceType === 'module' && token.type === token_1.Token.Identifier && token.value === 'await') {
							this.tolerateUnexpectedToken(token);
						}
						return this.finalize(node, new Node.Identifier(token.value));
					};
					Parser.prototype.parseVariableDeclaration = function (options) {
						var node = this.createNode();
						var params = [];
						var id = this.parsePattern(params, 'var');
						// ECMA-262 12.2.1
						if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
							if (this.scanner.isRestrictedWord(id.name)) {
								this.tolerateError(messages_1.Messages.StrictVarName);
							}
						}
						var init = null;
						if (this.match('=')) {
							this.nextToken();
							init = this.isolateCoverGrammar(this.parseAssignmentExpression);
						} else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
							this.expect('=');
						}
						return this.finalize(node, new Node.VariableDeclarator(id, init));
					};
					Parser.prototype.parseVariableDeclarationList = function (options) {
						var opt = { inFor: options.inFor };
						var list = [];
						list.push(this.parseVariableDeclaration(opt));
						while (this.match(',')) {
							this.nextToken();
							list.push(this.parseVariableDeclaration(opt));
						}
						return list;
					};
					Parser.prototype.parseVariableStatement = function () {
						var node = this.createNode();
						this.expectKeyword('var');
						var declarations = this.parseVariableDeclarationList({ inFor: false });
						this.consumeSemicolon();
						return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
					};
					// ECMA-262 13.4 Empty Statement
					Parser.prototype.parseEmptyStatement = function () {
						var node = this.createNode();
						this.expect(';');
						return this.finalize(node, new Node.EmptyStatement());
					};
					// ECMA-262 13.5 Expression Statement
					Parser.prototype.parseExpressionStatement = function () {
						var node = this.createNode();
						var expr = this.parseExpression();
						this.consumeSemicolon();
						return this.finalize(node, new Node.ExpressionStatement(expr));
					};
					// ECMA-262 13.6 If statement
					Parser.prototype.parseIfStatement = function () {
						var node = this.createNode();
						var consequent;
						var alternate = null;
						this.expectKeyword('if');
						this.expect('(');
						var test = this.parseExpression();
						if (!this.match(')') && this.config.tolerant) {
							this.tolerateUnexpectedToken(this.nextToken());
							consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
						} else {
							this.expect(')');
							consequent = this.parseStatement();
							if (this.matchKeyword('else')) {
								this.nextToken();
								alternate = this.parseStatement();
							}
						}
						return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
					};
					// ECMA-262 13.7.2 The do-while Statement
					Parser.prototype.parseDoWhileStatement = function () {
						var node = this.createNode();
						this.expectKeyword('do');
						var previousInIteration = this.context.inIteration;
						this.context.inIteration = true;
						var body = this.parseStatement();
						this.context.inIteration = previousInIteration;
						this.expectKeyword('while');
						this.expect('(');
						var test = this.parseExpression();
						this.expect(')');
						if (this.match(';')) {
							this.nextToken();
						}
						return this.finalize(node, new Node.DoWhileStatement(body, test));
					};
					// ECMA-262 13.7.3 The while Statement
					Parser.prototype.parseWhileStatement = function () {
						var node = this.createNode();
						var body;
						this.expectKeyword('while');
						this.expect('(');
						var test = this.parseExpression();
						if (!this.match(')') && this.config.tolerant) {
							this.tolerateUnexpectedToken(this.nextToken());
							body = this.finalize(this.createNode(), new Node.EmptyStatement());
						} else {
							this.expect(')');
							var previousInIteration = this.context.inIteration;
							this.context.inIteration = true;
							body = this.parseStatement();
							this.context.inIteration = previousInIteration;
						}
						return this.finalize(node, new Node.WhileStatement(test, body));
					};
					// ECMA-262 13.7.4 The for Statement
					// ECMA-262 13.7.5 The for-in and for-of Statements
					Parser.prototype.parseForStatement = function () {
						var init = null;
						var test = null;
						var update = null;
						var forIn = true;
						var left, right;
						var node = this.createNode();
						this.expectKeyword('for');
						this.expect('(');
						if (this.match(';')) {
							this.nextToken();
						} else {
							if (this.matchKeyword('var')) {
								init = this.createNode();
								this.nextToken();
								var previousAllowIn = this.context.allowIn;
								this.context.allowIn = false;
								var declarations = this.parseVariableDeclarationList({ inFor: true });
								this.context.allowIn = previousAllowIn;
								if (declarations.length === 1 && this.matchKeyword('in')) {
									var decl = declarations[0];
									if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
										this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
									}
									init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
									this.nextToken();
									left = init;
									right = this.parseExpression();
									init = null;
								} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
									this.nextToken();
									left = init;
									right = this.parseAssignmentExpression();
									init = null;
									forIn = false;
								} else {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
									this.expect(';');
								}
							} else if (this.matchKeyword('const') || this.matchKeyword('let')) {
								init = this.createNode();
								var kind = this.nextToken().value;
								if (!this.context.strict && this.lookahead.value === 'in') {
									init = this.finalize(init, new Node.Identifier(kind));
									this.nextToken();
									left = init;
									right = this.parseExpression();
									init = null;
								} else {
									var previousAllowIn = this.context.allowIn;
									this.context.allowIn = false;
									var declarations = this.parseBindingList(kind, { inFor: true });
									this.context.allowIn = previousAllowIn;
									if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
										init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
										this.nextToken();
										left = init;
										right = this.parseExpression();
										init = null;
									} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
										init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
										this.nextToken();
										left = init;
										right = this.parseAssignmentExpression();
										init = null;
										forIn = false;
									} else {
										this.consumeSemicolon();
										init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
									}
								}
							} else {
								var initStartToken = this.lookahead;
								var previousAllowIn = this.context.allowIn;
								this.context.allowIn = false;
								init = this.inheritCoverGrammar(this.parseAssignmentExpression);
								this.context.allowIn = previousAllowIn;
								if (this.matchKeyword('in')) {
									if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
										this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
									}
									this.nextToken();
									this.reinterpretExpressionAsPattern(init);
									left = init;
									right = this.parseExpression();
									init = null;
								} else if (this.matchContextualKeyword('of')) {
									if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
										this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
									}
									this.nextToken();
									this.reinterpretExpressionAsPattern(init);
									left = init;
									right = this.parseAssignmentExpression();
									init = null;
									forIn = false;
								} else {
									if (this.match(',')) {
										var initSeq = [init];
										while (this.match(',')) {
											this.nextToken();
											initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
										}
										init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
									}
									this.expect(';');
								}
							}
						}
						if (typeof left === 'undefined') {
							if (!this.match(';')) {
								test = this.parseExpression();
							}
							this.expect(';');
							if (!this.match(')')) {
								update = this.parseExpression();
							}
						}
						var body;
						if (!this.match(')') && this.config.tolerant) {
							this.tolerateUnexpectedToken(this.nextToken());
							body = this.finalize(this.createNode(), new Node.EmptyStatement());
						} else {
							this.expect(')');
							var previousInIteration = this.context.inIteration;
							this.context.inIteration = true;
							body = this.isolateCoverGrammar(this.parseStatement);
							this.context.inIteration = previousInIteration;
						}
						return typeof left === 'undefined' ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
					};
					// ECMA-262 13.8 The continue statement
					Parser.prototype.parseContinueStatement = function () {
						var node = this.createNode();
						this.expectKeyword('continue');
						var label = null;
						if (this.lookahead.type === token_1.Token.Identifier && !this.hasLineTerminator) {
							label = this.parseVariableIdentifier();
							var key = '$' + label.name;
							if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
								this.throwError(messages_1.Messages.UnknownLabel, label.name);
							}
						}
						this.consumeSemicolon();
						if (label === null && !this.context.inIteration) {
							this.throwError(messages_1.Messages.IllegalContinue);
						}
						return this.finalize(node, new Node.ContinueStatement(label));
					};
					// ECMA-262 13.9 The break statement
					Parser.prototype.parseBreakStatement = function () {
						var node = this.createNode();
						this.expectKeyword('break');
						var label = null;
						if (this.lookahead.type === token_1.Token.Identifier && !this.hasLineTerminator) {
							label = this.parseVariableIdentifier();
							var key = '$' + label.name;
							if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
								this.throwError(messages_1.Messages.UnknownLabel, label.name);
							}
						}
						this.consumeSemicolon();
						if (label === null && !this.context.inIteration && !this.context.inSwitch) {
							this.throwError(messages_1.Messages.IllegalBreak);
						}
						return this.finalize(node, new Node.BreakStatement(label));
					};
					// ECMA-262 13.10 The return statement
					Parser.prototype.parseReturnStatement = function () {
						if (!this.context.inFunctionBody) {
							this.tolerateError(messages_1.Messages.IllegalReturn);
						}
						var node = this.createNode();
						this.expectKeyword('return');
						var hasArgument = !this.match(';') && !this.match('}') && !this.hasLineTerminator && this.lookahead.type !== token_1.Token.EOF;
						var argument = hasArgument ? this.parseExpression() : null;
						this.consumeSemicolon();
						return this.finalize(node, new Node.ReturnStatement(argument));
					};
					// ECMA-262 13.11 The with statement
					Parser.prototype.parseWithStatement = function () {
						if (this.context.strict) {
							this.tolerateError(messages_1.Messages.StrictModeWith);
						}
						var node = this.createNode();
						this.expectKeyword('with');
						this.expect('(');
						var object = this.parseExpression();
						this.expect(')');
						var body = this.parseStatement();
						return this.finalize(node, new Node.WithStatement(object, body));
					};
					// ECMA-262 13.12 The switch statement
					Parser.prototype.parseSwitchCase = function () {
						var node = this.createNode();
						var test;
						if (this.matchKeyword('default')) {
							this.nextToken();
							test = null;
						} else {
							this.expectKeyword('case');
							test = this.parseExpression();
						}
						this.expect(':');
						var consequent = [];
						while (true) {
							if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
								break;
							}
							consequent.push(this.parseStatementListItem());
						}
						return this.finalize(node, new Node.SwitchCase(test, consequent));
					};
					Parser.prototype.parseSwitchStatement = function () {
						var node = this.createNode();
						this.expectKeyword('switch');
						this.expect('(');
						var discriminant = this.parseExpression();
						this.expect(')');
						var previousInSwitch = this.context.inSwitch;
						this.context.inSwitch = true;
						var cases = [];
						var defaultFound = false;
						this.expect('{');
						while (true) {
							if (this.match('}')) {
								break;
							}
							var clause = this.parseSwitchCase();
							if (clause.test === null) {
								if (defaultFound) {
									this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
								}
								defaultFound = true;
							}
							cases.push(clause);
						}
						this.expect('}');
						this.context.inSwitch = previousInSwitch;
						return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
					};
					// ECMA-262 13.13 Labelled Statements
					Parser.prototype.parseLabelledStatement = function () {
						var node = this.createNode();
						var expr = this.parseExpression();
						var statement;
						if (expr.type === syntax_1.Syntax.Identifier && this.match(':')) {
							this.nextToken();
							var id = expr;
							var key = '$' + id.name;
							if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
								this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
							}
							this.context.labelSet[key] = true;
							var labeledBody = this.parseStatement();
							delete this.context.labelSet[key];
							statement = new Node.LabeledStatement(id, labeledBody);
						} else {
							this.consumeSemicolon();
							statement = new Node.ExpressionStatement(expr);
						}
						return this.finalize(node, statement);
					};
					// ECMA-262 13.14 The throw statement
					Parser.prototype.parseThrowStatement = function () {
						var node = this.createNode();
						this.expectKeyword('throw');
						if (this.hasLineTerminator) {
							this.throwError(messages_1.Messages.NewlineAfterThrow);
						}
						var argument = this.parseExpression();
						this.consumeSemicolon();
						return this.finalize(node, new Node.ThrowStatement(argument));
					};
					// ECMA-262 13.15 The try statement
					Parser.prototype.parseCatchClause = function () {
						var node = this.createNode();
						this.expectKeyword('catch');
						this.expect('(');
						if (this.match(')')) {
							this.throwUnexpectedToken(this.lookahead);
						}
						var params = [];
						var param = this.parsePattern(params);
						var paramMap = {};
						for (var i = 0; i < params.length; i++) {
							var key = '$' + params[i].value;
							if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
								this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
							}
							paramMap[key] = true;
						}
						if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
							if (this.scanner.isRestrictedWord(param.name)) {
								this.tolerateError(messages_1.Messages.StrictCatchVariable);
							}
						}
						this.expect(')');
						var body = this.parseBlock();
						return this.finalize(node, new Node.CatchClause(param, body));
					};
					Parser.prototype.parseFinallyClause = function () {
						this.expectKeyword('finally');
						return this.parseBlock();
					};
					Parser.prototype.parseTryStatement = function () {
						var node = this.createNode();
						this.expectKeyword('try');
						var block = this.parseBlock();
						var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
						var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
						if (!handler && !finalizer) {
							this.throwError(messages_1.Messages.NoCatchOrFinally);
						}
						return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
					};
					// ECMA-262 13.16 The debugger statement
					Parser.prototype.parseDebuggerStatement = function () {
						var node = this.createNode();
						this.expectKeyword('debugger');
						this.consumeSemicolon();
						return this.finalize(node, new Node.DebuggerStatement());
					};
					// ECMA-262 13 Statements
					Parser.prototype.parseStatement = function () {
						var statement = null;
						switch (this.lookahead.type) {
							case token_1.Token.BooleanLiteral:
							case token_1.Token.NullLiteral:
							case token_1.Token.NumericLiteral:
							case token_1.Token.StringLiteral:
							case token_1.Token.Template:
							case token_1.Token.RegularExpression:
								statement = this.parseExpressionStatement();
								break;
							case token_1.Token.Punctuator:
								var value = this.lookahead.value;
								if (value === '{') {
									statement = this.parseBlock();
								} else if (value === '(') {
									statement = this.parseExpressionStatement();
								} else if (value === ';') {
									statement = this.parseEmptyStatement();
								} else {
									statement = this.parseExpressionStatement();
								}
								break;
							case token_1.Token.Identifier:
								statement = this.parseLabelledStatement();
								break;
							case token_1.Token.Keyword:
								switch (this.lookahead.value) {
									case 'break':
										statement = this.parseBreakStatement();
										break;
									case 'continue':
										statement = this.parseContinueStatement();
										break;
									case 'debugger':
										statement = this.parseDebuggerStatement();
										break;
									case 'do':
										statement = this.parseDoWhileStatement();
										break;
									case 'for':
										statement = this.parseForStatement();
										break;
									case 'function':
										statement = this.parseFunctionDeclaration();
										break;
									case 'if':
										statement = this.parseIfStatement();
										break;
									case 'return':
										statement = this.parseReturnStatement();
										break;
									case 'switch':
										statement = this.parseSwitchStatement();
										break;
									case 'throw':
										statement = this.parseThrowStatement();
										break;
									case 'try':
										statement = this.parseTryStatement();
										break;
									case 'var':
										statement = this.parseVariableStatement();
										break;
									case 'while':
										statement = this.parseWhileStatement();
										break;
									case 'with':
										statement = this.parseWithStatement();
										break;
									default:
										statement = this.parseExpressionStatement();
										break;
								}
								break;
							default:
								this.throwUnexpectedToken(this.lookahead);
						}
						return statement;
					};
					// ECMA-262 14.1 Function Definition
					Parser.prototype.parseFunctionSourceElements = function () {
						var node = this.createNode();
						this.expect('{');
						var body = this.parseDirectivePrologues();
						var previousLabelSet = this.context.labelSet;
						var previousInIteration = this.context.inIteration;
						var previousInSwitch = this.context.inSwitch;
						var previousInFunctionBody = this.context.inFunctionBody;
						this.context.labelSet = {};
						this.context.inIteration = false;
						this.context.inSwitch = false;
						this.context.inFunctionBody = true;
						while (this.startMarker.index < this.scanner.length) {
							if (this.match('}')) {
								break;
							}
							body.push(this.parseStatementListItem());
						}
						this.expect('}');
						this.context.labelSet = previousLabelSet;
						this.context.inIteration = previousInIteration;
						this.context.inSwitch = previousInSwitch;
						this.context.inFunctionBody = previousInFunctionBody;
						return this.finalize(node, new Node.BlockStatement(body));
					};
					Parser.prototype.validateParam = function (options, param, name) {
						var key = '$' + name;
						if (this.context.strict) {
							if (this.scanner.isRestrictedWord(name)) {
								options.stricted = param;
								options.message = messages_1.Messages.StrictParamName;
							}
							if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
								options.stricted = param;
								options.message = messages_1.Messages.StrictParamDupe;
							}
						} else if (!options.firstRestricted) {
							if (this.scanner.isRestrictedWord(name)) {
								options.firstRestricted = param;
								options.message = messages_1.Messages.StrictParamName;
							} else if (this.scanner.isStrictModeReservedWord(name)) {
								options.firstRestricted = param;
								options.message = messages_1.Messages.StrictReservedWord;
							} else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
								options.stricted = param;
								options.message = messages_1.Messages.StrictParamDupe;
							}
						}
						/* istanbul ignore next */
						if (typeof Object.defineProperty === 'function') {
							Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
						} else {
							options.paramSet[key] = true;
						}
					};
					Parser.prototype.parseRestElement = function (params) {
						var node = this.createNode();
						this.nextToken();
						if (this.match('{')) {
							this.throwError(messages_1.Messages.ObjectPatternAsRestParameter);
						}
						params.push(this.lookahead);
						var param = this.parseVariableIdentifier();
						if (this.match('=')) {
							this.throwError(messages_1.Messages.DefaultRestParameter);
						}
						if (!this.match(')')) {
							this.throwError(messages_1.Messages.ParameterAfterRestParameter);
						}
						return this.finalize(node, new Node.RestElement(param));
					};
					Parser.prototype.parseFormalParameter = function (options) {
						var param;
						var params = [];
						var token = this.lookahead;
						if (token.value === '...') {
							param = this.parseRestElement(params);
							this.validateParam(options, param.argument, param.argument.name);
							options.params.push(param);
							return false;
						}
						param = this.parsePatternWithDefault(params);
						for (var i = 0; i < params.length; i++) {
							this.validateParam(options, params[i], params[i].value);
						}
						options.params.push(param);
						return !this.match(')');
					};
					Parser.prototype.parseFormalParameters = function (firstRestricted) {
						var options;
						options = {
							params: [],
							firstRestricted: firstRestricted
						};
						this.expect('(');
						if (!this.match(')')) {
							options.paramSet = {};
							while (this.startMarker.index < this.scanner.length) {
								if (!this.parseFormalParameter(options)) {
									break;
								}
								this.expect(',');
							}
						}
						this.expect(')');
						return {
							params: options.params,
							stricted: options.stricted,
							firstRestricted: options.firstRestricted,
							message: options.message
						};
					};
					Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
						var node = this.createNode();
						this.expectKeyword('function');
						var isGenerator = this.match('*');
						if (isGenerator) {
							this.nextToken();
						}
						var message;
						var id = null;
						var firstRestricted = null;
						if (!identifierIsOptional || !this.match('(')) {
							var token = this.lookahead;
							id = this.parseVariableIdentifier();
							if (this.context.strict) {
								if (this.scanner.isRestrictedWord(token.value)) {
									this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
								}
							} else {
								if (this.scanner.isRestrictedWord(token.value)) {
									firstRestricted = token;
									message = messages_1.Messages.StrictFunctionName;
								} else if (this.scanner.isStrictModeReservedWord(token.value)) {
									firstRestricted = token;
									message = messages_1.Messages.StrictReservedWord;
								}
							}
						}
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = !isGenerator;
						var formalParameters = this.parseFormalParameters(firstRestricted);
						var params = formalParameters.params;
						var stricted = formalParameters.stricted;
						firstRestricted = formalParameters.firstRestricted;
						if (formalParameters.message) {
							message = formalParameters.message;
						}
						var previousStrict = this.context.strict;
						var body = this.parseFunctionSourceElements();
						if (this.context.strict && firstRestricted) {
							this.throwUnexpectedToken(firstRestricted, message);
						}
						if (this.context.strict && stricted) {
							this.tolerateUnexpectedToken(stricted, message);
						}
						this.context.strict = previousStrict;
						this.context.allowYield = previousAllowYield;
						return this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
					};
					Parser.prototype.parseFunctionExpression = function () {
						var node = this.createNode();
						this.expectKeyword('function');
						var isGenerator = this.match('*');
						if (isGenerator) {
							this.nextToken();
						}
						var message;
						var id = null;
						var firstRestricted;
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = !isGenerator;
						if (!this.match('(')) {
							var token = this.lookahead;
							id = !this.context.strict && !isGenerator && this.matchKeyword('yield') ? this.parseIdentifierName() : this.parseVariableIdentifier();
							if (this.context.strict) {
								if (this.scanner.isRestrictedWord(token.value)) {
									this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
								}
							} else {
								if (this.scanner.isRestrictedWord(token.value)) {
									firstRestricted = token;
									message = messages_1.Messages.StrictFunctionName;
								} else if (this.scanner.isStrictModeReservedWord(token.value)) {
									firstRestricted = token;
									message = messages_1.Messages.StrictReservedWord;
								}
							}
						}
						var formalParameters = this.parseFormalParameters(firstRestricted);
						var params = formalParameters.params;
						var stricted = formalParameters.stricted;
						firstRestricted = formalParameters.firstRestricted;
						if (formalParameters.message) {
							message = formalParameters.message;
						}
						var previousStrict = this.context.strict;
						var body = this.parseFunctionSourceElements();
						if (this.context.strict && firstRestricted) {
							this.throwUnexpectedToken(firstRestricted, message);
						}
						if (this.context.strict && stricted) {
							this.tolerateUnexpectedToken(stricted, message);
						}
						this.context.strict = previousStrict;
						this.context.allowYield = previousAllowYield;
						return this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
					};
					// ECMA-262 14.1.1 Directive Prologues
					Parser.prototype.parseDirective = function () {
						var token = this.lookahead;
						var directive = null;
						var node = this.createNode();
						var expr = this.parseExpression();
						if (expr.type === syntax_1.Syntax.Literal) {
							directive = this.getTokenRaw(token).slice(1, -1);
						}
						this.consumeSemicolon();
						return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
					};
					Parser.prototype.parseDirectivePrologues = function () {
						var firstRestricted = null;
						var body = [];
						while (true) {
							var token = this.lookahead;
							if (token.type !== token_1.Token.StringLiteral) {
								break;
							}
							var statement = this.parseDirective();
							body.push(statement);
							var directive = statement.directive;
							if (typeof directive !== 'string') {
								break;
							}
							if (directive === 'use strict') {
								this.context.strict = true;
								if (firstRestricted) {
									this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
								}
							} else {
								if (!firstRestricted && token.octal) {
									firstRestricted = token;
								}
							}
						}
						return body;
					};
					// ECMA-262 14.3 Method Definitions
					Parser.prototype.qualifiedPropertyName = function (token) {
						switch (token.type) {
							case token_1.Token.Identifier:
							case token_1.Token.StringLiteral:
							case token_1.Token.BooleanLiteral:
							case token_1.Token.NullLiteral:
							case token_1.Token.NumericLiteral:
							case token_1.Token.Keyword:
								return true;
							case token_1.Token.Punctuator:
								return token.value === '[';
						}
						return false;
					};
					Parser.prototype.parseGetterMethod = function () {
						var node = this.createNode();
						this.expect('(');
						this.expect(')');
						var isGenerator = false;
						var params = {
							params: [],
							stricted: null,
							firstRestricted: null,
							message: null
						};
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = false;
						var method = this.parsePropertyMethod(params);
						this.context.allowYield = previousAllowYield;
						return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
					};
					Parser.prototype.parseSetterMethod = function () {
						var node = this.createNode();
						var options = {
							params: [],
							firstRestricted: null,
							paramSet: {}
						};
						var isGenerator = false;
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = false;
						this.expect('(');
						if (this.match(')')) {
							this.tolerateUnexpectedToken(this.lookahead);
						} else {
							this.parseFormalParameter(options);
						}
						this.expect(')');
						var method = this.parsePropertyMethod(options);
						this.context.allowYield = previousAllowYield;
						return this.finalize(node, new Node.FunctionExpression(null, options.params, method, isGenerator));
					};
					Parser.prototype.parseGeneratorMethod = function () {
						var node = this.createNode();
						var isGenerator = true;
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = true;
						var params = this.parseFormalParameters();
						this.context.allowYield = false;
						var method = this.parsePropertyMethod(params);
						this.context.allowYield = previousAllowYield;
						return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
					};
					// ECMA-262 14.4 Generator Function Definitions
					Parser.prototype.parseYieldExpression = function () {
						var node = this.createNode();
						this.expectKeyword('yield');
						var argument = null;
						var delegate = false;
						if (!this.hasLineTerminator) {
							var previousAllowYield = this.context.allowYield;
							this.context.allowYield = false;
							delegate = this.match('*');
							if (delegate) {
								this.nextToken();
								argument = this.parseAssignmentExpression();
							} else {
								if (!this.match(';') && !this.match('}') && !this.match(')') && this.lookahead.type !== token_1.Token.EOF) {
									argument = this.parseAssignmentExpression();
								}
							}
							this.context.allowYield = previousAllowYield;
						}
						return this.finalize(node, new Node.YieldExpression(argument, delegate));
					};
					// ECMA-262 14.5 Class Definitions
					Parser.prototype.parseClassElement = function (hasConstructor) {
						var token = this.lookahead;
						var node = this.createNode();
						var kind;
						var key;
						var value;
						var computed = false;
						var method = false;
						var isStatic = false;
						if (this.match('*')) {
							this.nextToken();
						} else {
							computed = this.match('[');
							key = this.parseObjectPropertyKey();
							var id = key;
							if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
								token = this.lookahead;
								isStatic = true;
								computed = this.match('[');
								if (this.match('*')) {
									this.nextToken();
								} else {
									key = this.parseObjectPropertyKey();
								}
							}
						}
						var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
						if (token.type === token_1.Token.Identifier) {
							if (token.value === 'get' && lookaheadPropertyKey) {
								kind = 'get';
								computed = this.match('[');
								key = this.parseObjectPropertyKey();
								this.context.allowYield = false;
								value = this.parseGetterMethod();
							} else if (token.value === 'set' && lookaheadPropertyKey) {
								kind = 'set';
								computed = this.match('[');
								key = this.parseObjectPropertyKey();
								value = this.parseSetterMethod();
							}
						} else if (token.type === token_1.Token.Punctuator && token.value === '*' && lookaheadPropertyKey) {
							kind = 'init';
							computed = this.match('[');
							key = this.parseObjectPropertyKey();
							value = this.parseGeneratorMethod();
							method = true;
						}
						if (!kind && key && this.match('(')) {
							kind = 'init';
							value = this.parsePropertyMethodFunction();
							method = true;
						}
						if (!kind) {
							this.throwUnexpectedToken(this.lookahead);
						}
						if (kind === 'init') {
							kind = 'method';
						}
						if (!computed) {
							if (isStatic && this.isPropertyKey(key, 'prototype')) {
								this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
							}
							if (!isStatic && this.isPropertyKey(key, 'constructor')) {
								if (kind !== 'method' || !method || value.generator) {
									this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
								}
								if (hasConstructor.value) {
									this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
								} else {
									hasConstructor.value = true;
								}
								kind = 'constructor';
							}
						}
						return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
					};
					Parser.prototype.parseClassElementList = function () {
						var body = [];
						var hasConstructor = { value: false };
						this.expect('{');
						while (!this.match('}')) {
							if (this.match(';')) {
								this.nextToken();
							} else {
								body.push(this.parseClassElement(hasConstructor));
							}
						}
						this.expect('}');
						return body;
					};
					Parser.prototype.parseClassBody = function () {
						var node = this.createNode();
						var elementList = this.parseClassElementList();
						return this.finalize(node, new Node.ClassBody(elementList));
					};
					Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
						var node = this.createNode();
						var previousStrict = this.context.strict;
						this.context.strict = true;
						this.expectKeyword('class');
						var id = identifierIsOptional && this.lookahead.type !== token_1.Token.Identifier ? null : this.parseVariableIdentifier();
						var superClass = null;
						if (this.matchKeyword('extends')) {
							this.nextToken();
							superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
						}
						var classBody = this.parseClassBody();
						this.context.strict = previousStrict;
						return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
					};
					Parser.prototype.parseClassExpression = function () {
						var node = this.createNode();
						var previousStrict = this.context.strict;
						this.context.strict = true;
						this.expectKeyword('class');
						var id = this.lookahead.type === token_1.Token.Identifier ? this.parseVariableIdentifier() : null;
						var superClass = null;
						if (this.matchKeyword('extends')) {
							this.nextToken();
							superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
						}
						var classBody = this.parseClassBody();
						this.context.strict = previousStrict;
						return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
					};
					// ECMA-262 15.1 Scripts
					// ECMA-262 15.2 Modules
					Parser.prototype.parseProgram = function () {
						var node = this.createNode();
						var body = this.parseDirectivePrologues();
						while (this.startMarker.index < this.scanner.length) {
							body.push(this.parseStatementListItem());
						}
						return this.finalize(node, new Node.Program(body, this.sourceType));
					};
					// ECMA-262 15.2.2 Imports
					Parser.prototype.parseModuleSpecifier = function () {
						var node = this.createNode();
						if (this.lookahead.type !== token_1.Token.StringLiteral) {
							this.throwError(messages_1.Messages.InvalidModuleSpecifier);
						}
						var token = this.nextToken();
						var raw = this.getTokenRaw(token);
						return this.finalize(node, new Node.Literal(token.value, raw));
					};
					// import {<foo as bar>} ...;
					Parser.prototype.parseImportSpecifier = function () {
						var node = this.createNode();
						var imported;
						var local;
						if (this.lookahead.type === token_1.Token.Identifier) {
							imported = this.parseVariableIdentifier();
							local = imported;
							if (this.matchContextualKeyword('as')) {
								this.nextToken();
								local = this.parseVariableIdentifier();
							}
						} else {
							imported = this.parseIdentifierName();
							local = imported;
							if (this.matchContextualKeyword('as')) {
								this.nextToken();
								local = this.parseVariableIdentifier();
							} else {
								this.throwUnexpectedToken(this.nextToken());
							}
						}
						return this.finalize(node, new Node.ImportSpecifier(local, imported));
					};
					// {foo, bar as bas}
					Parser.prototype.parseNamedImports = function () {
						this.expect('{');
						var specifiers = [];
						while (!this.match('}')) {
							specifiers.push(this.parseImportSpecifier());
							if (!this.match('}')) {
								this.expect(',');
							}
						}
						this.expect('}');
						return specifiers;
					};
					// import <foo> ...;
					Parser.prototype.parseImportDefaultSpecifier = function () {
						var node = this.createNode();
						var local = this.parseIdentifierName();
						return this.finalize(node, new Node.ImportDefaultSpecifier(local));
					};
					// import <* as foo> ...;
					Parser.prototype.parseImportNamespaceSpecifier = function () {
						var node = this.createNode();
						this.expect('*');
						if (!this.matchContextualKeyword('as')) {
							this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
						}
						this.nextToken();
						var local = this.parseIdentifierName();
						return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
					};
					Parser.prototype.parseImportDeclaration = function () {
						if (this.context.inFunctionBody) {
							this.throwError(messages_1.Messages.IllegalImportDeclaration);
						}
						var node = this.createNode();
						this.expectKeyword('import');
						var src;
						var specifiers = [];
						if (this.lookahead.type === token_1.Token.StringLiteral) {
							// import 'foo';
							src = this.parseModuleSpecifier();
						} else {
							if (this.match('{')) {
								// import {bar}
								specifiers = specifiers.concat(this.parseNamedImports());
							} else if (this.match('*')) {
								// import * as foo
								specifiers.push(this.parseImportNamespaceSpecifier());
							} else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
								// import foo
								specifiers.push(this.parseImportDefaultSpecifier());
								if (this.match(',')) {
									this.nextToken();
									if (this.match('*')) {
										// import foo, * as foo
										specifiers.push(this.parseImportNamespaceSpecifier());
									} else if (this.match('{')) {
										// import foo, {bar}
										specifiers = specifiers.concat(this.parseNamedImports());
									} else {
										this.throwUnexpectedToken(this.lookahead);
									}
								}
							} else {
								this.throwUnexpectedToken(this.nextToken());
							}
							if (!this.matchContextualKeyword('from')) {
								var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
								this.throwError(message, this.lookahead.value);
							}
							this.nextToken();
							src = this.parseModuleSpecifier();
						}
						this.consumeSemicolon();
						return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
					};
					// ECMA-262 15.2.3 Exports
					Parser.prototype.parseExportSpecifier = function () {
						var node = this.createNode();
						var local = this.parseIdentifierName();
						var exported = local;
						if (this.matchContextualKeyword('as')) {
							this.nextToken();
							exported = this.parseIdentifierName();
						}
						return this.finalize(node, new Node.ExportSpecifier(local, exported));
					};
					Parser.prototype.parseExportDeclaration = function () {
						if (this.context.inFunctionBody) {
							this.throwError(messages_1.Messages.IllegalExportDeclaration);
						}
						var node = this.createNode();
						this.expectKeyword('export');
						var exportDeclaration;
						if (this.matchKeyword('default')) {
							// export default ...
							this.nextToken();
							if (this.matchKeyword('function')) {
								// export default function foo () {}
								// export default function () {}
								var declaration = this.parseFunctionDeclaration(true);
								exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
							} else if (this.matchKeyword('class')) {
								// export default class foo {}
								var declaration = this.parseClassDeclaration(true);
								exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
							} else {
								if (this.matchContextualKeyword('from')) {
									this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
								}
								// export default {};
								// export default [];
								// export default (1 + 2);
								var declaration = this.match('{') ? this.parseObjectInitializer() : this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
								this.consumeSemicolon();
								exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
							}
						} else if (this.match('*')) {
							// export * from 'foo';
							this.nextToken();
							if (!this.matchContextualKeyword('from')) {
								var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
								this.throwError(message, this.lookahead.value);
							}
							this.nextToken();
							var src = this.parseModuleSpecifier();
							this.consumeSemicolon();
							exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
						} else if (this.lookahead.type === token_1.Token.Keyword) {
							// export var f = 1;
							var declaration = void 0;
							switch (this.lookahead.value) {
								case 'let':
								case 'const':
									declaration = this.parseLexicalDeclaration({ inFor: false });
									break;
								case 'var':
								case 'class':
								case 'function':
									declaration = this.parseStatementListItem();
									break;
								default:
									this.throwUnexpectedToken(this.lookahead);
							}
							exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
						} else {
							var specifiers = [];
							var source = null;
							var isExportFromIdentifier = false;
							this.expect('{');
							while (!this.match('}')) {
								isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
								specifiers.push(this.parseExportSpecifier());
								if (!this.match('}')) {
									this.expect(',');
								}
							}
							this.expect('}');
							if (this.matchContextualKeyword('from')) {
								// export {default} from 'foo';
								// export {foo} from 'foo';
								this.nextToken();
								source = this.parseModuleSpecifier();
								this.consumeSemicolon();
							} else if (isExportFromIdentifier) {
								// export {default}; // missing fromClause
								var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
								this.throwError(message, this.lookahead.value);
							} else {
								// export {foo};
								this.consumeSemicolon();
							}
							exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
						}
						return exportDeclaration;
					};
					return Parser;
				}();
				exports.Parser = Parser;

				/***/
			},
			/* 4 */
			/***/function (module, exports) {

				// Ensure the condition is true, otherwise throw an error.
				// This is only to have a better contract semantic, i.e. another safety net
				// to catch a logic error. The condition shall be fulfilled in normal case.
				// Do NOT use this to enforce a certain condition on any user input.
				"use strict";

				function assert(condition, message) {
					/* istanbul ignore if */
					if (!condition) {
						throw new Error('ASSERT: ' + message);
					}
				}
				exports.assert = assert;

				/***/
			},
			/* 5 */
			/***/function (module, exports) {

				"use strict";
				// Error messages should be identical to V8.

				exports.Messages = {
					UnexpectedToken: 'Unexpected token %0',
					UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
					UnexpectedNumber: 'Unexpected number',
					UnexpectedString: 'Unexpected string',
					UnexpectedIdentifier: 'Unexpected identifier',
					UnexpectedReserved: 'Unexpected reserved word',
					UnexpectedTemplate: 'Unexpected quasi %0',
					UnexpectedEOS: 'Unexpected end of input',
					NewlineAfterThrow: 'Illegal newline after throw',
					InvalidRegExp: 'Invalid regular expression',
					UnterminatedRegExp: 'Invalid regular expression: missing /',
					InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
					InvalidLHSInForIn: 'Invalid left-hand side in for-in',
					InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
					MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
					NoCatchOrFinally: 'Missing catch or finally after try',
					UnknownLabel: 'Undefined label \'%0\'',
					Redeclaration: '%0 \'%1\' has already been declared',
					IllegalContinue: 'Illegal continue statement',
					IllegalBreak: 'Illegal break statement',
					IllegalReturn: 'Illegal return statement',
					StrictModeWith: 'Strict mode code may not include a with statement',
					StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
					StrictVarName: 'Variable name may not be eval or arguments in strict mode',
					StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
					StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
					StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
					StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
					StrictDelete: 'Delete of an unqualified identifier in strict mode.',
					StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
					StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
					StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
					StrictReservedWord: 'Use of future reserved word in strict mode',
					TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
					ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
					DefaultRestParameter: 'Unexpected token =',
					ObjectPatternAsRestParameter: 'Unexpected token {',
					DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
					ConstructorSpecialMethod: 'Class constructor may not be an accessor',
					DuplicateConstructor: 'A class may only have one constructor',
					StaticPrototype: 'Classes may not have static property named prototype',
					MissingFromClause: 'Unexpected token',
					NoAsAfterImportNamespace: 'Unexpected token',
					InvalidModuleSpecifier: 'Unexpected token',
					IllegalImportDeclaration: 'Unexpected token',
					IllegalExportDeclaration: 'Unexpected token',
					DuplicateBinding: 'Duplicate binding %0',
					ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer'
				};

				/***/
			},
			/* 6 */
			/***/function (module, exports) {

				"use strict";

				var ErrorHandler = function () {
					function ErrorHandler() {
						this.errors = [];
						this.tolerant = false;
					}
					;
					ErrorHandler.prototype.recordError = function (error) {
						this.errors.push(error);
					};
					;
					ErrorHandler.prototype.tolerate = function (error) {
						if (this.tolerant) {
							this.recordError(error);
						} else {
							throw error;
						}
					};
					;
					ErrorHandler.prototype.constructError = function (msg, column) {
						var error = new Error(msg);
						try {
							throw error;
						} catch (base) {
							/* istanbul ignore else */
							if (Object.create && Object.defineProperty) {
								error = Object.create(base);
								Object.defineProperty(error, 'column', { value: column });
							}
						} finally {
							return error;
						}
					};
					;
					ErrorHandler.prototype.createError = function (index, line, col, description) {
						var msg = 'Line ' + line + ': ' + description;
						var error = this.constructError(msg, col);
						error.index = index;
						error.lineNumber = line;
						error.description = description;
						return error;
					};
					;
					ErrorHandler.prototype.throwError = function (index, line, col, description) {
						throw this.createError(index, line, col, description);
					};
					;
					ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
						var error = this.createError(index, line, col, description);
						if (this.tolerant) {
							this.recordError(error);
						} else {
							throw error;
						}
					};
					;
					return ErrorHandler;
				}();
				exports.ErrorHandler = ErrorHandler;

				/***/
			},
			/* 7 */
			/***/function (module, exports) {

				"use strict";

				(function (Token) {
					Token[Token["BooleanLiteral"] = 1] = "BooleanLiteral";
					Token[Token["EOF"] = 2] = "EOF";
					Token[Token["Identifier"] = 3] = "Identifier";
					Token[Token["Keyword"] = 4] = "Keyword";
					Token[Token["NullLiteral"] = 5] = "NullLiteral";
					Token[Token["NumericLiteral"] = 6] = "NumericLiteral";
					Token[Token["Punctuator"] = 7] = "Punctuator";
					Token[Token["StringLiteral"] = 8] = "StringLiteral";
					Token[Token["RegularExpression"] = 9] = "RegularExpression";
					Token[Token["Template"] = 10] = "Template";
				})(exports.Token || (exports.Token = {}));
				var Token = exports.Token;
				;
				exports.TokenName = {};
				exports.TokenName[Token.BooleanLiteral] = 'Boolean';
				exports.TokenName[Token.EOF] = '<end>';
				exports.TokenName[Token.Identifier] = 'Identifier';
				exports.TokenName[Token.Keyword] = 'Keyword';
				exports.TokenName[Token.NullLiteral] = 'Null';
				exports.TokenName[Token.NumericLiteral] = 'Numeric';
				exports.TokenName[Token.Punctuator] = 'Punctuator';
				exports.TokenName[Token.StringLiteral] = 'String';
				exports.TokenName[Token.RegularExpression] = 'RegularExpression';
				exports.TokenName[Token.Template] = 'Template';

				/***/
			},
			/* 8 */
			/***/function (module, exports, __webpack_require__) {

				"use strict";

				var assert_1 = __webpack_require__(4);
				var messages_1 = __webpack_require__(5);
				var character_1 = __webpack_require__(9);
				var token_1 = __webpack_require__(7);
				function hexValue(ch) {
					return '0123456789abcdef'.indexOf(ch.toLowerCase());
				}
				function octalValue(ch) {
					return '01234567'.indexOf(ch);
				}
				var Scanner = function () {
					function Scanner(code, handler) {
						this.source = code;
						this.errorHandler = handler;
						this.trackComment = false;
						this.length = code.length;
						this.index = 0;
						this.lineNumber = code.length > 0 ? 1 : 0;
						this.lineStart = 0;
						this.curlyStack = [];
					}
					;
					Scanner.prototype.eof = function () {
						return this.index >= this.length;
					};
					;
					Scanner.prototype.throwUnexpectedToken = function (message) {
						if (message === void 0) {
							message = messages_1.Messages.UnexpectedTokenIllegal;
						}
						this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
					};
					;
					Scanner.prototype.tolerateUnexpectedToken = function () {
						this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, messages_1.Messages.UnexpectedTokenIllegal);
					};
					;
					// ECMA-262 11.4 Comments
					Scanner.prototype.skipSingleLineComment = function (offset) {
						var comments;
						var start, loc;
						if (this.trackComment) {
							comments = [];
							start = this.index - offset;
							loc = {
								start: {
									line: this.lineNumber,
									column: this.index - this.lineStart - offset
								},
								end: {}
							};
						}
						while (!this.eof()) {
							var ch = this.source.charCodeAt(this.index);
							++this.index;
							if (character_1.Character.isLineTerminator(ch)) {
								if (this.trackComment) {
									loc.end = {
										line: this.lineNumber,
										column: this.index - this.lineStart - 1
									};
									var entry = {
										multiLine: false,
										slice: [start + offset, this.index - 1],
										range: [start, this.index - 1],
										loc: loc
									};
									comments.push(entry);
								}
								if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
									++this.index;
								}
								++this.lineNumber;
								this.lineStart = this.index;
								return comments;
							}
						}
						if (this.trackComment) {
							loc.end = {
								line: this.lineNumber,
								column: this.index - this.lineStart
							};
							var entry = {
								multiLine: false,
								slice: [start + offset, this.index],
								range: [start, this.index],
								loc: loc
							};
							comments.push(entry);
						}
						return comments;
					};
					;
					Scanner.prototype.skipMultiLineComment = function () {
						var comments;
						var start, loc;
						if (this.trackComment) {
							comments = [];
							start = this.index - 2;
							loc = {
								start: {
									line: this.lineNumber,
									column: this.index - this.lineStart - 2
								},
								end: {}
							};
						}
						while (!this.eof()) {
							var ch = this.source.charCodeAt(this.index);
							if (character_1.Character.isLineTerminator(ch)) {
								if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
									++this.index;
								}
								++this.lineNumber;
								++this.index;
								this.lineStart = this.index;
							} else if (ch === 0x2A) {
								// Block comment ends with '*/'.
								if (this.source.charCodeAt(this.index + 1) === 0x2F) {
									this.index += 2;
									if (this.trackComment) {
										loc.end = {
											line: this.lineNumber,
											column: this.index - this.lineStart
										};
										var entry = {
											multiLine: true,
											slice: [start + 2, this.index - 2],
											range: [start, this.index],
											loc: loc
										};
										comments.push(entry);
									}
									return comments;
								}
								++this.index;
							} else {
								++this.index;
							}
						}
						// Ran off the end of the file - the whole thing is a comment
						if (this.trackComment) {
							loc.end = {
								line: this.lineNumber,
								column: this.index - this.lineStart
							};
							var entry = {
								multiLine: true,
								slice: [start + 2, this.index],
								range: [start, this.index],
								loc: loc
							};
							comments.push(entry);
						}
						this.tolerateUnexpectedToken();
						return comments;
					};
					;
					Scanner.prototype.scanComments = function () {
						var comments;
						if (this.trackComment) {
							comments = [];
						}
						var start = this.index === 0;
						while (!this.eof()) {
							var ch = this.source.charCodeAt(this.index);
							if (character_1.Character.isWhiteSpace(ch)) {
								++this.index;
							} else if (character_1.Character.isLineTerminator(ch)) {
								++this.index;
								if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
									++this.index;
								}
								++this.lineNumber;
								this.lineStart = this.index;
								start = true;
							} else if (ch === 0x2F) {
								ch = this.source.charCodeAt(this.index + 1);
								if (ch === 0x2F) {
									this.index += 2;
									var comment = this.skipSingleLineComment(2);
									if (this.trackComment) {
										comments = comments.concat(comment);
									}
									start = true;
								} else if (ch === 0x2A) {
									this.index += 2;
									var comment = this.skipMultiLineComment();
									if (this.trackComment) {
										comments = comments.concat(comment);
									}
								} else {
									break;
								}
							} else if (start && ch === 0x2D) {
								// U+003E is '>'
								if (this.source.charCodeAt(this.index + 1) === 0x2D && this.source.charCodeAt(this.index + 2) === 0x3E) {
									// '-->' is a single-line comment
									this.index += 3;
									var comment = this.skipSingleLineComment(3);
									if (this.trackComment) {
										comments = comments.concat(comment);
									}
								} else {
									break;
								}
							} else if (ch === 0x3C) {
								if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
									this.index += 4; // `<!--`
									var comment = this.skipSingleLineComment(4);
									if (this.trackComment) {
										comments = comments.concat(comment);
									}
								} else {
									break;
								}
							} else {
								break;
							}
						}
						return comments;
					};
					;
					// ECMA-262 11.6.2.2 Future Reserved Words
					Scanner.prototype.isFutureReservedWord = function (id) {
						switch (id) {
							case 'enum':
							case 'export':
							case 'import':
							case 'super':
								return true;
							default:
								return false;
						}
					};
					;
					Scanner.prototype.isStrictModeReservedWord = function (id) {
						switch (id) {
							case 'implements':
							case 'interface':
							case 'package':
							case 'private':
							case 'protected':
							case 'public':
							case 'static':
							case 'yield':
							case 'let':
								return true;
							default:
								return false;
						}
					};
					;
					Scanner.prototype.isRestrictedWord = function (id) {
						return id === 'eval' || id === 'arguments';
					};
					;
					// ECMA-262 11.6.2.1 Keywords
					Scanner.prototype.isKeyword = function (id) {
						switch (id.length) {
							case 2:
								return id === 'if' || id === 'in' || id === 'do';
							case 3:
								return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';
							case 4:
								return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
							case 5:
								return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
							case 6:
								return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
							case 7:
								return id === 'default' || id === 'finally' || id === 'extends';
							case 8:
								return id === 'function' || id === 'continue' || id === 'debugger';
							case 10:
								return id === 'instanceof';
							default:
								return false;
						}
					};
					;
					Scanner.prototype.codePointAt = function (i) {
						var cp = this.source.charCodeAt(i);
						if (cp >= 0xD800 && cp <= 0xDBFF) {
							var second = this.source.charCodeAt(i + 1);
							if (second >= 0xDC00 && second <= 0xDFFF) {
								var first = cp;
								cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
							}
						}
						return cp;
					};
					;
					Scanner.prototype.scanHexEscape = function (prefix) {
						var len = prefix === 'u' ? 4 : 2;
						var code = 0;
						for (var i = 0; i < len; ++i) {
							if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
								code = code * 16 + hexValue(this.source[this.index++]);
							} else {
								return '';
							}
						}
						return String.fromCharCode(code);
					};
					;
					Scanner.prototype.scanUnicodeCodePointEscape = function () {
						var ch = this.source[this.index];
						var code = 0;
						// At least, one hex digit is required.
						if (ch === '}') {
							this.throwUnexpectedToken();
						}
						while (!this.eof()) {
							ch = this.source[this.index++];
							if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
								break;
							}
							code = code * 16 + hexValue(ch);
						}
						if (code > 0x10FFFF || ch !== '}') {
							this.throwUnexpectedToken();
						}
						return character_1.Character.fromCodePoint(code);
					};
					;
					Scanner.prototype.getIdentifier = function () {
						var start = this.index++;
						while (!this.eof()) {
							var ch = this.source.charCodeAt(this.index);
							if (ch === 0x5C) {
								// Blackslash (U+005C) marks Unicode escape sequence.
								this.index = start;
								return this.getComplexIdentifier();
							} else if (ch >= 0xD800 && ch < 0xDFFF) {
								// Need to handle surrogate pairs.
								this.index = start;
								return this.getComplexIdentifier();
							}
							if (character_1.Character.isIdentifierPart(ch)) {
								++this.index;
							} else {
								break;
							}
						}
						return this.source.slice(start, this.index);
					};
					;
					Scanner.prototype.getComplexIdentifier = function () {
						var cp = this.codePointAt(this.index);
						var id = character_1.Character.fromCodePoint(cp);
						this.index += id.length;
						// '\u' (U+005C, U+0075) denotes an escaped character.
						var ch;
						if (cp === 0x5C) {
							if (this.source.charCodeAt(this.index) !== 0x75) {
								this.throwUnexpectedToken();
							}
							++this.index;
							if (this.source[this.index] === '{') {
								++this.index;
								ch = this.scanUnicodeCodePointEscape();
							} else {
								ch = this.scanHexEscape('u');
								cp = ch.charCodeAt(0);
								if (!ch || ch === '\\' || !character_1.Character.isIdentifierStart(cp)) {
									this.throwUnexpectedToken();
								}
							}
							id = ch;
						}
						while (!this.eof()) {
							cp = this.codePointAt(this.index);
							if (!character_1.Character.isIdentifierPart(cp)) {
								break;
							}
							ch = character_1.Character.fromCodePoint(cp);
							id += ch;
							this.index += ch.length;
							// '\u' (U+005C, U+0075) denotes an escaped character.
							if (cp === 0x5C) {
								id = id.substr(0, id.length - 1);
								if (this.source.charCodeAt(this.index) !== 0x75) {
									this.throwUnexpectedToken();
								}
								++this.index;
								if (this.source[this.index] === '{') {
									++this.index;
									ch = this.scanUnicodeCodePointEscape();
								} else {
									ch = this.scanHexEscape('u');
									cp = ch.charCodeAt(0);
									if (!ch || ch === '\\' || !character_1.Character.isIdentifierPart(cp)) {
										this.throwUnexpectedToken();
									}
								}
								id += ch;
							}
						}
						return id;
					};
					;
					Scanner.prototype.octalToDecimal = function (ch) {
						// \0 is not octal escape sequence
						var octal = ch !== '0';
						var code = octalValue(ch);
						if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
							octal = true;
							code = code * 8 + octalValue(this.source[this.index++]);
							// 3 digits are only allowed when string starts
							// with 0, 1, 2, 3
							if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
								code = code * 8 + octalValue(this.source[this.index++]);
							}
						}
						return {
							code: code,
							octal: octal
						};
					};
					;
					// ECMA-262 11.6 Names and Keywords
					Scanner.prototype.scanIdentifier = function () {
						var type;
						var start = this.index;
						// Backslash (U+005C) starts an escaped character.
						var id = this.source.charCodeAt(start) === 0x5C ? this.getComplexIdentifier() : this.getIdentifier();
						// There is no keyword or literal with only one character.
						// Thus, it must be an identifier.
						if (id.length === 1) {
							type = token_1.Token.Identifier;
						} else if (this.isKeyword(id)) {
							type = token_1.Token.Keyword;
						} else if (id === 'null') {
							type = token_1.Token.NullLiteral;
						} else if (id === 'true' || id === 'false') {
							type = token_1.Token.BooleanLiteral;
						} else {
							type = token_1.Token.Identifier;
						}
						return {
							type: type,
							value: id,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: start,
							end: this.index
						};
					};
					;
					// ECMA-262 11.7 Punctuators
					Scanner.prototype.scanPunctuator = function () {
						var token = {
							type: token_1.Token.Punctuator,
							value: '',
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: this.index,
							end: this.index
						};
						// Check for most common single-character punctuators.
						var str = this.source[this.index];
						switch (str) {
							case '(':
							case '{':
								if (str === '{') {
									this.curlyStack.push('{');
								}
								++this.index;
								break;
							case '.':
								++this.index;
								if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
									// Spread operator: ...
									this.index += 2;
									str = '...';
								}
								break;
							case '}':
								++this.index;
								this.curlyStack.pop();
								break;
							case ')':
							case ';':
							case ',':
							case '[':
							case ']':
							case ':':
							case '?':
							case '~':
								++this.index;
								break;
							default:
								// 4-character punctuator.
								str = this.source.substr(this.index, 4);
								if (str === '>>>=') {
									this.index += 4;
								} else {
									// 3-character punctuators.
									str = str.substr(0, 3);
									if (str === '===' || str === '!==' || str === '>>>' || str === '<<=' || str === '>>=' || str === '**=') {
										this.index += 3;
									} else {
										// 2-character punctuators.
										str = str.substr(0, 2);
										if (str === '&&' || str === '||' || str === '==' || str === '!=' || str === '+=' || str === '-=' || str === '*=' || str === '/=' || str === '++' || str === '--' || str === '<<' || str === '>>' || str === '&=' || str === '|=' || str === '^=' || str === '%=' || str === '<=' || str === '>=' || str === '=>' || str === '**') {
											this.index += 2;
										} else {
											// 1-character punctuators.
											str = this.source[this.index];
											if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
												++this.index;
											}
										}
									}
								}
						}
						if (this.index === token.start) {
							this.throwUnexpectedToken();
						}
						token.end = this.index;
						token.value = str;
						return token;
					};
					;
					// ECMA-262 11.8.3 Numeric Literals
					Scanner.prototype.scanHexLiteral = function (start) {
						var number = '';
						while (!this.eof()) {
							if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
								break;
							}
							number += this.source[this.index++];
						}
						if (number.length === 0) {
							this.throwUnexpectedToken();
						}
						if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
							this.throwUnexpectedToken();
						}
						return {
							type: token_1.Token.NumericLiteral,
							value: parseInt('0x' + number, 16),
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: start,
							end: this.index
						};
					};
					;
					Scanner.prototype.scanBinaryLiteral = function (start) {
						var number = '';
						var ch;
						while (!this.eof()) {
							ch = this.source[this.index];
							if (ch !== '0' && ch !== '1') {
								break;
							}
							number += this.source[this.index++];
						}
						if (number.length === 0) {
							// only 0b or 0B
							this.throwUnexpectedToken();
						}
						if (!this.eof()) {
							ch = this.source.charCodeAt(this.index);
							/* istanbul ignore else */
							if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
								this.throwUnexpectedToken();
							}
						}
						return {
							type: token_1.Token.NumericLiteral,
							value: parseInt(number, 2),
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: start,
							end: this.index
						};
					};
					;
					Scanner.prototype.scanOctalLiteral = function (prefix, start) {
						var number = '';
						var octal = false;
						if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
							octal = true;
							number = '0' + this.source[this.index++];
						} else {
							++this.index;
						}
						while (!this.eof()) {
							if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
								break;
							}
							number += this.source[this.index++];
						}
						if (!octal && number.length === 0) {
							// only 0o or 0O
							this.throwUnexpectedToken();
						}
						if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							this.throwUnexpectedToken();
						}
						return {
							type: token_1.Token.NumericLiteral,
							value: parseInt(number, 8),
							octal: octal,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: start,
							end: this.index
						};
					};
					;
					Scanner.prototype.isImplicitOctalLiteral = function () {
						// Implicit octal, unless there is a non-octal digit.
						// (Annex B.1.1 on Numeric Literals)
						for (var i = this.index + 1; i < this.length; ++i) {
							var ch = this.source[i];
							if (ch === '8' || ch === '9') {
								return false;
							}
							if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
								return true;
							}
						}
						return true;
					};
					;
					Scanner.prototype.scanNumericLiteral = function () {
						var start = this.index;
						var ch = this.source[start];
						assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
						var number = '';
						if (ch !== '.') {
							number = this.source[this.index++];
							ch = this.source[this.index];
							// Hex number starts with '0x'.
							// Octal number starts with '0'.
							// Octal number in ES6 starts with '0o'.
							// Binary number in ES6 starts with '0b'.
							if (number === '0') {
								if (ch === 'x' || ch === 'X') {
									++this.index;
									return this.scanHexLiteral(start);
								}
								if (ch === 'b' || ch === 'B') {
									++this.index;
									return this.scanBinaryLiteral(start);
								}
								if (ch === 'o' || ch === 'O') {
									return this.scanOctalLiteral(ch, start);
								}
								if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
									if (this.isImplicitOctalLiteral()) {
										return this.scanOctalLiteral(ch, start);
									}
								}
							}
							while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
								number += this.source[this.index++];
							}
							ch = this.source[this.index];
						}
						if (ch === '.') {
							number += this.source[this.index++];
							while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
								number += this.source[this.index++];
							}
							ch = this.source[this.index];
						}
						if (ch === 'e' || ch === 'E') {
							number += this.source[this.index++];
							ch = this.source[this.index];
							if (ch === '+' || ch === '-') {
								number += this.source[this.index++];
							}
							if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
								while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
									number += this.source[this.index++];
								}
							} else {
								this.throwUnexpectedToken();
							}
						}
						if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
							this.throwUnexpectedToken();
						}
						return {
							type: token_1.Token.NumericLiteral,
							value: parseFloat(number),
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: start,
							end: this.index
						};
					};
					;
					// ECMA-262 11.8.4 String Literals
					Scanner.prototype.scanStringLiteral = function () {
						var start = this.index;
						var quote = this.source[start];
						assert_1.assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
						++this.index;
						var octal = false;
						var str = '';
						while (!this.eof()) {
							var ch = this.source[this.index++];
							if (ch === quote) {
								quote = '';
								break;
							} else if (ch === '\\') {
								ch = this.source[this.index++];
								if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
									switch (ch) {
										case 'u':
										case 'x':
											if (this.source[this.index] === '{') {
												++this.index;
												str += this.scanUnicodeCodePointEscape();
											} else {
												var unescaped = this.scanHexEscape(ch);
												if (!unescaped) {
													this.throwUnexpectedToken();
												}
												str += unescaped;
											}
											break;
										case 'n':
											str += '\n';
											break;
										case 'r':
											str += '\r';
											break;
										case 't':
											str += '\t';
											break;
										case 'b':
											str += '\b';
											break;
										case 'f':
											str += '\f';
											break;
										case 'v':
											str += '\x0B';
											break;
										case '8':
										case '9':
											str += ch;
											this.tolerateUnexpectedToken();
											break;
										default:
											if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
												var octToDec = this.octalToDecimal(ch);
												octal = octToDec.octal || octal;
												str += String.fromCharCode(octToDec.code);
											} else {
												str += ch;
											}
											break;
									}
								} else {
									++this.lineNumber;
									if (ch === '\r' && this.source[this.index] === '\n') {
										++this.index;
									}
									this.lineStart = this.index;
								}
							} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								break;
							} else {
								str += ch;
							}
						}
						if (quote !== '') {
							this.index = start;
							this.throwUnexpectedToken();
						}
						return {
							type: token_1.Token.StringLiteral,
							value: str,
							octal: octal,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: start,
							end: this.index
						};
					};
					;
					// ECMA-262 11.8.6 Template Literal Lexical Components
					Scanner.prototype.scanTemplate = function () {
						var cooked = '';
						var terminated = false;
						var start = this.index;
						var head = this.source[start] === '`';
						var tail = false;
						var rawOffset = 2;
						++this.index;
						while (!this.eof()) {
							var ch = this.source[this.index++];
							if (ch === '`') {
								rawOffset = 1;
								tail = true;
								terminated = true;
								break;
							} else if (ch === '$') {
								if (this.source[this.index] === '{') {
									this.curlyStack.push('${');
									++this.index;
									terminated = true;
									break;
								}
								cooked += ch;
							} else if (ch === '\\') {
								ch = this.source[this.index++];
								if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
									switch (ch) {
										case 'n':
											cooked += '\n';
											break;
										case 'r':
											cooked += '\r';
											break;
										case 't':
											cooked += '\t';
											break;
										case 'u':
										case 'x':
											if (this.source[this.index] === '{') {
												++this.index;
												cooked += this.scanUnicodeCodePointEscape();
											} else {
												var restore = this.index;
												var unescaped = this.scanHexEscape(ch);
												if (unescaped) {
													cooked += unescaped;
												} else {
													this.index = restore;
													cooked += ch;
												}
											}
											break;
										case 'b':
											cooked += '\b';
											break;
										case 'f':
											cooked += '\f';
											break;
										case 'v':
											cooked += '\v';
											break;
										default:
											if (ch === '0') {
												if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
													// Illegal: \01 \02 and so on
													this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
												}
												cooked += '\0';
											} else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
												// Illegal: \1 \2
												this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
											} else {
												cooked += ch;
											}
											break;
									}
								} else {
									++this.lineNumber;
									if (ch === '\r' && this.source[this.index] === '\n') {
										++this.index;
									}
									this.lineStart = this.index;
								}
							} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								++this.lineNumber;
								if (ch === '\r' && this.source[this.index] === '\n') {
									++this.index;
								}
								this.lineStart = this.index;
								cooked += '\n';
							} else {
								cooked += ch;
							}
						}
						if (!terminated) {
							this.throwUnexpectedToken();
						}
						if (!head) {
							this.curlyStack.pop();
						}
						return {
							type: token_1.Token.Template,
							value: {
								cooked: cooked,
								raw: this.source.slice(start + 1, this.index - rawOffset)
							},
							head: head,
							tail: tail,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: start,
							end: this.index
						};
					};
					;
					// ECMA-262 11.8.5 Regular Expression Literals
					Scanner.prototype.testRegExp = function (pattern, flags) {
						// The BMP character to use as a replacement for astral symbols when
						// translating an ES6 "u"-flagged pattern to an ES5-compatible
						// approximation.
						// Note: replacing with '\uFFFF' enables false positives in unlikely
						// scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
						// pattern that would not be detected by this substitution.
						var astralSubstitute = '\uFFFF';
						var tmp = pattern;
						var self = this;
						if (flags.indexOf('u') >= 0) {
							tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
								var codePoint = parseInt($1 || $2, 16);
								if (codePoint > 0x10FFFF) {
									self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
								}
								if (codePoint <= 0xFFFF) {
									return String.fromCharCode(codePoint);
								}
								return astralSubstitute;
							}).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
						}
						// First, detect invalid regular expressions.
						try {
							RegExp(tmp);
						} catch (e) {
							this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
						}
						// Return a regular expression object for this pattern-flag pair, or
						// `null` in case the current environment doesn't support the flags it
						// uses.
						try {
							return new RegExp(pattern, flags);
						} catch (exception) {
							/* istanbul ignore next */
							return null;
						}
					};
					;
					Scanner.prototype.scanRegExpBody = function () {
						var ch = this.source[this.index];
						assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
						var str = this.source[this.index++];
						var classMarker = false;
						var terminated = false;
						while (!this.eof()) {
							ch = this.source[this.index++];
							str += ch;
							if (ch === '\\') {
								ch = this.source[this.index++];
								// ECMA-262 7.8.5
								if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
									this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
								}
								str += ch;
							} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
							} else if (classMarker) {
								if (ch === ']') {
									classMarker = false;
								}
							} else {
								if (ch === '/') {
									terminated = true;
									break;
								} else if (ch === '[') {
									classMarker = true;
								}
							}
						}
						if (!terminated) {
							this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
						}
						// Exclude leading and trailing slash.
						var body = str.substr(1, str.length - 2);
						return {
							value: body,
							literal: str
						};
					};
					;
					Scanner.prototype.scanRegExpFlags = function () {
						var str = '';
						var flags = '';
						while (!this.eof()) {
							var ch = this.source[this.index];
							if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
								break;
							}
							++this.index;
							if (ch === '\\' && !this.eof()) {
								ch = this.source[this.index];
								if (ch === 'u') {
									++this.index;
									var restore = this.index;
									ch = this.scanHexEscape('u');
									if (ch) {
										flags += ch;
										for (str += '\\u'; restore < this.index; ++restore) {
											str += this.source[restore];
										}
									} else {
										this.index = restore;
										flags += 'u';
										str += '\\u';
									}
									this.tolerateUnexpectedToken();
								} else {
									str += '\\';
									this.tolerateUnexpectedToken();
								}
							} else {
								flags += ch;
								str += ch;
							}
						}
						return {
							value: flags,
							literal: str
						};
					};
					;
					Scanner.prototype.scanRegExp = function () {
						var start = this.index;
						var body = this.scanRegExpBody();
						var flags = this.scanRegExpFlags();
						var value = this.testRegExp(body.value, flags.value);
						return {
							type: token_1.Token.RegularExpression,
							value: value,
							literal: body.literal + flags.literal,
							regex: {
								pattern: body.value,
								flags: flags.value
							},
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: start,
							end: this.index
						};
					};
					;
					Scanner.prototype.lex = function () {
						if (this.eof()) {
							return {
								type: token_1.Token.EOF,
								lineNumber: this.lineNumber,
								lineStart: this.lineStart,
								start: this.index,
								end: this.index
							};
						}
						var cp = this.source.charCodeAt(this.index);
						if (character_1.Character.isIdentifierStart(cp)) {
							return this.scanIdentifier();
						}
						// Very common: ( and ) and ;
						if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
							return this.scanPunctuator();
						}
						// String literal starts with single quote (U+0027) or double quote (U+0022).
						if (cp === 0x27 || cp === 0x22) {
							return this.scanStringLiteral();
						}
						// Dot (.) U+002E can also start a floating-point number, hence the need
						// to check the next character.
						if (cp === 0x2E) {
							if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
								return this.scanNumericLiteral();
							}
							return this.scanPunctuator();
						}
						if (character_1.Character.isDecimalDigit(cp)) {
							return this.scanNumericLiteral();
						}
						// Template literals start with ` (U+0060) for template head
						// or } (U+007D) for template middle or template tail.
						if (cp === 0x60 || cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${') {
							return this.scanTemplate();
						}
						// Possible identifier start in a surrogate pair.
						if (cp >= 0xD800 && cp < 0xDFFF) {
							if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
								return this.scanIdentifier();
							}
						}
						return this.scanPunctuator();
					};
					;
					return Scanner;
				}();
				exports.Scanner = Scanner;

				/***/
			},
			/* 9 */
			/***/function (module, exports) {

				"use strict";
				// See also tools/generate-unicode-regex.js.

				var Regex = {
					// Unicode v8.0.0 NonAsciiIdentifierStart:
					NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
					// Unicode v8.0.0 NonAsciiIdentifierPart:
					NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
				};
				exports.Character = {
					fromCodePoint: function (cp) {
						return cp < 0x10000 ? String.fromCharCode(cp) : String.fromCharCode(0xD800 + (cp - 0x10000 >> 10)) + String.fromCharCode(0xDC00 + (cp - 0x10000 & 1023));
					},
					// ECMA-262 11.2 White Space
					isWhiteSpace: function (cp) {
						return cp === 0x20 || cp === 0x09 || cp === 0x0B || cp === 0x0C || cp === 0xA0 || cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0;
					},
					// ECMA-262 11.3 Line Terminators
					isLineTerminator: function (cp) {
						return cp === 0x0A || cp === 0x0D || cp === 0x2028 || cp === 0x2029;
					},
					// ECMA-262 11.6 Identifier Names and Identifiers
					isIdentifierStart: function (cp) {
						return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp));
					},
					isIdentifierPart: function (cp) {
						return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp >= 0x30 && cp <= 0x39 || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp));
					},
					// ECMA-262 11.8.3 Numeric Literals
					isDecimalDigit: function (cp) {
						return cp >= 0x30 && cp <= 0x39; // 0..9
					},
					isHexDigit: function (cp) {
						return cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x46 || cp >= 0x61 && cp <= 0x66; // a..f
					},
					isOctalDigit: function (cp) {
						return cp >= 0x30 && cp <= 0x37; // 0..7
					}
				};

				/***/
			},
			/* 10 */
			/***/function (module, exports, __webpack_require__) {

				"use strict";

				var syntax_1 = __webpack_require__(2);
				var ArrayExpression = function () {
					function ArrayExpression(elements) {
						this.type = syntax_1.Syntax.ArrayExpression;
						this.elements = elements;
					}
					return ArrayExpression;
				}();
				exports.ArrayExpression = ArrayExpression;
				var ArrayPattern = function () {
					function ArrayPattern(elements) {
						this.type = syntax_1.Syntax.ArrayPattern;
						this.elements = elements;
					}
					return ArrayPattern;
				}();
				exports.ArrayPattern = ArrayPattern;
				var ArrowFunctionExpression = function () {
					function ArrowFunctionExpression(params, body, expression) {
						this.type = syntax_1.Syntax.ArrowFunctionExpression;
						this.id = null;
						this.params = params;
						this.body = body;
						this.generator = false;
						this.expression = expression;
					}
					return ArrowFunctionExpression;
				}();
				exports.ArrowFunctionExpression = ArrowFunctionExpression;
				var AssignmentExpression = function () {
					function AssignmentExpression(operator, left, right) {
						this.type = syntax_1.Syntax.AssignmentExpression;
						this.operator = operator;
						this.left = left;
						this.right = right;
					}
					return AssignmentExpression;
				}();
				exports.AssignmentExpression = AssignmentExpression;
				var AssignmentPattern = function () {
					function AssignmentPattern(left, right) {
						this.type = syntax_1.Syntax.AssignmentPattern;
						this.left = left;
						this.right = right;
					}
					return AssignmentPattern;
				}();
				exports.AssignmentPattern = AssignmentPattern;
				var BinaryExpression = function () {
					function BinaryExpression(operator, left, right) {
						var logical = operator === '||' || operator === '&&';
						this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
						this.operator = operator;
						this.left = left;
						this.right = right;
					}
					return BinaryExpression;
				}();
				exports.BinaryExpression = BinaryExpression;
				var BlockStatement = function () {
					function BlockStatement(body) {
						this.type = syntax_1.Syntax.BlockStatement;
						this.body = body;
					}
					return BlockStatement;
				}();
				exports.BlockStatement = BlockStatement;
				var BreakStatement = function () {
					function BreakStatement(label) {
						this.type = syntax_1.Syntax.BreakStatement;
						this.label = label;
					}
					return BreakStatement;
				}();
				exports.BreakStatement = BreakStatement;
				var CallExpression = function () {
					function CallExpression(callee, args) {
						this.type = syntax_1.Syntax.CallExpression;
						this.callee = callee;
						this.arguments = args;
					}
					return CallExpression;
				}();
				exports.CallExpression = CallExpression;
				var CatchClause = function () {
					function CatchClause(param, body) {
						this.type = syntax_1.Syntax.CatchClause;
						this.param = param;
						this.body = body;
					}
					return CatchClause;
				}();
				exports.CatchClause = CatchClause;
				var ClassBody = function () {
					function ClassBody(body) {
						this.type = syntax_1.Syntax.ClassBody;
						this.body = body;
					}
					return ClassBody;
				}();
				exports.ClassBody = ClassBody;
				var ClassDeclaration = function () {
					function ClassDeclaration(id, superClass, body) {
						this.type = syntax_1.Syntax.ClassDeclaration;
						this.id = id;
						this.superClass = superClass;
						this.body = body;
					}
					return ClassDeclaration;
				}();
				exports.ClassDeclaration = ClassDeclaration;
				var ClassExpression = function () {
					function ClassExpression(id, superClass, body) {
						this.type = syntax_1.Syntax.ClassExpression;
						this.id = id;
						this.superClass = superClass;
						this.body = body;
					}
					return ClassExpression;
				}();
				exports.ClassExpression = ClassExpression;
				var ComputedMemberExpression = function () {
					function ComputedMemberExpression(object, property) {
						this.type = syntax_1.Syntax.MemberExpression;
						this.computed = true;
						this.object = object;
						this.property = property;
					}
					return ComputedMemberExpression;
				}();
				exports.ComputedMemberExpression = ComputedMemberExpression;
				var ConditionalExpression = function () {
					function ConditionalExpression(test, consequent, alternate) {
						this.type = syntax_1.Syntax.ConditionalExpression;
						this.test = test;
						this.consequent = consequent;
						this.alternate = alternate;
					}
					return ConditionalExpression;
				}();
				exports.ConditionalExpression = ConditionalExpression;
				var ContinueStatement = function () {
					function ContinueStatement(label) {
						this.type = syntax_1.Syntax.ContinueStatement;
						this.label = label;
					}
					return ContinueStatement;
				}();
				exports.ContinueStatement = ContinueStatement;
				var DebuggerStatement = function () {
					function DebuggerStatement() {
						this.type = syntax_1.Syntax.DebuggerStatement;
					}
					return DebuggerStatement;
				}();
				exports.DebuggerStatement = DebuggerStatement;
				var Directive = function () {
					function Directive(expression, directive) {
						this.type = syntax_1.Syntax.ExpressionStatement;
						this.expression = expression;
						this.directive = directive;
					}
					return Directive;
				}();
				exports.Directive = Directive;
				var DoWhileStatement = function () {
					function DoWhileStatement(body, test) {
						this.type = syntax_1.Syntax.DoWhileStatement;
						this.body = body;
						this.test = test;
					}
					return DoWhileStatement;
				}();
				exports.DoWhileStatement = DoWhileStatement;
				var EmptyStatement = function () {
					function EmptyStatement() {
						this.type = syntax_1.Syntax.EmptyStatement;
					}
					return EmptyStatement;
				}();
				exports.EmptyStatement = EmptyStatement;
				var ExportAllDeclaration = function () {
					function ExportAllDeclaration(source) {
						this.type = syntax_1.Syntax.ExportAllDeclaration;
						this.source = source;
					}
					return ExportAllDeclaration;
				}();
				exports.ExportAllDeclaration = ExportAllDeclaration;
				var ExportDefaultDeclaration = function () {
					function ExportDefaultDeclaration(declaration) {
						this.type = syntax_1.Syntax.ExportDefaultDeclaration;
						this.declaration = declaration;
					}
					return ExportDefaultDeclaration;
				}();
				exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
				var ExportNamedDeclaration = function () {
					function ExportNamedDeclaration(declaration, specifiers, source) {
						this.type = syntax_1.Syntax.ExportNamedDeclaration;
						this.declaration = declaration;
						this.specifiers = specifiers;
						this.source = source;
					}
					return ExportNamedDeclaration;
				}();
				exports.ExportNamedDeclaration = ExportNamedDeclaration;
				var ExportSpecifier = function () {
					function ExportSpecifier(local, exported) {
						this.type = syntax_1.Syntax.ExportSpecifier;
						this.exported = exported;
						this.local = local;
					}
					return ExportSpecifier;
				}();
				exports.ExportSpecifier = ExportSpecifier;
				var ExpressionStatement = function () {
					function ExpressionStatement(expression) {
						this.type = syntax_1.Syntax.ExpressionStatement;
						this.expression = expression;
					}
					return ExpressionStatement;
				}();
				exports.ExpressionStatement = ExpressionStatement;
				var ForInStatement = function () {
					function ForInStatement(left, right, body) {
						this.type = syntax_1.Syntax.ForInStatement;
						this.left = left;
						this.right = right;
						this.body = body;
						this.each = false;
					}
					return ForInStatement;
				}();
				exports.ForInStatement = ForInStatement;
				var ForOfStatement = function () {
					function ForOfStatement(left, right, body) {
						this.type = syntax_1.Syntax.ForOfStatement;
						this.left = left;
						this.right = right;
						this.body = body;
					}
					return ForOfStatement;
				}();
				exports.ForOfStatement = ForOfStatement;
				var ForStatement = function () {
					function ForStatement(init, test, update, body) {
						this.type = syntax_1.Syntax.ForStatement;
						this.init = init;
						this.test = test;
						this.update = update;
						this.body = body;
					}
					return ForStatement;
				}();
				exports.ForStatement = ForStatement;
				var FunctionDeclaration = function () {
					function FunctionDeclaration(id, params, body, generator) {
						this.type = syntax_1.Syntax.FunctionDeclaration;
						this.id = id;
						this.params = params;
						this.body = body;
						this.generator = generator;
						this.expression = false;
					}
					return FunctionDeclaration;
				}();
				exports.FunctionDeclaration = FunctionDeclaration;
				var FunctionExpression = function () {
					function FunctionExpression(id, params, body, generator) {
						this.type = syntax_1.Syntax.FunctionExpression;
						this.id = id;
						this.params = params;
						this.body = body;
						this.generator = generator;
						this.expression = false;
					}
					return FunctionExpression;
				}();
				exports.FunctionExpression = FunctionExpression;
				var Identifier = function () {
					function Identifier(name) {
						this.type = syntax_1.Syntax.Identifier;
						this.name = name;
					}
					return Identifier;
				}();
				exports.Identifier = Identifier;
				var IfStatement = function () {
					function IfStatement(test, consequent, alternate) {
						this.type = syntax_1.Syntax.IfStatement;
						this.test = test;
						this.consequent = consequent;
						this.alternate = alternate;
					}
					return IfStatement;
				}();
				exports.IfStatement = IfStatement;
				var ImportDeclaration = function () {
					function ImportDeclaration(specifiers, source) {
						this.type = syntax_1.Syntax.ImportDeclaration;
						this.specifiers = specifiers;
						this.source = source;
					}
					return ImportDeclaration;
				}();
				exports.ImportDeclaration = ImportDeclaration;
				var ImportDefaultSpecifier = function () {
					function ImportDefaultSpecifier(local) {
						this.type = syntax_1.Syntax.ImportDefaultSpecifier;
						this.local = local;
					}
					return ImportDefaultSpecifier;
				}();
				exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
				var ImportNamespaceSpecifier = function () {
					function ImportNamespaceSpecifier(local) {
						this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
						this.local = local;
					}
					return ImportNamespaceSpecifier;
				}();
				exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
				var ImportSpecifier = function () {
					function ImportSpecifier(local, imported) {
						this.type = syntax_1.Syntax.ImportSpecifier;
						this.local = local;
						this.imported = imported;
					}
					return ImportSpecifier;
				}();
				exports.ImportSpecifier = ImportSpecifier;
				var LabeledStatement = function () {
					function LabeledStatement(label, body) {
						this.type = syntax_1.Syntax.LabeledStatement;
						this.label = label;
						this.body = body;
					}
					return LabeledStatement;
				}();
				exports.LabeledStatement = LabeledStatement;
				var Literal = function () {
					function Literal(value, raw) {
						this.type = syntax_1.Syntax.Literal;
						this.value = value;
						this.raw = raw;
					}
					return Literal;
				}();
				exports.Literal = Literal;
				var MetaProperty = function () {
					function MetaProperty(meta, property) {
						this.type = syntax_1.Syntax.MetaProperty;
						this.meta = meta;
						this.property = property;
					}
					return MetaProperty;
				}();
				exports.MetaProperty = MetaProperty;
				var MethodDefinition = function () {
					function MethodDefinition(key, computed, value, kind, isStatic) {
						this.type = syntax_1.Syntax.MethodDefinition;
						this.key = key;
						this.computed = computed;
						this.value = value;
						this.kind = kind;
						this.static = isStatic;
					}
					return MethodDefinition;
				}();
				exports.MethodDefinition = MethodDefinition;
				var NewExpression = function () {
					function NewExpression(callee, args) {
						this.type = syntax_1.Syntax.NewExpression;
						this.callee = callee;
						this.arguments = args;
					}
					return NewExpression;
				}();
				exports.NewExpression = NewExpression;
				var ObjectExpression = function () {
					function ObjectExpression(properties) {
						this.type = syntax_1.Syntax.ObjectExpression;
						this.properties = properties;
					}
					return ObjectExpression;
				}();
				exports.ObjectExpression = ObjectExpression;
				var ObjectPattern = function () {
					function ObjectPattern(properties) {
						this.type = syntax_1.Syntax.ObjectPattern;
						this.properties = properties;
					}
					return ObjectPattern;
				}();
				exports.ObjectPattern = ObjectPattern;
				var Program = function () {
					function Program(body, sourceType) {
						this.type = syntax_1.Syntax.Program;
						this.body = body;
						this.sourceType = sourceType;
					}
					return Program;
				}();
				exports.Program = Program;
				var Property = function () {
					function Property(kind, key, computed, value, method, shorthand) {
						this.type = syntax_1.Syntax.Property;
						this.key = key;
						this.computed = computed;
						this.value = value;
						this.kind = kind;
						this.method = method;
						this.shorthand = shorthand;
					}
					return Property;
				}();
				exports.Property = Property;
				var RegexLiteral = function () {
					function RegexLiteral(value, raw, regex) {
						this.type = syntax_1.Syntax.Literal;
						this.value = value;
						this.raw = raw;
						this.regex = regex;
					}
					return RegexLiteral;
				}();
				exports.RegexLiteral = RegexLiteral;
				var RestElement = function () {
					function RestElement(argument) {
						this.type = syntax_1.Syntax.RestElement;
						this.argument = argument;
					}
					return RestElement;
				}();
				exports.RestElement = RestElement;
				var ReturnStatement = function () {
					function ReturnStatement(argument) {
						this.type = syntax_1.Syntax.ReturnStatement;
						this.argument = argument;
					}
					return ReturnStatement;
				}();
				exports.ReturnStatement = ReturnStatement;
				var SequenceExpression = function () {
					function SequenceExpression(expressions) {
						this.type = syntax_1.Syntax.SequenceExpression;
						this.expressions = expressions;
					}
					return SequenceExpression;
				}();
				exports.SequenceExpression = SequenceExpression;
				var SpreadElement = function () {
					function SpreadElement(argument) {
						this.type = syntax_1.Syntax.SpreadElement;
						this.argument = argument;
					}
					return SpreadElement;
				}();
				exports.SpreadElement = SpreadElement;
				var StaticMemberExpression = function () {
					function StaticMemberExpression(object, property) {
						this.type = syntax_1.Syntax.MemberExpression;
						this.computed = false;
						this.object = object;
						this.property = property;
					}
					return StaticMemberExpression;
				}();
				exports.StaticMemberExpression = StaticMemberExpression;
				var Super = function () {
					function Super() {
						this.type = syntax_1.Syntax.Super;
					}
					return Super;
				}();
				exports.Super = Super;
				var SwitchCase = function () {
					function SwitchCase(test, consequent) {
						this.type = syntax_1.Syntax.SwitchCase;
						this.test = test;
						this.consequent = consequent;
					}
					return SwitchCase;
				}();
				exports.SwitchCase = SwitchCase;
				var SwitchStatement = function () {
					function SwitchStatement(discriminant, cases) {
						this.type = syntax_1.Syntax.SwitchStatement;
						this.discriminant = discriminant;
						this.cases = cases;
					}
					return SwitchStatement;
				}();
				exports.SwitchStatement = SwitchStatement;
				var TaggedTemplateExpression = function () {
					function TaggedTemplateExpression(tag, quasi) {
						this.type = syntax_1.Syntax.TaggedTemplateExpression;
						this.tag = tag;
						this.quasi = quasi;
					}
					return TaggedTemplateExpression;
				}();
				exports.TaggedTemplateExpression = TaggedTemplateExpression;
				var TemplateElement = function () {
					function TemplateElement(value, tail) {
						this.type = syntax_1.Syntax.TemplateElement;
						this.value = value;
						this.tail = tail;
					}
					return TemplateElement;
				}();
				exports.TemplateElement = TemplateElement;
				var TemplateLiteral = function () {
					function TemplateLiteral(quasis, expressions) {
						this.type = syntax_1.Syntax.TemplateLiteral;
						this.quasis = quasis;
						this.expressions = expressions;
					}
					return TemplateLiteral;
				}();
				exports.TemplateLiteral = TemplateLiteral;
				var ThisExpression = function () {
					function ThisExpression() {
						this.type = syntax_1.Syntax.ThisExpression;
					}
					return ThisExpression;
				}();
				exports.ThisExpression = ThisExpression;
				var ThrowStatement = function () {
					function ThrowStatement(argument) {
						this.type = syntax_1.Syntax.ThrowStatement;
						this.argument = argument;
					}
					return ThrowStatement;
				}();
				exports.ThrowStatement = ThrowStatement;
				var TryStatement = function () {
					function TryStatement(block, handler, finalizer) {
						this.type = syntax_1.Syntax.TryStatement;
						this.block = block;
						this.handler = handler;
						this.finalizer = finalizer;
					}
					return TryStatement;
				}();
				exports.TryStatement = TryStatement;
				var UnaryExpression = function () {
					function UnaryExpression(operator, argument) {
						this.type = syntax_1.Syntax.UnaryExpression;
						this.operator = operator;
						this.argument = argument;
						this.prefix = true;
					}
					return UnaryExpression;
				}();
				exports.UnaryExpression = UnaryExpression;
				var UpdateExpression = function () {
					function UpdateExpression(operator, argument, prefix) {
						this.type = syntax_1.Syntax.UpdateExpression;
						this.operator = operator;
						this.argument = argument;
						this.prefix = prefix;
					}
					return UpdateExpression;
				}();
				exports.UpdateExpression = UpdateExpression;
				var VariableDeclaration = function () {
					function VariableDeclaration(declarations, kind) {
						this.type = syntax_1.Syntax.VariableDeclaration;
						this.declarations = declarations;
						this.kind = kind;
					}
					return VariableDeclaration;
				}();
				exports.VariableDeclaration = VariableDeclaration;
				var VariableDeclarator = function () {
					function VariableDeclarator(id, init) {
						this.type = syntax_1.Syntax.VariableDeclarator;
						this.id = id;
						this.init = init;
					}
					return VariableDeclarator;
				}();
				exports.VariableDeclarator = VariableDeclarator;
				var WhileStatement = function () {
					function WhileStatement(test, body) {
						this.type = syntax_1.Syntax.WhileStatement;
						this.test = test;
						this.body = body;
					}
					return WhileStatement;
				}();
				exports.WhileStatement = WhileStatement;
				var WithStatement = function () {
					function WithStatement(object, body) {
						this.type = syntax_1.Syntax.WithStatement;
						this.object = object;
						this.body = body;
					}
					return WithStatement;
				}();
				exports.WithStatement = WithStatement;
				var YieldExpression = function () {
					function YieldExpression(argument, delegate) {
						this.type = syntax_1.Syntax.YieldExpression;
						this.argument = argument;
						this.delegate = delegate;
					}
					return YieldExpression;
				}();
				exports.YieldExpression = YieldExpression;

				/***/
			},
			/* 11 */
			/***/function (module, exports, __webpack_require__) {

				"use strict";
				/* istanbul ignore next */

				var __extends = this && this.__extends || function (d, b) {
					for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
					function __() {
						this.constructor = d;
					}
					d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
				};
				var character_1 = __webpack_require__(9);
				var token_1 = __webpack_require__(7);
				var parser_1 = __webpack_require__(3);
				var xhtml_entities_1 = __webpack_require__(12);
				var jsx_syntax_1 = __webpack_require__(13);
				var Node = __webpack_require__(10);
				var JSXNode = __webpack_require__(14);
				var JSXToken;
				(function (JSXToken) {
					JSXToken[JSXToken["Identifier"] = 100] = "Identifier";
					JSXToken[JSXToken["Text"] = 101] = "Text";
				})(JSXToken || (JSXToken = {}));
				token_1.TokenName[JSXToken.Identifier] = 'JSXIdentifier';
				token_1.TokenName[JSXToken.Text] = 'JSXText';
				// Fully qualified element name, e.g. <svg:path> returns "svg:path"
				function getQualifiedElementName(elementName) {
					var qualifiedName;
					switch (elementName.type) {
						case jsx_syntax_1.JSXSyntax.JSXIdentifier:
							var id = elementName;
							qualifiedName = id.name;
							break;
						case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
							var ns = elementName;
							qualifiedName = getQualifiedElementName(ns.namespace) + ':' + getQualifiedElementName(ns.name);
							break;
						case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
							var expr = elementName;
							qualifiedName = getQualifiedElementName(expr.object) + '.' + getQualifiedElementName(expr.property);
							break;
					}
					return qualifiedName;
				}
				var JSXParser = function (_super) {
					__extends(JSXParser, _super);
					function JSXParser(code, options, delegate) {
						_super.call(this, code, options, delegate);
					}
					JSXParser.prototype.parsePrimaryExpression = function () {
						return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
					};
					JSXParser.prototype.startJSX = function () {
						// Unwind the scanner before the lookahead token.
						this.scanner.index = this.startMarker.index;
						this.scanner.lineNumber = this.startMarker.lineNumber;
						this.scanner.lineStart = this.startMarker.lineStart;
					};
					JSXParser.prototype.finishJSX = function () {
						// Prime the next lookahead.
						this.nextToken();
					};
					JSXParser.prototype.reenterJSX = function () {
						this.startJSX();
						this.expectJSX('}');
						// Pop the closing '}' added from the lookahead.
						if (this.config.tokens) {
							this.tokens.pop();
						}
					};
					JSXParser.prototype.createJSXNode = function () {
						this.collectComments();
						return {
							index: this.scanner.index,
							line: this.scanner.lineNumber,
							column: this.scanner.index - this.scanner.lineStart
						};
					};
					JSXParser.prototype.createJSXChildNode = function () {
						return {
							index: this.scanner.index,
							line: this.scanner.lineNumber,
							column: this.scanner.index - this.scanner.lineStart
						};
					};
					JSXParser.prototype.scanXHTMLEntity = function (quote) {
						var result = '&';
						var valid = true;
						var terminated = false;
						var numeric = false;
						var hex = false;
						while (!this.scanner.eof() && valid && !terminated) {
							var ch = this.scanner.source[this.scanner.index];
							if (ch === quote) {
								break;
							}
							terminated = ch === ';';
							result += ch;
							++this.scanner.index;
							if (!terminated) {
								switch (result.length) {
									case 2:
										// e.g. '&#123;'
										numeric = ch === '#';
										break;
									case 3:
										if (numeric) {
											// e.g. '&#x41;'
											hex = ch === 'x';
											valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
											numeric = numeric && !hex;
										}
										break;
									default:
										valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
										valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
										break;
								}
							}
						}
						if (valid && terminated && result.length > 2) {
							// e.g. '&#x41;' becomes just '#x41'
							var str = result.substr(1, result.length - 2);
							if (numeric && str.length > 1) {
								result = String.fromCharCode(parseInt(str.substr(1), 10));
							} else if (hex && str.length > 2) {
								result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
							} else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
								result = xhtml_entities_1.XHTMLEntities[str];
							}
						}
						return result;
					};
					// Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
					JSXParser.prototype.lexJSX = function () {
						var cp = this.scanner.source.charCodeAt(this.scanner.index);
						// < > / : = { }
						if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
							var value = this.scanner.source[this.scanner.index++];
							return {
								type: token_1.Token.Punctuator,
								value: value,
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start: this.scanner.index - 1,
								end: this.scanner.index
							};
						}
						// " '
						if (cp === 34 || cp === 39) {
							var start = this.scanner.index;
							var quote = this.scanner.source[this.scanner.index++];
							var str = '';
							while (!this.scanner.eof()) {
								var ch = this.scanner.source[this.scanner.index++];
								if (ch === quote) {
									break;
								} else if (ch === '&') {
									str += this.scanXHTMLEntity(quote);
								} else {
									str += ch;
								}
							}
							return {
								type: token_1.Token.StringLiteral,
								value: str,
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start: start,
								end: this.scanner.index
							};
						}
						// ... or .
						if (cp === 46) {
							var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
							var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
							var value = n1 === 46 && n2 === 46 ? '...' : '.';
							var start = this.scanner.index;
							this.scanner.index += value.length;
							return {
								type: token_1.Token.Punctuator,
								value: value,
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start: start,
								end: this.scanner.index
							};
						}
						// `
						if (cp === 96) {
							// Only placeholder, since it will be rescanned as a real assignment expression.
							return {
								type: token_1.Token.Template,
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start: this.scanner.index,
								end: this.scanner.index
							};
						}
						// Identifer can not contain backslash (char code 92).
						if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
							var start = this.scanner.index;
							++this.scanner.index;
							while (!this.scanner.eof()) {
								var ch = this.scanner.source.charCodeAt(this.scanner.index);
								if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
									++this.scanner.index;
								} else if (ch === 45) {
									// Hyphen (char code 45) can be part of an identifier.
									++this.scanner.index;
								} else {
									break;
								}
							}
							var id = this.scanner.source.slice(start, this.scanner.index);
							return {
								type: JSXToken.Identifier,
								value: id,
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start: start,
								end: this.scanner.index
							};
						}
						this.scanner.throwUnexpectedToken();
					};
					JSXParser.prototype.nextJSXToken = function () {
						this.collectComments();
						this.startMarker.index = this.scanner.index;
						this.startMarker.lineNumber = this.scanner.lineNumber;
						this.startMarker.lineStart = this.scanner.lineStart;
						var token = this.lexJSX();
						this.lastMarker.index = this.scanner.index;
						this.lastMarker.lineNumber = this.scanner.lineNumber;
						this.lastMarker.lineStart = this.scanner.lineStart;
						if (this.config.tokens) {
							this.tokens.push(this.convertToken(token));
						}
						return token;
					};
					JSXParser.prototype.nextJSXText = function () {
						this.startMarker.index = this.scanner.index;
						this.startMarker.lineNumber = this.scanner.lineNumber;
						this.startMarker.lineStart = this.scanner.lineStart;
						var start = this.scanner.index;
						var text = '';
						while (!this.scanner.eof()) {
							var ch = this.scanner.source[this.scanner.index];
							if (ch === '{' || ch === '<') {
								break;
							}
							++this.scanner.index;
							text += ch;
							if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								++this.scanner.lineNumber;
								if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
									++this.scanner.index;
								}
								this.scanner.lineStart = this.scanner.index;
							}
						}
						this.lastMarker.index = this.scanner.index;
						this.lastMarker.lineNumber = this.scanner.lineNumber;
						this.lastMarker.lineStart = this.scanner.lineStart;
						var token = {
							type: JSXToken.Text,
							value: text,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
						if (text.length > 0 && this.config.tokens) {
							this.tokens.push(this.convertToken(token));
						}
						return token;
					};
					JSXParser.prototype.peekJSXToken = function () {
						var previousIndex = this.scanner.index;
						var previousLineNumber = this.scanner.lineNumber;
						var previousLineStart = this.scanner.lineStart;
						this.scanner.scanComments();
						var next = this.lexJSX();
						this.scanner.index = previousIndex;
						this.scanner.lineNumber = previousLineNumber;
						this.scanner.lineStart = previousLineStart;
						return next;
					};
					// Expect the next JSX token to match the specified punctuator.
					// If not, an exception will be thrown.
					JSXParser.prototype.expectJSX = function (value) {
						var token = this.nextJSXToken();
						if (token.type !== token_1.Token.Punctuator || token.value !== value) {
							this.throwUnexpectedToken(token);
						}
					};
					// Return true if the next JSX token matches the specified punctuator.
					JSXParser.prototype.matchJSX = function (value) {
						var next = this.peekJSXToken();
						return next.type === token_1.Token.Punctuator && next.value === value;
					};
					JSXParser.prototype.parseJSXIdentifier = function () {
						var node = this.createJSXNode();
						var token = this.nextJSXToken();
						if (token.type !== JSXToken.Identifier) {
							this.throwUnexpectedToken(token);
						}
						return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
					};
					JSXParser.prototype.parseJSXElementName = function () {
						var node = this.createJSXNode();
						var elementName = this.parseJSXIdentifier();
						if (this.matchJSX(':')) {
							var namespace = elementName;
							this.expectJSX(':');
							var name_1 = this.parseJSXIdentifier();
							elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
						} else if (this.matchJSX('.')) {
							while (this.matchJSX('.')) {
								var object = elementName;
								this.expectJSX('.');
								var property = this.parseJSXIdentifier();
								elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
							}
						}
						return elementName;
					};
					JSXParser.prototype.parseJSXAttributeName = function () {
						var node = this.createJSXNode();
						var attributeName;
						var identifier = this.parseJSXIdentifier();
						if (this.matchJSX(':')) {
							var namespace = identifier;
							this.expectJSX(':');
							var name_2 = this.parseJSXIdentifier();
							attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
						} else {
							attributeName = identifier;
						}
						return attributeName;
					};
					JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
						var node = this.createJSXNode();
						var token = this.nextJSXToken();
						if (token.type !== token_1.Token.StringLiteral) {
							this.throwUnexpectedToken(token);
						}
						var raw = this.getTokenRaw(token);
						return this.finalize(node, new Node.Literal(token.value, raw));
					};
					JSXParser.prototype.parseJSXExpressionAttribute = function () {
						var node = this.createJSXNode();
						this.expectJSX('{');
						this.finishJSX();
						if (this.match('}')) {
							this.tolerateError('JSX attributes must only be assigned a non-empty expression');
						}
						var expression = this.parseAssignmentExpression();
						this.reenterJSX();
						return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
					};
					JSXParser.prototype.parseJSXAttributeValue = function () {
						return this.matchJSX('{') ? this.parseJSXExpressionAttribute() : this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
					};
					JSXParser.prototype.parseJSXNameValueAttribute = function () {
						var node = this.createJSXNode();
						var name = this.parseJSXAttributeName();
						var value = null;
						if (this.matchJSX('=')) {
							this.expectJSX('=');
							value = this.parseJSXAttributeValue();
						}
						return this.finalize(node, new JSXNode.JSXAttribute(name, value));
					};
					JSXParser.prototype.parseJSXSpreadAttribute = function () {
						var node = this.createJSXNode();
						this.expectJSX('{');
						this.expectJSX('...');
						this.finishJSX();
						var argument = this.parseAssignmentExpression();
						this.reenterJSX();
						return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
					};
					JSXParser.prototype.parseJSXAttributes = function () {
						var attributes = [];
						while (!this.matchJSX('/') && !this.matchJSX('>')) {
							var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
							attributes.push(attribute);
						}
						return attributes;
					};
					JSXParser.prototype.parseJSXOpeningElement = function () {
						var node = this.createJSXNode();
						this.expectJSX('<');
						var name = this.parseJSXElementName();
						var attributes = this.parseJSXAttributes();
						var selfClosing = this.matchJSX('/');
						if (selfClosing) {
							this.expectJSX('/');
						}
						this.expectJSX('>');
						return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
					};
					JSXParser.prototype.parseJSXBoundaryElement = function () {
						var node = this.createJSXNode();
						this.expectJSX('<');
						if (this.matchJSX('/')) {
							this.expectJSX('/');
							var name_3 = this.parseJSXElementName();
							this.expectJSX('>');
							return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
						}
						var name = this.parseJSXElementName();
						var attributes = this.parseJSXAttributes();
						var selfClosing = this.matchJSX('/');
						if (selfClosing) {
							this.expectJSX('/');
						}
						this.expectJSX('>');
						return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
					};
					JSXParser.prototype.parseJSXEmptyExpression = function () {
						var node = this.createJSXChildNode();
						this.collectComments();
						this.lastMarker.index = this.scanner.index;
						this.lastMarker.lineNumber = this.scanner.lineNumber;
						this.lastMarker.lineStart = this.scanner.lineStart;
						return this.finalize(node, new JSXNode.JSXEmptyExpression());
					};
					JSXParser.prototype.parseJSXExpressionContainer = function () {
						var node = this.createJSXNode();
						this.expectJSX('{');
						var expression;
						if (this.matchJSX('}')) {
							expression = this.parseJSXEmptyExpression();
							this.expectJSX('}');
						} else {
							this.finishJSX();
							expression = this.parseAssignmentExpression();
							this.reenterJSX();
						}
						return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
					};
					JSXParser.prototype.parseJSXChildren = function () {
						var children = [];
						while (!this.scanner.eof()) {
							var node = this.createJSXChildNode();
							var token = this.nextJSXText();
							if (token.start < token.end) {
								var raw = this.getTokenRaw(token);
								var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
								children.push(child);
							}
							if (this.scanner.source[this.scanner.index] === '{') {
								var container = this.parseJSXExpressionContainer();
								children.push(container);
							} else {
								break;
							}
						}
						return children;
					};
					JSXParser.prototype.parseComplexJSXElement = function (el) {
						var stack = [];
						while (!this.scanner.eof()) {
							el.children = el.children.concat(this.parseJSXChildren());
							var node = this.createJSXChildNode();
							var element = this.parseJSXBoundaryElement();
							if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
								var opening = element;
								if (opening.selfClosing) {
									var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
									el.children.push(child);
								} else {
									stack.push(el);
									el = { node: node, opening: opening, closing: null, children: [] };
								}
							}
							if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
								el.closing = element;
								var open_1 = getQualifiedElementName(el.opening.name);
								var close_1 = getQualifiedElementName(el.closing.name);
								if (open_1 !== close_1) {
									this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
								}
								if (stack.length > 0) {
									var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
									el = stack.pop();
									el.children.push(child);
								} else {
									break;
								}
							}
						}
						return el;
					};
					JSXParser.prototype.parseJSXElement = function () {
						var node = this.createJSXNode();
						var opening = this.parseJSXOpeningElement();
						var children = [];
						var closing = null;
						if (!opening.selfClosing) {
							var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
							children = el.children;
							closing = el.closing;
						}
						return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
					};
					JSXParser.prototype.parseJSXRoot = function () {
						// Pop the opening '<' added from the lookahead.
						if (this.config.tokens) {
							this.tokens.pop();
						}
						this.startJSX();
						var element = this.parseJSXElement();
						this.finishJSX();
						return element;
					};
					return JSXParser;
				}(parser_1.Parser);
				exports.JSXParser = JSXParser;

				/***/
			},
			/* 12 */
			/***/function (module, exports) {

				// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
				"use strict";

				exports.XHTMLEntities = {
					quot: '\u0022',
					amp: '\u0026',
					apos: '\u0027',
					gt: '\u003E',
					nbsp: '\u00A0',
					iexcl: '\u00A1',
					cent: '\u00A2',
					pound: '\u00A3',
					curren: '\u00A4',
					yen: '\u00A5',
					brvbar: '\u00A6',
					sect: '\u00A7',
					uml: '\u00A8',
					copy: '\u00A9',
					ordf: '\u00AA',
					laquo: '\u00AB',
					not: '\u00AC',
					shy: '\u00AD',
					reg: '\u00AE',
					macr: '\u00AF',
					deg: '\u00B0',
					plusmn: '\u00B1',
					sup2: '\u00B2',
					sup3: '\u00B3',
					acute: '\u00B4',
					micro: '\u00B5',
					para: '\u00B6',
					middot: '\u00B7',
					cedil: '\u00B8',
					sup1: '\u00B9',
					ordm: '\u00BA',
					raquo: '\u00BB',
					frac14: '\u00BC',
					frac12: '\u00BD',
					frac34: '\u00BE',
					iquest: '\u00BF',
					Agrave: '\u00C0',
					Aacute: '\u00C1',
					Acirc: '\u00C2',
					Atilde: '\u00C3',
					Auml: '\u00C4',
					Aring: '\u00C5',
					AElig: '\u00C6',
					Ccedil: '\u00C7',
					Egrave: '\u00C8',
					Eacute: '\u00C9',
					Ecirc: '\u00CA',
					Euml: '\u00CB',
					Igrave: '\u00CC',
					Iacute: '\u00CD',
					Icirc: '\u00CE',
					Iuml: '\u00CF',
					ETH: '\u00D0',
					Ntilde: '\u00D1',
					Ograve: '\u00D2',
					Oacute: '\u00D3',
					Ocirc: '\u00D4',
					Otilde: '\u00D5',
					Ouml: '\u00D6',
					times: '\u00D7',
					Oslash: '\u00D8',
					Ugrave: '\u00D9',
					Uacute: '\u00DA',
					Ucirc: '\u00DB',
					Uuml: '\u00DC',
					Yacute: '\u00DD',
					THORN: '\u00DE',
					szlig: '\u00DF',
					agrave: '\u00E0',
					aacute: '\u00E1',
					acirc: '\u00E2',
					atilde: '\u00E3',
					auml: '\u00E4',
					aring: '\u00E5',
					aelig: '\u00E6',
					ccedil: '\u00E7',
					egrave: '\u00E8',
					eacute: '\u00E9',
					ecirc: '\u00EA',
					euml: '\u00EB',
					igrave: '\u00EC',
					iacute: '\u00ED',
					icirc: '\u00EE',
					iuml: '\u00EF',
					eth: '\u00F0',
					ntilde: '\u00F1',
					ograve: '\u00F2',
					oacute: '\u00F3',
					ocirc: '\u00F4',
					otilde: '\u00F5',
					ouml: '\u00F6',
					divide: '\u00F7',
					oslash: '\u00F8',
					ugrave: '\u00F9',
					uacute: '\u00FA',
					ucirc: '\u00FB',
					uuml: '\u00FC',
					yacute: '\u00FD',
					thorn: '\u00FE',
					yuml: '\u00FF',
					OElig: '\u0152',
					oelig: '\u0153',
					Scaron: '\u0160',
					scaron: '\u0161',
					Yuml: '\u0178',
					fnof: '\u0192',
					circ: '\u02C6',
					tilde: '\u02DC',
					Alpha: '\u0391',
					Beta: '\u0392',
					Gamma: '\u0393',
					Delta: '\u0394',
					Epsilon: '\u0395',
					Zeta: '\u0396',
					Eta: '\u0397',
					Theta: '\u0398',
					Iota: '\u0399',
					Kappa: '\u039A',
					Lambda: '\u039B',
					Mu: '\u039C',
					Nu: '\u039D',
					Xi: '\u039E',
					Omicron: '\u039F',
					Pi: '\u03A0',
					Rho: '\u03A1',
					Sigma: '\u03A3',
					Tau: '\u03A4',
					Upsilon: '\u03A5',
					Phi: '\u03A6',
					Chi: '\u03A7',
					Psi: '\u03A8',
					Omega: '\u03A9',
					alpha: '\u03B1',
					beta: '\u03B2',
					gamma: '\u03B3',
					delta: '\u03B4',
					epsilon: '\u03B5',
					zeta: '\u03B6',
					eta: '\u03B7',
					theta: '\u03B8',
					iota: '\u03B9',
					kappa: '\u03BA',
					lambda: '\u03BB',
					mu: '\u03BC',
					nu: '\u03BD',
					xi: '\u03BE',
					omicron: '\u03BF',
					pi: '\u03C0',
					rho: '\u03C1',
					sigmaf: '\u03C2',
					sigma: '\u03C3',
					tau: '\u03C4',
					upsilon: '\u03C5',
					phi: '\u03C6',
					chi: '\u03C7',
					psi: '\u03C8',
					omega: '\u03C9',
					thetasym: '\u03D1',
					upsih: '\u03D2',
					piv: '\u03D6',
					ensp: '\u2002',
					emsp: '\u2003',
					thinsp: '\u2009',
					zwnj: '\u200C',
					zwj: '\u200D',
					lrm: '\u200E',
					rlm: '\u200F',
					ndash: '\u2013',
					mdash: '\u2014',
					lsquo: '\u2018',
					rsquo: '\u2019',
					sbquo: '\u201A',
					ldquo: '\u201C',
					rdquo: '\u201D',
					bdquo: '\u201E',
					dagger: '\u2020',
					Dagger: '\u2021',
					bull: '\u2022',
					hellip: '\u2026',
					permil: '\u2030',
					prime: '\u2032',
					Prime: '\u2033',
					lsaquo: '\u2039',
					rsaquo: '\u203A',
					oline: '\u203E',
					frasl: '\u2044',
					euro: '\u20AC',
					image: '\u2111',
					weierp: '\u2118',
					real: '\u211C',
					trade: '\u2122',
					alefsym: '\u2135',
					larr: '\u2190',
					uarr: '\u2191',
					rarr: '\u2192',
					darr: '\u2193',
					harr: '\u2194',
					crarr: '\u21B5',
					lArr: '\u21D0',
					uArr: '\u21D1',
					rArr: '\u21D2',
					dArr: '\u21D3',
					hArr: '\u21D4',
					forall: '\u2200',
					part: '\u2202',
					exist: '\u2203',
					empty: '\u2205',
					nabla: '\u2207',
					isin: '\u2208',
					notin: '\u2209',
					ni: '\u220B',
					prod: '\u220F',
					sum: '\u2211',
					minus: '\u2212',
					lowast: '\u2217',
					radic: '\u221A',
					prop: '\u221D',
					infin: '\u221E',
					ang: '\u2220',
					and: '\u2227',
					or: '\u2228',
					cap: '\u2229',
					cup: '\u222A',
					int: '\u222B',
					there4: '\u2234',
					sim: '\u223C',
					cong: '\u2245',
					asymp: '\u2248',
					ne: '\u2260',
					equiv: '\u2261',
					le: '\u2264',
					ge: '\u2265',
					sub: '\u2282',
					sup: '\u2283',
					nsub: '\u2284',
					sube: '\u2286',
					supe: '\u2287',
					oplus: '\u2295',
					otimes: '\u2297',
					perp: '\u22A5',
					sdot: '\u22C5',
					lceil: '\u2308',
					rceil: '\u2309',
					lfloor: '\u230A',
					rfloor: '\u230B',
					loz: '\u25CA',
					spades: '\u2660',
					clubs: '\u2663',
					hearts: '\u2665',
					diams: '\u2666',
					lang: '\u27E8',
					rang: '\u27E9'
				};

				/***/
			},
			/* 13 */
			/***/function (module, exports) {

				"use strict";

				exports.JSXSyntax = {
					JSXAttribute: 'JSXAttribute',
					JSXClosingElement: 'JSXClosingElement',
					JSXElement: 'JSXElement',
					JSXEmptyExpression: 'JSXEmptyExpression',
					JSXExpressionContainer: 'JSXExpressionContainer',
					JSXIdentifier: 'JSXIdentifier',
					JSXMemberExpression: 'JSXMemberExpression',
					JSXNamespacedName: 'JSXNamespacedName',
					JSXOpeningElement: 'JSXOpeningElement',
					JSXSpreadAttribute: 'JSXSpreadAttribute',
					JSXText: 'JSXText'
				};

				/***/
			},
			/* 14 */
			/***/function (module, exports, __webpack_require__) {

				"use strict";

				var jsx_syntax_1 = __webpack_require__(13);
				var JSXClosingElement = function () {
					function JSXClosingElement(name) {
						this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
						this.name = name;
					}
					return JSXClosingElement;
				}();
				exports.JSXClosingElement = JSXClosingElement;
				var JSXElement = function () {
					function JSXElement(openingElement, children, closingElement) {
						this.type = jsx_syntax_1.JSXSyntax.JSXElement;
						this.openingElement = openingElement;
						this.children = children;
						this.closingElement = closingElement;
					}
					return JSXElement;
				}();
				exports.JSXElement = JSXElement;
				var JSXEmptyExpression = function () {
					function JSXEmptyExpression() {
						this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
					}
					return JSXEmptyExpression;
				}();
				exports.JSXEmptyExpression = JSXEmptyExpression;
				var JSXExpressionContainer = function () {
					function JSXExpressionContainer(expression) {
						this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
						this.expression = expression;
					}
					return JSXExpressionContainer;
				}();
				exports.JSXExpressionContainer = JSXExpressionContainer;
				var JSXIdentifier = function () {
					function JSXIdentifier(name) {
						this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
						this.name = name;
					}
					return JSXIdentifier;
				}();
				exports.JSXIdentifier = JSXIdentifier;
				var JSXMemberExpression = function () {
					function JSXMemberExpression(object, property) {
						this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
						this.object = object;
						this.property = property;
					}
					return JSXMemberExpression;
				}();
				exports.JSXMemberExpression = JSXMemberExpression;
				var JSXAttribute = function () {
					function JSXAttribute(name, value) {
						this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
						this.name = name;
						this.value = value;
					}
					return JSXAttribute;
				}();
				exports.JSXAttribute = JSXAttribute;
				var JSXNamespacedName = function () {
					function JSXNamespacedName(namespace, name) {
						this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
						this.namespace = namespace;
						this.name = name;
					}
					return JSXNamespacedName;
				}();
				exports.JSXNamespacedName = JSXNamespacedName;
				var JSXOpeningElement = function () {
					function JSXOpeningElement(name, selfClosing, attributes) {
						this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
						this.name = name;
						this.selfClosing = selfClosing;
						this.attributes = attributes;
					}
					return JSXOpeningElement;
				}();
				exports.JSXOpeningElement = JSXOpeningElement;
				var JSXSpreadAttribute = function () {
					function JSXSpreadAttribute(argument) {
						this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
						this.argument = argument;
					}
					return JSXSpreadAttribute;
				}();
				exports.JSXSpreadAttribute = JSXSpreadAttribute;
				var JSXText = function () {
					function JSXText(value, raw) {
						this.type = jsx_syntax_1.JSXSyntax.JSXText;
						this.value = value;
						this.raw = raw;
					}
					return JSXText;
				}();
				exports.JSXText = JSXText;

				/***/
			},
			/* 15 */
			/***/function (module, exports, __webpack_require__) {

				"use strict";

				var scanner_1 = __webpack_require__(8);
				var error_handler_1 = __webpack_require__(6);
				var token_1 = __webpack_require__(7);
				var Reader = function () {
					function Reader() {
						this.values = [];
						this.curly = this.paren = -1;
					}
					;
					// A function following one of those tokens is an expression.
					Reader.prototype.beforeFunctionExpression = function (t) {
						return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void',
						// assignment operators
						'=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',',
						// binary/unary operators
						'+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
					};
					;
					// Determine if forward slash (/) is an operator or part of a regular expression
					// https://github.com/mozilla/sweet.js/wiki/design
					Reader.prototype.isRegexStart = function () {
						var previous = this.values[this.values.length - 1];
						var regex = previous !== null;
						switch (previous) {
							case 'this':
							case ']':
								regex = false;
								break;
							case ')':
								var check = this.values[this.paren - 1];
								regex = check === 'if' || check === 'while' || check === 'for' || check === 'with';
								break;
							case '}':
								// Dividing a function by anything makes little sense,
								// but we have to check for that.
								regex = false;
								if (this.values[this.curly - 3] === 'function') {
									// Anonymous function, e.g. function(){} /42
									var check_1 = this.values[this.curly - 4];
									regex = check_1 ? !this.beforeFunctionExpression(check_1) : false;
								} else if (this.values[this.curly - 4] === 'function') {
									// Named function, e.g. function f(){} /42/
									var check_2 = this.values[this.curly - 5];
									regex = check_2 ? !this.beforeFunctionExpression(check_2) : true;
								}
						}
						return regex;
					};
					;
					Reader.prototype.push = function (token) {
						if (token.type === token_1.Token.Punctuator || token.type === token_1.Token.Keyword) {
							if (token.value === '{') {
								this.curly = this.values.length;
							} else if (token.value === '(') {
								this.paren = this.values.length;
							}
							this.values.push(token.value);
						} else {
							this.values.push(null);
						}
					};
					;
					return Reader;
				}();
				var Tokenizer = function () {
					function Tokenizer(code, config) {
						this.errorHandler = new error_handler_1.ErrorHandler();
						this.errorHandler.tolerant = config ? typeof config.tolerant === 'boolean' && config.tolerant : false;
						this.scanner = new scanner_1.Scanner(code, this.errorHandler);
						this.scanner.trackComment = config ? typeof config.comment === 'boolean' && config.comment : false;
						this.trackRange = config ? typeof config.range === 'boolean' && config.range : false;
						this.trackLoc = config ? typeof config.loc === 'boolean' && config.loc : false;
						this.buffer = [];
						this.reader = new Reader();
					}
					;
					Tokenizer.prototype.errors = function () {
						return this.errorHandler.errors;
					};
					;
					Tokenizer.prototype.getNextToken = function () {
						if (this.buffer.length === 0) {
							var comments = this.scanner.scanComments();
							if (this.scanner.trackComment) {
								for (var i = 0; i < comments.length; ++i) {
									var e = comments[i];
									var comment = void 0;
									var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
									comment = {
										type: e.multiLine ? 'BlockComment' : 'LineComment',
										value: value
									};
									if (this.trackRange) {
										comment.range = e.range;
									}
									if (this.trackLoc) {
										comment.loc = e.loc;
									}
									this.buffer.push(comment);
								}
							}
							if (!this.scanner.eof()) {
								var loc = void 0;
								if (this.trackLoc) {
									loc = {
										start: {
											line: this.scanner.lineNumber,
											column: this.scanner.index - this.scanner.lineStart
										},
										end: {}
									};
								}
								var token = void 0;
								if (this.scanner.source[this.scanner.index] === '/') {
									token = this.reader.isRegexStart() ? this.scanner.scanRegExp() : this.scanner.scanPunctuator();
								} else {
									token = this.scanner.lex();
								}
								this.reader.push(token);
								var entry = void 0;
								entry = {
									type: token_1.TokenName[token.type],
									value: this.scanner.source.slice(token.start, token.end)
								};
								if (this.trackRange) {
									entry.range = [token.start, token.end];
								}
								if (this.trackLoc) {
									loc.end = {
										line: this.scanner.lineNumber,
										column: this.scanner.index - this.scanner.lineStart
									};
									entry.loc = loc;
								}
								if (token.regex) {
									entry.regex = token.regex;
								}
								this.buffer.push(entry);
							}
						}
						return this.buffer.shift();
					};
					;
					return Tokenizer;
				}();
				exports.Tokenizer = Tokenizer;

				/***/
			}
			/******/])
		);
	});
	;
});
System.registerDynamic("npm:esprima@3.1.2.js", ["npm:esprima@3.1.2/dist/esprima.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:esprima@3.1.2/dist/esprima.js");
});
System.registerDynamic('npm:os-browserify@0.1.2/browser.js', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    exports.endianness = function () {
        return 'LE';
    };

    exports.hostname = function () {
        if (typeof location !== 'undefined') {
            return location.hostname;
        } else return '';
    };

    exports.loadavg = function () {
        return [];
    };

    exports.uptime = function () {
        return 0;
    };

    exports.freemem = function () {
        return Number.MAX_VALUE;
    };

    exports.totalmem = function () {
        return Number.MAX_VALUE;
    };

    exports.cpus = function () {
        return [];
    };

    exports.type = function () {
        return 'Browser';
    };

    exports.release = function () {
        if (typeof navigator !== 'undefined') {
            return navigator.appVersion;
        }
        return '';
    };

    exports.networkInterfaces = exports.getNetworkInterfaces = function () {
        return {};
    };

    exports.arch = function () {
        return 'javascript';
    };

    exports.platform = function () {
        return 'browser';
    };

    exports.tmpdir = exports.tmpDir = function () {
        return '/tmp';
    };

    exports.EOL = '\n';
});
System.registerDynamic("npm:os-browserify@0.1.2.js", ["npm:os-browserify@0.1.2/browser.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:os-browserify@0.1.2/browser.js");
});
System.registerDynamic('github:jspm/nodelibs-os@0.1.0/index.js', ['npm:os-browserify@0.1.2.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = System._nodeRequire ? System._nodeRequire('os') : $__require('npm:os-browserify@0.1.2.js');
});
System.registerDynamic("github:jspm/nodelibs-os@0.1.0.js", ["github:jspm/nodelibs-os@0.1.0/index.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("github:jspm/nodelibs-os@0.1.0/index.js");
});
System.registerDynamic('npm:recast@0.11.18/lib/options.js', ['npm:esprima@3.1.2.js', 'github:jspm/nodelibs-os@0.1.0.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var defaults = {
    parser: $__require('npm:esprima@3.1.2.js'),
    tabWidth: 4,
    useTabs: false,
    reuseWhitespace: true,
    lineTerminator: $__require('github:jspm/nodelibs-os@0.1.0.js').EOL,
    wrapColumn: 74,
    sourceFileName: null,
    sourceMapName: null,
    sourceRoot: null,
    inputSourceMap: null,
    range: false,
    tolerant: true,
    quote: null,
    trailingComma: false,
    arrayBracketSpacing: false,
    objectCurlySpacing: true,
    arrowParensAlways: false,
    flowObjectCommas: true
  },
      hasOwn = defaults.hasOwnProperty;
  exports.normalize = function (options) {
    options = options || defaults;
    function get(key) {
      return hasOwn.call(options, key) ? options[key] : defaults[key];
    }
    return {
      tabWidth: +get("tabWidth"),
      useTabs: !!get("useTabs"),
      reuseWhitespace: !!get("reuseWhitespace"),
      lineTerminator: get("lineTerminator"),
      wrapColumn: Math.max(get("wrapColumn"), 0),
      sourceFileName: get("sourceFileName"),
      sourceMapName: get("sourceMapName"),
      sourceRoot: get("sourceRoot"),
      inputSourceMap: get("inputSourceMap"),
      parser: get("esprima") || get("parser"),
      range: get("range"),
      tolerant: get("tolerant"),
      quote: get("quote"),
      trailingComma: get("trailingComma"),
      arrayBracketSpacing: get("arrayBracketSpacing"),
      objectCurlySpacing: get("objectCurlySpacing"),
      arrowParensAlways: get("arrowParensAlways"),
      flowObjectCommas: get("flowObjectCommas")
    };
  };
});
System.registerDynamic("npm:private@0.1.6/private.js", [], true, function ($__require, exports, module) {
  /* */
  "format cjs";
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var originalObject = Object;
  var originalDefProp = Object.defineProperty;
  var originalCreate = Object.create;

  function defProp(obj, name, value) {
    if (originalDefProp) try {
      originalDefProp.call(originalObject, obj, name, { value: value });
    } catch (definePropertyIsBrokenInIE8) {
      obj[name] = value;
    } else {
      obj[name] = value;
    }
  }

  // For functions that will be invoked using .call or .apply, we need to
  // define those methods on the function objects themselves, rather than
  // inheriting them from Function.prototype, so that a malicious or clumsy
  // third party cannot interfere with the functionality of this module by
  // redefining Function.prototype.call or .apply.
  function makeSafeToCall(fun) {
    if (fun) {
      defProp(fun, "call", fun.call);
      defProp(fun, "apply", fun.apply);
    }
    return fun;
  }

  makeSafeToCall(originalDefProp);
  makeSafeToCall(originalCreate);

  var hasOwn = makeSafeToCall(Object.prototype.hasOwnProperty);
  var numToStr = makeSafeToCall(Number.prototype.toString);
  var strSlice = makeSafeToCall(String.prototype.slice);

  var cloner = function () {};
  function create(prototype) {
    if (originalCreate) {
      return originalCreate.call(originalObject, prototype);
    }
    cloner.prototype = prototype || null;
    return new cloner();
  }

  var rand = Math.random;
  var uniqueKeys = create(null);

  function makeUniqueKey() {
    // Collisions are highly unlikely, but this module is in the business of
    // making guarantees rather than safe bets.
    do var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2)); while (hasOwn.call(uniqueKeys, uniqueKey));
    return uniqueKeys[uniqueKey] = uniqueKey;
  }

  function internString(str) {
    var obj = {};
    obj[str] = true;
    return Object.keys(obj)[0];
  }

  // External users might find this function useful, but it is not necessary
  // for the typical use of this module.
  defProp(exports, "makeUniqueKey", makeUniqueKey);

  // Object.getOwnPropertyNames is the only way to enumerate non-enumerable
  // properties, so if we wrap it to ignore our secret keys, there should be
  // no way (except guessing) to access those properties.
  var originalGetOPNs = Object.getOwnPropertyNames;
  Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
    for (var names = originalGetOPNs(object), src = 0, dst = 0, len = names.length; src < len; ++src) {
      if (!hasOwn.call(uniqueKeys, names[src])) {
        if (src > dst) {
          names[dst] = names[src];
        }
        ++dst;
      }
    }
    names.length = dst;
    return names;
  };

  function defaultCreatorFn(object) {
    return create(null);
  }

  function makeAccessor(secretCreatorFn) {
    var brand = makeUniqueKey();
    var passkey = create(null);

    secretCreatorFn = secretCreatorFn || defaultCreatorFn;

    function register(object) {
      var secret; // Created lazily.

      function vault(key, forget) {
        // Only code that has access to the passkey can retrieve (or forget)
        // the secret object.
        if (key === passkey) {
          return forget ? secret = null : secret || (secret = secretCreatorFn(object));
        }
      }

      defProp(object, brand, vault);
    }

    function accessor(object) {
      if (!hasOwn.call(object, brand)) register(object);
      return object[brand](passkey);
    }

    accessor.forget = function (object) {
      if (hasOwn.call(object, brand)) object[brand](passkey, true);
    };

    return accessor;
  }

  defProp(exports, "makeAccessor", makeAccessor);
});
System.registerDynamic("npm:private@0.1.6.js", ["npm:private@0.1.6/private.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:private@0.1.6/private.js");
});
System.registerDynamic('npm:recast@0.11.18/lib/mapping.js', ['github:jspm/nodelibs-assert@0.1.0.js', 'npm:recast@0.11.18/lib/types.js', 'npm:recast@0.11.18/lib/lines.js', 'npm:recast@0.11.18/lib/util.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var assert = $__require('github:jspm/nodelibs-assert@0.1.0.js');
  var types = $__require('npm:recast@0.11.18/lib/types.js');
  var isString = types.builtInTypes.string;
  var isNumber = types.builtInTypes.number;
  var SourceLocation = types.namedTypes.SourceLocation;
  var Position = types.namedTypes.Position;
  var linesModule = $__require('npm:recast@0.11.18/lib/lines.js');
  var comparePos = $__require('npm:recast@0.11.18/lib/util.js').comparePos;
  function Mapping(sourceLines, sourceLoc, targetLoc) {
    assert.ok(this instanceof Mapping);
    assert.ok(sourceLines instanceof linesModule.Lines);
    SourceLocation.assert(sourceLoc);
    if (targetLoc) {
      assert.ok(isNumber.check(targetLoc.start.line) && isNumber.check(targetLoc.start.column) && isNumber.check(targetLoc.end.line) && isNumber.check(targetLoc.end.column));
    } else {
      targetLoc = sourceLoc;
    }
    Object.defineProperties(this, {
      sourceLines: { value: sourceLines },
      sourceLoc: { value: sourceLoc },
      targetLoc: { value: targetLoc }
    });
  }
  var Mp = Mapping.prototype;
  module.exports = Mapping;
  Mp.slice = function (lines, start, end) {
    assert.ok(lines instanceof linesModule.Lines);
    Position.assert(start);
    if (end) {
      Position.assert(end);
    } else {
      end = lines.lastPos();
    }
    var sourceLines = this.sourceLines;
    var sourceLoc = this.sourceLoc;
    var targetLoc = this.targetLoc;
    function skip(name) {
      var sourceFromPos = sourceLoc[name];
      var targetFromPos = targetLoc[name];
      var targetToPos = start;
      if (name === "end") {
        targetToPos = end;
      } else {
        assert.strictEqual(name, "start");
      }
      return skipChars(sourceLines, sourceFromPos, lines, targetFromPos, targetToPos);
    }
    if (comparePos(start, targetLoc.start) <= 0) {
      if (comparePos(targetLoc.end, end) <= 0) {
        targetLoc = {
          start: subtractPos(targetLoc.start, start.line, start.column),
          end: subtractPos(targetLoc.end, start.line, start.column)
        };
      } else if (comparePos(end, targetLoc.start) <= 0) {
        return null;
      } else {
        sourceLoc = {
          start: sourceLoc.start,
          end: skip("end")
        };
        targetLoc = {
          start: subtractPos(targetLoc.start, start.line, start.column),
          end: subtractPos(end, start.line, start.column)
        };
      }
    } else {
      if (comparePos(targetLoc.end, start) <= 0) {
        return null;
      }
      if (comparePos(targetLoc.end, end) <= 0) {
        sourceLoc = {
          start: skip("start"),
          end: sourceLoc.end
        };
        targetLoc = {
          start: {
            line: 1,
            column: 0
          },
          end: subtractPos(targetLoc.end, start.line, start.column)
        };
      } else {
        sourceLoc = {
          start: skip("start"),
          end: skip("end")
        };
        targetLoc = {
          start: {
            line: 1,
            column: 0
          },
          end: subtractPos(end, start.line, start.column)
        };
      }
    }
    return new Mapping(this.sourceLines, sourceLoc, targetLoc);
  };
  Mp.add = function (line, column) {
    return new Mapping(this.sourceLines, this.sourceLoc, {
      start: addPos(this.targetLoc.start, line, column),
      end: addPos(this.targetLoc.end, line, column)
    });
  };
  function addPos(toPos, line, column) {
    return {
      line: toPos.line + line - 1,
      column: toPos.line === 1 ? toPos.column + column : toPos.column
    };
  }
  Mp.subtract = function (line, column) {
    return new Mapping(this.sourceLines, this.sourceLoc, {
      start: subtractPos(this.targetLoc.start, line, column),
      end: subtractPos(this.targetLoc.end, line, column)
    });
  };
  function subtractPos(fromPos, line, column) {
    return {
      line: fromPos.line - line + 1,
      column: fromPos.line === line ? fromPos.column - column : fromPos.column
    };
  }
  Mp.indent = function (by, skipFirstLine, noNegativeColumns) {
    if (by === 0) {
      return this;
    }
    var targetLoc = this.targetLoc;
    var startLine = targetLoc.start.line;
    var endLine = targetLoc.end.line;
    if (skipFirstLine && startLine === 1 && endLine === 1) {
      return this;
    }
    targetLoc = {
      start: targetLoc.start,
      end: targetLoc.end
    };
    if (!skipFirstLine || startLine > 1) {
      var startColumn = targetLoc.start.column + by;
      targetLoc.start = {
        line: startLine,
        column: noNegativeColumns ? Math.max(0, startColumn) : startColumn
      };
    }
    if (!skipFirstLine || endLine > 1) {
      var endColumn = targetLoc.end.column + by;
      targetLoc.end = {
        line: endLine,
        column: noNegativeColumns ? Math.max(0, endColumn) : endColumn
      };
    }
    return new Mapping(this.sourceLines, this.sourceLoc, targetLoc);
  };
  function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {
    assert.ok(sourceLines instanceof linesModule.Lines);
    assert.ok(targetLines instanceof linesModule.Lines);
    Position.assert(sourceFromPos);
    Position.assert(targetFromPos);
    Position.assert(targetToPos);
    var targetComparison = comparePos(targetFromPos, targetToPos);
    if (targetComparison === 0) {
      return sourceFromPos;
    }
    if (targetComparison < 0) {
      var sourceCursor = sourceLines.skipSpaces(sourceFromPos);
      var targetCursor = targetLines.skipSpaces(targetFromPos);
      var lineDiff = targetToPos.line - targetCursor.line;
      sourceCursor.line += lineDiff;
      targetCursor.line += lineDiff;
      if (lineDiff > 0) {
        sourceCursor.column = 0;
        targetCursor.column = 0;
      } else {
        assert.strictEqual(lineDiff, 0);
      }
      while (comparePos(targetCursor, targetToPos) < 0 && targetLines.nextPos(targetCursor, true)) {
        assert.ok(sourceLines.nextPos(sourceCursor, true));
        assert.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
      }
    } else {
      var sourceCursor = sourceLines.skipSpaces(sourceFromPos, true);
      var targetCursor = targetLines.skipSpaces(targetFromPos, true);
      var lineDiff = targetToPos.line - targetCursor.line;
      sourceCursor.line += lineDiff;
      targetCursor.line += lineDiff;
      if (lineDiff < 0) {
        sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);
        targetCursor.column = targetLines.getLineLength(targetCursor.line);
      } else {
        assert.strictEqual(lineDiff, 0);
      }
      while (comparePos(targetToPos, targetCursor) < 0 && targetLines.prevPos(targetCursor, true)) {
        assert.ok(sourceLines.prevPos(sourceCursor, true));
        assert.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
      }
    }
    return sourceCursor;
  }
});
System.registerDynamic('npm:recast@0.11.18/lib/lines.js', ['github:jspm/nodelibs-assert@0.1.0.js', 'npm:source-map@0.5.6.js', 'npm:recast@0.11.18/lib/options.js', 'npm:private@0.1.6.js', 'npm:recast@0.11.18/lib/types.js', 'npm:recast@0.11.18/lib/util.js', 'npm:recast@0.11.18/lib/mapping.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var assert = $__require('github:jspm/nodelibs-assert@0.1.0.js');
  var sourceMap = $__require('npm:source-map@0.5.6.js');
  var normalizeOptions = $__require('npm:recast@0.11.18/lib/options.js').normalize;
  var secretKey = $__require('npm:private@0.1.6.js').makeUniqueKey();
  var types = $__require('npm:recast@0.11.18/lib/types.js');
  var isString = types.builtInTypes.string;
  var comparePos = $__require('npm:recast@0.11.18/lib/util.js').comparePos;
  var Mapping = $__require('npm:recast@0.11.18/lib/mapping.js');
  function getSecret(lines) {
    return lines[secretKey];
  }
  function Lines(infos, sourceFileName) {
    assert.ok(this instanceof Lines);
    assert.ok(infos.length > 0);
    if (sourceFileName) {
      isString.assert(sourceFileName);
    } else {
      sourceFileName = null;
    }
    Object.defineProperty(this, secretKey, { value: {
        infos: infos,
        mappings: [],
        name: sourceFileName,
        cachedSourceMap: null
      } });
    if (sourceFileName) {
      getSecret(this).mappings.push(new Mapping(this, {
        start: this.firstPos(),
        end: this.lastPos()
      }));
    }
  }
  exports.Lines = Lines;
  var Lp = Lines.prototype;
  Object.defineProperties(Lp, {
    length: { get: function () {
        return getSecret(this).infos.length;
      } },
    name: { get: function () {
        return getSecret(this).name;
      } }
  });
  function copyLineInfo(info) {
    return {
      line: info.line,
      indent: info.indent,
      locked: info.locked,
      sliceStart: info.sliceStart,
      sliceEnd: info.sliceEnd
    };
  }
  var fromStringCache = {};
  var hasOwn = fromStringCache.hasOwnProperty;
  var maxCacheKeyLen = 10;
  function countSpaces(spaces, tabWidth) {
    var count = 0;
    var len = spaces.length;
    for (var i = 0; i < len; ++i) {
      switch (spaces.charCodeAt(i)) {
        case 9:
          assert.strictEqual(typeof tabWidth, "number");
          assert.ok(tabWidth > 0);
          var next = Math.ceil(count / tabWidth) * tabWidth;
          if (next === count) {
            count += tabWidth;
          } else {
            count = next;
          }
          break;
        case 11:
        case 12:
        case 13:
        case 0xfeff:
          break;
        case 32:
        default:
          count += 1;
          break;
      }
    }
    return count;
  }
  exports.countSpaces = countSpaces;
  var leadingSpaceExp = /^\s*/;
  var lineTerminatorSeqExp = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;
  function fromString(string, options) {
    if (string instanceof Lines) return string;
    string += "";
    var tabWidth = options && options.tabWidth;
    var tabless = string.indexOf("\t") < 0;
    var locked = !!(options && options.locked);
    var cacheable = !options && tabless && string.length <= maxCacheKeyLen;
    assert.ok(tabWidth || tabless, "No tab width specified but encountered tabs in string\n" + string);
    if (cacheable && hasOwn.call(fromStringCache, string)) return fromStringCache[string];
    var lines = new Lines(string.split(lineTerminatorSeqExp).map(function (line) {
      var spaces = leadingSpaceExp.exec(line)[0];
      return {
        line: line,
        indent: countSpaces(spaces, tabWidth),
        locked: locked,
        sliceStart: spaces.length,
        sliceEnd: line.length
      };
    }), normalizeOptions(options).sourceFileName);
    if (cacheable) fromStringCache[string] = lines;
    return lines;
  }
  exports.fromString = fromString;
  function isOnlyWhitespace(string) {
    return !/\S/.test(string);
  }
  Lp.toString = function (options) {
    return this.sliceString(this.firstPos(), this.lastPos(), options);
  };
  Lp.getSourceMap = function (sourceMapName, sourceRoot) {
    if (!sourceMapName) {
      return null;
    }
    var targetLines = this;
    function updateJSON(json) {
      json = json || {};
      isString.assert(sourceMapName);
      json.file = sourceMapName;
      if (sourceRoot) {
        isString.assert(sourceRoot);
        json.sourceRoot = sourceRoot;
      }
      return json;
    }
    var secret = getSecret(targetLines);
    if (secret.cachedSourceMap) {
      return updateJSON(secret.cachedSourceMap.toJSON());
    }
    var smg = new sourceMap.SourceMapGenerator(updateJSON());
    var sourcesToContents = {};
    secret.mappings.forEach(function (mapping) {
      var sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) || mapping.sourceLines.lastPos();
      var targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) || targetLines.lastPos();
      while (comparePos(sourceCursor, mapping.sourceLoc.end) < 0 && comparePos(targetCursor, mapping.targetLoc.end) < 0) {
        var sourceChar = mapping.sourceLines.charAt(sourceCursor);
        var targetChar = targetLines.charAt(targetCursor);
        assert.strictEqual(sourceChar, targetChar);
        var sourceName = mapping.sourceLines.name;
        smg.addMapping({
          source: sourceName,
          original: {
            line: sourceCursor.line,
            column: sourceCursor.column
          },
          generated: {
            line: targetCursor.line,
            column: targetCursor.column
          }
        });
        if (!hasOwn.call(sourcesToContents, sourceName)) {
          var sourceContent = mapping.sourceLines.toString();
          smg.setSourceContent(sourceName, sourceContent);
          sourcesToContents[sourceName] = sourceContent;
        }
        targetLines.nextPos(targetCursor, true);
        mapping.sourceLines.nextPos(sourceCursor, true);
      }
    });
    secret.cachedSourceMap = smg;
    return smg.toJSON();
  };
  Lp.bootstrapCharAt = function (pos) {
    assert.strictEqual(typeof pos, "object");
    assert.strictEqual(typeof pos.line, "number");
    assert.strictEqual(typeof pos.column, "number");
    var line = pos.line,
        column = pos.column,
        strings = this.toString().split(lineTerminatorSeqExp),
        string = strings[line - 1];
    if (typeof string === "undefined") return "";
    if (column === string.length && line < strings.length) return "\n";
    if (column >= string.length) return "";
    return string.charAt(column);
  };
  Lp.charAt = function (pos) {
    assert.strictEqual(typeof pos, "object");
    assert.strictEqual(typeof pos.line, "number");
    assert.strictEqual(typeof pos.column, "number");
    var line = pos.line,
        column = pos.column,
        secret = getSecret(this),
        infos = secret.infos,
        info = infos[line - 1],
        c = column;
    if (typeof info === "undefined" || c < 0) return "";
    var indent = this.getIndentAt(line);
    if (c < indent) return " ";
    c += info.sliceStart - indent;
    if (c === info.sliceEnd && line < this.length) return "\n";
    if (c >= info.sliceEnd) return "";
    return info.line.charAt(c);
  };
  Lp.stripMargin = function (width, skipFirstLine) {
    if (width === 0) return this;
    assert.ok(width > 0, "negative margin: " + width);
    if (skipFirstLine && this.length === 1) return this;
    var secret = getSecret(this);
    var lines = new Lines(secret.infos.map(function (info, i) {
      if (info.line && (i > 0 || !skipFirstLine)) {
        info = copyLineInfo(info);
        info.indent = Math.max(0, info.indent - width);
      }
      return info;
    }));
    if (secret.mappings.length > 0) {
      var newMappings = getSecret(lines).mappings;
      assert.strictEqual(newMappings.length, 0);
      secret.mappings.forEach(function (mapping) {
        newMappings.push(mapping.indent(width, skipFirstLine, true));
      });
    }
    return lines;
  };
  Lp.indent = function (by) {
    if (by === 0) return this;
    var secret = getSecret(this);
    var lines = new Lines(secret.infos.map(function (info) {
      if (info.line && !info.locked) {
        info = copyLineInfo(info);
        info.indent += by;
      }
      return info;
    }));
    if (secret.mappings.length > 0) {
      var newMappings = getSecret(lines).mappings;
      assert.strictEqual(newMappings.length, 0);
      secret.mappings.forEach(function (mapping) {
        newMappings.push(mapping.indent(by));
      });
    }
    return lines;
  };
  Lp.indentTail = function (by) {
    if (by === 0) return this;
    if (this.length < 2) return this;
    var secret = getSecret(this);
    var lines = new Lines(secret.infos.map(function (info, i) {
      if (i > 0 && info.line && !info.locked) {
        info = copyLineInfo(info);
        info.indent += by;
      }
      return info;
    }));
    if (secret.mappings.length > 0) {
      var newMappings = getSecret(lines).mappings;
      assert.strictEqual(newMappings.length, 0);
      secret.mappings.forEach(function (mapping) {
        newMappings.push(mapping.indent(by, true));
      });
    }
    return lines;
  };
  Lp.lockIndentTail = function () {
    if (this.length < 2) {
      return this;
    }
    var infos = getSecret(this).infos;
    return new Lines(infos.map(function (info, i) {
      info = copyLineInfo(info);
      info.locked = i > 0;
      return info;
    }));
  };
  Lp.getIndentAt = function (line) {
    assert.ok(line >= 1, "no line " + line + " (line numbers start from 1)");
    var secret = getSecret(this),
        info = secret.infos[line - 1];
    return Math.max(info.indent, 0);
  };
  Lp.guessTabWidth = function () {
    var secret = getSecret(this);
    if (hasOwn.call(secret, "cachedTabWidth")) {
      return secret.cachedTabWidth;
    }
    var counts = [];
    var lastIndent = 0;
    for (var line = 1, last = this.length; line <= last; ++line) {
      var info = secret.infos[line - 1];
      var sliced = info.line.slice(info.sliceStart, info.sliceEnd);
      if (isOnlyWhitespace(sliced)) {
        continue;
      }
      var diff = Math.abs(info.indent - lastIndent);
      counts[diff] = ~~counts[diff] + 1;
      lastIndent = info.indent;
    }
    var maxCount = -1;
    var result = 2;
    for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {
      if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {
        maxCount = counts[tabWidth];
        result = tabWidth;
      }
    }
    return secret.cachedTabWidth = result;
  };
  Lp.isOnlyWhitespace = function () {
    return isOnlyWhitespace(this.toString());
  };
  Lp.isPrecededOnlyByWhitespace = function (pos) {
    var secret = getSecret(this);
    var info = secret.infos[pos.line - 1];
    var indent = Math.max(info.indent, 0);
    var diff = pos.column - indent;
    if (diff <= 0) {
      return true;
    }
    var start = info.sliceStart;
    var end = Math.min(start + diff, info.sliceEnd);
    var prefix = info.line.slice(start, end);
    return isOnlyWhitespace(prefix);
  };
  Lp.getLineLength = function (line) {
    var secret = getSecret(this),
        info = secret.infos[line - 1];
    return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;
  };
  Lp.nextPos = function (pos, skipSpaces) {
    var l = Math.max(pos.line, 0),
        c = Math.max(pos.column, 0);
    if (c < this.getLineLength(l)) {
      pos.column += 1;
      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
    }
    if (l < this.length) {
      pos.line += 1;
      pos.column = 0;
      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
    }
    return false;
  };
  Lp.prevPos = function (pos, skipSpaces) {
    var l = pos.line,
        c = pos.column;
    if (c < 1) {
      l -= 1;
      if (l < 1) return false;
      c = this.getLineLength(l);
    } else {
      c = Math.min(c - 1, this.getLineLength(l));
    }
    pos.line = l;
    pos.column = c;
    return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;
  };
  Lp.firstPos = function () {
    return {
      line: 1,
      column: 0
    };
  };
  Lp.lastPos = function () {
    return {
      line: this.length,
      column: this.getLineLength(this.length)
    };
  };
  Lp.skipSpaces = function (pos, backward, modifyInPlace) {
    if (pos) {
      pos = modifyInPlace ? pos : {
        line: pos.line,
        column: pos.column
      };
    } else if (backward) {
      pos = this.lastPos();
    } else {
      pos = this.firstPos();
    }
    if (backward) {
      while (this.prevPos(pos)) {
        if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {
          return pos;
        }
      }
      return null;
    } else {
      while (isOnlyWhitespace(this.charAt(pos))) {
        if (!this.nextPos(pos)) {
          return null;
        }
      }
      return pos;
    }
  };
  Lp.trimLeft = function () {
    var pos = this.skipSpaces(this.firstPos(), false, true);
    return pos ? this.slice(pos) : emptyLines;
  };
  Lp.trimRight = function () {
    var pos = this.skipSpaces(this.lastPos(), true, true);
    return pos ? this.slice(this.firstPos(), pos) : emptyLines;
  };
  Lp.trim = function () {
    var start = this.skipSpaces(this.firstPos(), false, true);
    if (start === null) return emptyLines;
    var end = this.skipSpaces(this.lastPos(), true, true);
    assert.notStrictEqual(end, null);
    return this.slice(start, end);
  };
  Lp.eachPos = function (callback, startPos, skipSpaces) {
    var pos = this.firstPos();
    if (startPos) {
      pos.line = startPos.line, pos.column = startPos.column;
    }
    if (skipSpaces && !this.skipSpaces(pos, false, true)) {
      return;
    }
    do callback.call(this, pos); while (this.nextPos(pos, skipSpaces));
  };
  Lp.bootstrapSlice = function (start, end) {
    var strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end.line);
    strings.push(strings.pop().slice(0, end.column));
    strings[0] = strings[0].slice(start.column);
    return fromString(strings.join("\n"));
  };
  Lp.slice = function (start, end) {
    if (!end) {
      if (!start) {
        return this;
      }
      end = this.lastPos();
    }
    var secret = getSecret(this);
    var sliced = secret.infos.slice(start.line - 1, end.line);
    if (start.line === end.line) {
      sliced[0] = sliceInfo(sliced[0], start.column, end.column);
    } else {
      assert.ok(start.line < end.line);
      sliced[0] = sliceInfo(sliced[0], start.column);
      sliced.push(sliceInfo(sliced.pop(), 0, end.column));
    }
    var lines = new Lines(sliced);
    if (secret.mappings.length > 0) {
      var newMappings = getSecret(lines).mappings;
      assert.strictEqual(newMappings.length, 0);
      secret.mappings.forEach(function (mapping) {
        var sliced = mapping.slice(this, start, end);
        if (sliced) {
          newMappings.push(sliced);
        }
      }, this);
    }
    return lines;
  };
  function sliceInfo(info, startCol, endCol) {
    var sliceStart = info.sliceStart;
    var sliceEnd = info.sliceEnd;
    var indent = Math.max(info.indent, 0);
    var lineLength = indent + sliceEnd - sliceStart;
    if (typeof endCol === "undefined") {
      endCol = lineLength;
    }
    startCol = Math.max(startCol, 0);
    endCol = Math.min(endCol, lineLength);
    endCol = Math.max(endCol, startCol);
    if (endCol < indent) {
      indent = endCol;
      sliceEnd = sliceStart;
    } else {
      sliceEnd -= lineLength - endCol;
    }
    lineLength = endCol;
    lineLength -= startCol;
    if (startCol < indent) {
      indent -= startCol;
    } else {
      startCol -= indent;
      indent = 0;
      sliceStart += startCol;
    }
    assert.ok(indent >= 0);
    assert.ok(sliceStart <= sliceEnd);
    assert.strictEqual(lineLength, indent + sliceEnd - sliceStart);
    if (info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd) {
      return info;
    }
    return {
      line: info.line,
      indent: indent,
      locked: false,
      sliceStart: sliceStart,
      sliceEnd: sliceEnd
    };
  }
  Lp.bootstrapSliceString = function (start, end, options) {
    return this.slice(start, end).toString(options);
  };
  Lp.sliceString = function (start, end, options) {
    if (!end) {
      if (!start) {
        return this;
      }
      end = this.lastPos();
    }
    options = normalizeOptions(options);
    var infos = getSecret(this).infos;
    var parts = [];
    var tabWidth = options.tabWidth;
    for (var line = start.line; line <= end.line; ++line) {
      var info = infos[line - 1];
      if (line === start.line) {
        if (line === end.line) {
          info = sliceInfo(info, start.column, end.column);
        } else {
          info = sliceInfo(info, start.column);
        }
      } else if (line === end.line) {
        info = sliceInfo(info, 0, end.column);
      }
      var indent = Math.max(info.indent, 0);
      var before = info.line.slice(0, info.sliceStart);
      if (options.reuseWhitespace && isOnlyWhitespace(before) && countSpaces(before, options.tabWidth) === indent) {
        parts.push(info.line.slice(0, info.sliceEnd));
        continue;
      }
      var tabs = 0;
      var spaces = indent;
      if (options.useTabs) {
        tabs = Math.floor(indent / tabWidth);
        spaces -= tabs * tabWidth;
      }
      var result = "";
      if (tabs > 0) {
        result += new Array(tabs + 1).join("\t");
      }
      if (spaces > 0) {
        result += new Array(spaces + 1).join(" ");
      }
      result += info.line.slice(info.sliceStart, info.sliceEnd);
      parts.push(result);
    }
    return parts.join(options.lineTerminator);
  };
  Lp.isEmpty = function () {
    return this.length < 2 && this.getLineLength(1) < 1;
  };
  Lp.join = function (elements) {
    var separator = this;
    var separatorSecret = getSecret(separator);
    var infos = [];
    var mappings = [];
    var prevInfo;
    function appendSecret(secret) {
      if (secret === null) return;
      if (prevInfo) {
        var info = secret.infos[0];
        var indent = new Array(info.indent + 1).join(" ");
        var prevLine = infos.length;
        var prevColumn = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;
        prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd);
        prevInfo.locked = prevInfo.locked || info.locked;
        prevInfo.sliceEnd = prevInfo.line.length;
        if (secret.mappings.length > 0) {
          secret.mappings.forEach(function (mapping) {
            mappings.push(mapping.add(prevLine, prevColumn));
          });
        }
      } else if (secret.mappings.length > 0) {
        mappings.push.apply(mappings, secret.mappings);
      }
      secret.infos.forEach(function (info, i) {
        if (!prevInfo || i > 0) {
          prevInfo = copyLineInfo(info);
          infos.push(prevInfo);
        }
      });
    }
    function appendWithSeparator(secret, i) {
      if (i > 0) appendSecret(separatorSecret);
      appendSecret(secret);
    }
    elements.map(function (elem) {
      var lines = fromString(elem);
      if (lines.isEmpty()) return null;
      return getSecret(lines);
    }).forEach(separator.isEmpty() ? appendSecret : appendWithSeparator);
    if (infos.length < 1) return emptyLines;
    var lines = new Lines(infos);
    getSecret(lines).mappings = mappings;
    return lines;
  };
  exports.concat = function (elements) {
    return emptyLines.join(elements);
  };
  Lp.concat = function (other) {
    var args = arguments,
        list = [this];
    list.push.apply(list, args);
    assert.strictEqual(list.length, args.length + 1);
    return emptyLines.join(list);
  };
  var emptyLines = fromString("");
});
System.registerDynamic('npm:recast@0.11.18/lib/patcher.js', ['github:jspm/nodelibs-assert@0.1.0.js', 'npm:recast@0.11.18/lib/lines.js', 'npm:recast@0.11.18/lib/types.js', 'npm:recast@0.11.18/lib/util.js', 'npm:recast@0.11.18/lib/fast-path.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var assert = $__require('github:jspm/nodelibs-assert@0.1.0.js');
  var linesModule = $__require('npm:recast@0.11.18/lib/lines.js');
  var types = $__require('npm:recast@0.11.18/lib/types.js');
  var getFieldValue = types.getFieldValue;
  var Printable = types.namedTypes.Printable;
  var Expression = types.namedTypes.Expression;
  var SourceLocation = types.namedTypes.SourceLocation;
  var util = $__require('npm:recast@0.11.18/lib/util.js');
  var comparePos = util.comparePos;
  var FastPath = $__require('npm:recast@0.11.18/lib/fast-path.js');
  var isObject = types.builtInTypes.object;
  var isArray = types.builtInTypes.array;
  var isString = types.builtInTypes.string;
  var riskyAdjoiningCharExp = /[0-9a-z_$]/i;
  function Patcher(lines) {
    assert.ok(this instanceof Patcher);
    assert.ok(lines instanceof linesModule.Lines);
    var self = this,
        replacements = [];
    self.replace = function (loc, lines) {
      if (isString.check(lines)) lines = linesModule.fromString(lines);
      replacements.push({
        lines: lines,
        start: loc.start,
        end: loc.end
      });
    };
    self.get = function (loc) {
      loc = loc || {
        start: {
          line: 1,
          column: 0
        },
        end: {
          line: lines.length,
          column: lines.getLineLength(lines.length)
        }
      };
      var sliceFrom = loc.start,
          toConcat = [];
      function pushSlice(from, to) {
        assert.ok(comparePos(from, to) <= 0);
        toConcat.push(lines.slice(from, to));
      }
      replacements.sort(function (a, b) {
        return comparePos(a.start, b.start);
      }).forEach(function (rep) {
        if (comparePos(sliceFrom, rep.start) > 0) {} else {
          pushSlice(sliceFrom, rep.start);
          toConcat.push(rep.lines);
          sliceFrom = rep.end;
        }
      });
      pushSlice(sliceFrom, loc.end);
      return linesModule.concat(toConcat);
    };
  }
  exports.Patcher = Patcher;
  var Pp = Patcher.prototype;
  Pp.tryToReprintComments = function (newNode, oldNode, print) {
    var patcher = this;
    if (!newNode.comments && !oldNode.comments) {
      return true;
    }
    var newPath = FastPath.from(newNode);
    var oldPath = FastPath.from(oldNode);
    newPath.stack.push("comments", getSurroundingComments(newNode));
    oldPath.stack.push("comments", getSurroundingComments(oldNode));
    var reprints = [];
    var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);
    if (ableToReprintComments && reprints.length > 0) {
      reprints.forEach(function (reprint) {
        var oldComment = reprint.oldPath.getValue();
        assert.ok(oldComment.leading || oldComment.trailing);
        patcher.replace(oldComment.loc, print(reprint.newPath).indentTail(oldComment.loc.indent));
      });
    }
    return ableToReprintComments;
  };
  function getSurroundingComments(node) {
    var result = [];
    if (node.comments && node.comments.length > 0) {
      node.comments.forEach(function (comment) {
        if (comment.leading || comment.trailing) {
          result.push(comment);
        }
      });
    }
    return result;
  }
  Pp.deleteComments = function (node) {
    if (!node.comments) {
      return;
    }
    var patcher = this;
    node.comments.forEach(function (comment) {
      if (comment.leading) {
        patcher.replace({
          start: comment.loc.start,
          end: node.loc.lines.skipSpaces(comment.loc.end, false, false)
        }, "");
      } else if (comment.trailing) {
        patcher.replace({
          start: node.loc.lines.skipSpaces(comment.loc.start, true, false),
          end: comment.loc.end
        }, "");
      }
    });
  };
  exports.getReprinter = function (path) {
    assert.ok(path instanceof FastPath);
    var node = path.getValue();
    if (!Printable.check(node)) return;
    var orig = node.original;
    var origLoc = orig && orig.loc;
    var lines = origLoc && origLoc.lines;
    var reprints = [];
    if (!lines || !findReprints(path, reprints)) return;
    return function (print) {
      var patcher = new Patcher(lines);
      reprints.forEach(function (reprint) {
        var newNode = reprint.newPath.getValue();
        var oldNode = reprint.oldPath.getValue();
        SourceLocation.assert(oldNode.loc, true);
        var needToPrintNewPathWithComments = !patcher.tryToReprintComments(newNode, oldNode, print);
        if (needToPrintNewPathWithComments) {
          patcher.deleteComments(oldNode);
        }
        var newLines = print(reprint.newPath, needToPrintNewPathWithComments).indentTail(oldNode.loc.indent);
        var nls = needsLeadingSpace(lines, oldNode.loc, newLines);
        var nts = needsTrailingSpace(lines, oldNode.loc, newLines);
        if (nls || nts) {
          var newParts = [];
          nls && newParts.push(" ");
          newParts.push(newLines);
          nts && newParts.push(" ");
          newLines = linesModule.concat(newParts);
        }
        patcher.replace(oldNode.loc, newLines);
      });
      return patcher.get(origLoc).indentTail(-orig.loc.indent);
    };
  };
  function needsLeadingSpace(oldLines, oldLoc, newLines) {
    var posBeforeOldLoc = util.copyPos(oldLoc.start);
    var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);
    var newFirstChar = newLines.charAt(newLines.firstPos());
    return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);
  }
  function needsTrailingSpace(oldLines, oldLoc, newLines) {
    var charAfterOldLoc = oldLines.charAt(oldLoc.end);
    var newLastPos = newLines.lastPos();
    var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);
    return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);
  }
  function findReprints(newPath, reprints) {
    var newNode = newPath.getValue();
    Printable.assert(newNode);
    var oldNode = newNode.original;
    Printable.assert(oldNode);
    assert.deepEqual(reprints, []);
    if (newNode.type !== oldNode.type) {
      return false;
    }
    var oldPath = new FastPath(oldNode);
    var canReprint = findChildReprints(newPath, oldPath, reprints);
    if (!canReprint) {
      reprints.length = 0;
    }
    return canReprint;
  }
  function findAnyReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue();
    var oldNode = oldPath.getValue();
    if (newNode === oldNode) return true;
    if (isArray.check(newNode)) return findArrayReprints(newPath, oldPath, reprints);
    if (isObject.check(newNode)) return findObjectReprints(newPath, oldPath, reprints);
    return false;
  }
  function findArrayReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue();
    var oldNode = oldPath.getValue();
    isArray.assert(newNode);
    var len = newNode.length;
    if (!(isArray.check(oldNode) && oldNode.length === len)) return false;
    for (var i = 0; i < len; ++i) {
      newPath.stack.push(i, newNode[i]);
      oldPath.stack.push(i, oldNode[i]);
      var canReprint = findAnyReprints(newPath, oldPath, reprints);
      newPath.stack.length -= 2;
      oldPath.stack.length -= 2;
      if (!canReprint) {
        return false;
      }
    }
    return true;
  }
  function findObjectReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue();
    isObject.assert(newNode);
    if (newNode.original === null) {
      return false;
    }
    var oldNode = oldPath.getValue();
    if (!isObject.check(oldNode)) return false;
    if (Printable.check(newNode)) {
      if (!Printable.check(oldNode)) {
        return false;
      }
      if (newNode.type === oldNode.type) {
        var childReprints = [];
        if (findChildReprints(newPath, oldPath, childReprints)) {
          reprints.push.apply(reprints, childReprints);
        } else if (oldNode.loc) {
          reprints.push({
            oldPath: oldPath.copy(),
            newPath: newPath.copy()
          });
        } else {
          return false;
        }
        return true;
      }
      if (Expression.check(newNode) && Expression.check(oldNode) && oldNode.loc) {
        reprints.push({
          oldPath: oldPath.copy(),
          newPath: newPath.copy()
        });
        return true;
      }
      return false;
    }
    return findChildReprints(newPath, oldPath, reprints);
  }
  var reusablePos = {
    line: 1,
    column: 0
  };
  var nonSpaceExp = /\S/;
  function hasOpeningParen(oldPath) {
    var oldNode = oldPath.getValue();
    var loc = oldNode.loc;
    var lines = loc && loc.lines;
    if (lines) {
      var pos = reusablePos;
      pos.line = loc.start.line;
      pos.column = loc.start.column;
      while (lines.prevPos(pos)) {
        var ch = lines.charAt(pos);
        if (ch === "(") {
          return comparePos(oldPath.getRootValue().loc.start, pos) <= 0;
        }
        if (nonSpaceExp.test(ch)) {
          return false;
        }
      }
    }
    return false;
  }
  function hasClosingParen(oldPath) {
    var oldNode = oldPath.getValue();
    var loc = oldNode.loc;
    var lines = loc && loc.lines;
    if (lines) {
      var pos = reusablePos;
      pos.line = loc.end.line;
      pos.column = loc.end.column;
      do {
        var ch = lines.charAt(pos);
        if (ch === ")") {
          return comparePos(pos, oldPath.getRootValue().loc.end) <= 0;
        }
        if (nonSpaceExp.test(ch)) {
          return false;
        }
      } while (lines.nextPos(pos));
    }
    return false;
  }
  function hasParens(oldPath) {
    return hasOpeningParen(oldPath) && hasClosingParen(oldPath);
  }
  function findChildReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue();
    var oldNode = oldPath.getValue();
    isObject.assert(newNode);
    isObject.assert(oldNode);
    if (newNode.original === null) {
      return false;
    }
    if (!newPath.canBeFirstInStatement() && newPath.firstInStatement() && !hasOpeningParen(oldPath)) return false;
    if (newPath.needsParens(true) && !hasParens(oldPath)) {
      return false;
    }
    for (var k in util.getUnionOfKeys(newNode, oldNode)) {
      if (k === "loc") continue;
      newPath.stack.push(k, types.getFieldValue(newNode, k));
      oldPath.stack.push(k, types.getFieldValue(oldNode, k));
      var canReprint = findAnyReprints(newPath, oldPath, reprints);
      newPath.stack.length -= 2;
      oldPath.stack.length -= 2;
      if (!canReprint) {
        return false;
      }
    }
    return true;
  }
});
System.registerDynamic('npm:recast@0.11.18/lib/fast-path.js', ['github:jspm/nodelibs-assert@0.1.0.js', 'npm:recast@0.11.18/lib/types.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var assert = $__require('github:jspm/nodelibs-assert@0.1.0.js');
  var types = $__require('npm:recast@0.11.18/lib/types.js');
  var n = types.namedTypes;
  var Node = n.Node;
  var isArray = types.builtInTypes.array;
  var isNumber = types.builtInTypes.number;
  function FastPath(value) {
    assert.ok(this instanceof FastPath);
    this.stack = [value];
  }
  var FPp = FastPath.prototype;
  module.exports = FastPath;
  FastPath.from = function (obj) {
    if (obj instanceof FastPath) {
      return obj.copy();
    }
    if (obj instanceof types.NodePath) {
      var copy = Object.create(FastPath.prototype);
      var stack = [obj.value];
      for (var pp; pp = obj.parentPath; obj = pp) stack.push(obj.name, pp.value);
      copy.stack = stack.reverse();
      return copy;
    }
    return new FastPath(obj);
  };
  FPp.copy = function copy() {
    var copy = Object.create(FastPath.prototype);
    copy.stack = this.stack.slice(0);
    return copy;
  };
  FPp.getName = function getName() {
    var s = this.stack;
    var len = s.length;
    if (len > 1) {
      return s[len - 2];
    }
    return null;
  };
  FPp.getValue = function getValue() {
    var s = this.stack;
    return s[s.length - 1];
  };
  function getNodeHelper(path, count) {
    var s = path.stack;
    for (var i = s.length - 1; i >= 0; i -= 2) {
      var value = s[i];
      if (n.Node.check(value) && --count < 0) {
        return value;
      }
    }
    return null;
  }
  FPp.getNode = function getNode(count) {
    return getNodeHelper(this, ~~count);
  };
  FPp.getParentNode = function getParentNode(count) {
    return getNodeHelper(this, ~~count + 1);
  };
  FPp.getRootValue = function getRootValue() {
    var s = this.stack;
    if (s.length % 2 === 0) {
      return s[1];
    }
    return s[0];
  };
  FPp.call = function call(callback) {
    var s = this.stack;
    var origLen = s.length;
    var value = s[origLen - 1];
    var argc = arguments.length;
    for (var i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name];
      s.push(name, value);
    }
    var result = callback(this);
    s.length = origLen;
    return result;
  };
  FPp.each = function each(callback) {
    var s = this.stack;
    var origLen = s.length;
    var value = s[origLen - 1];
    var argc = arguments.length;
    for (var i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name];
      s.push(name, value);
    }
    for (var i = 0; i < value.length; ++i) {
      if (i in value) {
        s.push(i, value[i]);
        callback(this);
        s.length -= 2;
      }
    }
    s.length = origLen;
  };
  FPp.map = function map(callback) {
    var s = this.stack;
    var origLen = s.length;
    var value = s[origLen - 1];
    var argc = arguments.length;
    for (var i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name];
      s.push(name, value);
    }
    var result = new Array(value.length);
    for (var i = 0; i < value.length; ++i) {
      if (i in value) {
        s.push(i, value[i]);
        result[i] = callback(this, i);
        s.length -= 2;
      }
    }
    s.length = origLen;
    return result;
  };
  FPp.needsParens = function (assumeExpressionContext) {
    var parent = this.getParentNode();
    if (!parent) {
      return false;
    }
    var name = this.getName();
    var node = this.getNode();
    if (this.getValue() !== node) {
      return false;
    }
    if (n.Statement.check(node)) {
      return false;
    }
    if (node.type === "Identifier") {
      return false;
    }
    if (parent.type === "ParenthesizedExpression") {
      return false;
    }
    switch (node.type) {
      case "UnaryExpression":
      case "SpreadElement":
      case "SpreadProperty":
        return parent.type === "MemberExpression" && name === "object" && parent.object === node;
      case "BinaryExpression":
      case "LogicalExpression":
        switch (parent.type) {
          case "CallExpression":
            return name === "callee" && parent.callee === node;
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
            return true;
          case "MemberExpression":
            return name === "object" && parent.object === node;
          case "BinaryExpression":
          case "LogicalExpression":
            var po = parent.operator;
            var pp = PRECEDENCE[po];
            var no = node.operator;
            var np = PRECEDENCE[no];
            if (pp > np) {
              return true;
            }
            if (pp === np && name === "right") {
              assert.strictEqual(parent.right, node);
              return true;
            }
          default:
            return false;
        }
      case "SequenceExpression":
        switch (parent.type) {
          case "ReturnStatement":
            return false;
          case "ForStatement":
            return false;
          case "ExpressionStatement":
            return name !== "expression";
          default:
            return true;
        }
      case "YieldExpression":
        switch (parent.type) {
          case "BinaryExpression":
          case "LogicalExpression":
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "CallExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ConditionalExpression":
          case "YieldExpression":
            return true;
          default:
            return false;
        }
      case "IntersectionTypeAnnotation":
      case "UnionTypeAnnotation":
        return parent.type === "NullableTypeAnnotation";
      case "Literal":
        return parent.type === "MemberExpression" && isNumber.check(node.value) && name === "object" && parent.object === node;
      case "AssignmentExpression":
      case "ConditionalExpression":
        switch (parent.type) {
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "BinaryExpression":
          case "LogicalExpression":
            return true;
          case "CallExpression":
            return name === "callee" && parent.callee === node;
          case "ConditionalExpression":
            return name === "test" && parent.test === node;
          case "MemberExpression":
            return name === "object" && parent.object === node;
          default:
            return false;
        }
      case "ArrowFunctionExpression":
        if (parent.type === 'CallExpression' && name === 'callee') {
          return true;
        }
        ;
        return isBinary(parent);
      case "ObjectExpression":
        if (parent.type === "ArrowFunctionExpression" && name === "body") {
          return true;
        }
      default:
        if (parent.type === "NewExpression" && name === "callee" && parent.callee === node) {
          return containsCallExpression(node);
        }
    }
    if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) return true;
    return false;
  };
  function isBinary(node) {
    return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);
  }
  function isUnaryLike(node) {
    return n.UnaryExpression.check(node) || n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);
  }
  var PRECEDENCE = {};
  [["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%", "**"]].forEach(function (tier, i) {
    tier.forEach(function (op) {
      PRECEDENCE[op] = i;
    });
  });
  function containsCallExpression(node) {
    if (n.CallExpression.check(node)) {
      return true;
    }
    if (isArray.check(node)) {
      return node.some(containsCallExpression);
    }
    if (n.Node.check(node)) {
      return types.someField(node, function (name, child) {
        return containsCallExpression(child);
      });
    }
    return false;
  }
  FPp.canBeFirstInStatement = function () {
    var node = this.getNode();
    return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);
  };
  FPp.firstInStatement = function () {
    var s = this.stack;
    var parentName, parent;
    var childName, child;
    for (var i = s.length - 1; i >= 0; i -= 2) {
      if (n.Node.check(s[i])) {
        childName = parentName;
        child = parent;
        parentName = s[i - 1];
        parent = s[i];
      }
      if (!parent || !child) {
        continue;
      }
      if (n.BlockStatement.check(parent) && parentName === "body" && childName === 0) {
        assert.strictEqual(parent.body[0], child);
        return true;
      }
      if (n.ExpressionStatement.check(parent) && childName === "expression") {
        assert.strictEqual(parent.expression, child);
        return true;
      }
      if (n.SequenceExpression.check(parent) && parentName === "expressions" && childName === 0) {
        assert.strictEqual(parent.expressions[0], child);
        continue;
      }
      if (n.CallExpression.check(parent) && childName === "callee") {
        assert.strictEqual(parent.callee, child);
        continue;
      }
      if (n.MemberExpression.check(parent) && childName === "object") {
        assert.strictEqual(parent.object, child);
        continue;
      }
      if (n.ConditionalExpression.check(parent) && childName === "test") {
        assert.strictEqual(parent.test, child);
        continue;
      }
      if (isBinary(parent) && childName === "left") {
        assert.strictEqual(parent.left, child);
        continue;
      }
      if (n.UnaryExpression.check(parent) && !parent.prefix && childName === "argument") {
        assert.strictEqual(parent.argument, child);
        continue;
      }
      return false;
    }
    return true;
  };
});
System.registerDynamic('npm:util@0.10.3/support/isBufferBrowser.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
  };
});
System.registerDynamic('npm:inherits@2.0.1/inherits_browser.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
});
System.registerDynamic("npm:inherits@2.0.1.js", ["npm:inherits@2.0.1/inherits_browser.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:inherits@2.0.1/inherits_browser.js");
});
System.registerDynamic('npm:util@0.10.3/util.js', ['npm:util@0.10.3/support/isBufferBrowser.js', 'npm:inherits@2.0.1.js', 'github:jspm/nodelibs-process@0.1.2.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var formatRegExp = /%[sdj%]/g;
    exports.format = function (f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function (x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function (fn, msg) {
      if (isUndefined(global.process)) {
        return function () {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnviron;
    exports.debuglog = function (set) {
      if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function () {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function () {};
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
          array = false,
          braces = ['{', '}'];
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      if (isNull(value)) return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = $__require('npm:util@0.10.3/support/isBufferBrowser.js');
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }
    exports.log = function () {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = $__require('npm:inherits@2.0.1.js');
    exports._extend = function (origin, add) {
      if (!add || !isObject(add)) return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
});
System.registerDynamic("npm:util@0.10.3.js", ["npm:util@0.10.3/util.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:util@0.10.3/util.js");
});
System.registerDynamic('npm:base64-js@0.0.8/lib/b64.js', [], true, function ($__require, exports, module) {
	var global = this || self,
	    GLOBAL = global;
	/* */
	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

		var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

		var PLUS = '+'.charCodeAt(0);
		var SLASH = '/'.charCodeAt(0);
		var NUMBER = '0'.charCodeAt(0);
		var LOWER = 'a'.charCodeAt(0);
		var UPPER = 'A'.charCodeAt(0);
		var PLUS_URL_SAFE = '-'.charCodeAt(0);
		var SLASH_URL_SAFE = '_'.charCodeAt(0);

		function decode(elt) {
			var code = elt.charCodeAt(0);
			if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'
			if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'
			if (code < NUMBER) return -1; //no match
			if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
			if (code < UPPER + 26) return code - UPPER;
			if (code < LOWER + 26) return code - LOWER + 26;
		}

		function b64ToByteArray(b64) {
			var i, j, l, tmp, placeHolders, arr;

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4');
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length;
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders);

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length;

			var L = 0;

			function push(v) {
				arr[L++] = v;
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
				push((tmp & 0xFF0000) >> 16);
				push((tmp & 0xFF00) >> 8);
				push(tmp & 0xFF);
			}

			if (placeHolders === 2) {
				tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
				push(tmp & 0xFF);
			} else if (placeHolders === 1) {
				tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
				push(tmp >> 8 & 0xFF);
				push(tmp & 0xFF);
			}

			return arr;
		}

		function uint8ToBase64(uint8) {
			var i,
			    extraBytes = uint8.length % 3,
			    // if we have 1 byte left, pad 2 bytes
			output = "",
			    temp,
			    length;

			function encode(num) {
				return lookup.charAt(num);
			}

			function tripletToBase64(num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
				output += tripletToBase64(temp);
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1];
					output += encode(temp >> 2);
					output += encode(temp << 4 & 0x3F);
					output += '==';
					break;
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
					output += encode(temp >> 10);
					output += encode(temp >> 4 & 0x3F);
					output += encode(temp << 2 & 0x3F);
					output += '=';
					break;
			}

			return output;
		}

		exports.toByteArray = b64ToByteArray;
		exports.fromByteArray = uint8ToBase64;
	})(typeof exports === 'undefined' ? this.base64js = {} : exports);
});
System.registerDynamic("npm:base64-js@0.0.8.js", ["npm:base64-js@0.0.8/lib/b64.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:base64-js@0.0.8/lib/b64.js");
});
System.registerDynamic("npm:ieee754@1.1.8/index.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };
});
System.registerDynamic("npm:ieee754@1.1.8.js", ["npm:ieee754@1.1.8/index.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:ieee754@1.1.8/index.js");
});
System.registerDynamic('npm:isarray@1.0.0/index.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toString = {}.toString;

  module.exports = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };
});
System.registerDynamic("npm:isarray@1.0.0.js", ["npm:isarray@1.0.0/index.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:isarray@1.0.0/index.js");
});
System.registerDynamic('npm:buffer@3.6.0/index.js', ['npm:base64-js@0.0.8.js', 'npm:ieee754@1.1.8.js', 'npm:isarray@1.0.0.js'], true, function ($__require, exports, module) {
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  /* eslint-disable no-proto */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var base64 = $__require('npm:base64-js@0.0.8.js');
  var ieee754 = $__require('npm:ieee754@1.1.8.js');
  var isArray = $__require('npm:isarray@1.0.0.js');

  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192; // not used by this implementation

  var rootParent = {};

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
   *     on objects.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.
  
   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

  function typedArraySupport() {
    function Bar() {}
    try {
      var arr = new Uint8Array(1);
      arr.foo = function () {
        return 42;
      };
      arr.constructor = Bar;
      return arr.foo() === 42 && // typed array instances can be augmented
      arr.constructor === Bar && // constructor can be set
      typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
      arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
    } catch (e) {
      return false;
    }
  }

  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }

  /**
   * Class: Buffer
   * =============
   *
   * The Buffer constructor returns instances of `Uint8Array` that are augmented
   * with function properties for all the node `Buffer` API functions. We use
   * `Uint8Array` so that square bracket notation works as expected -- it returns
   * a single octet.
   *
   * By augmenting the instances, we can avoid modifying the `Uint8Array`
   * prototype.
   */
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
      if (arguments.length > 1) return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }

    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      this.length = 0;
      this.parent = undefined;
    }

    // Common case.
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }

    // Slightly less common case.
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }

    // Unusual.
    return fromObject(this, arg);
  }

  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }

  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';

    // Assumption: byteLength() return value is always < kMaxLength.
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);

    that.write(string, encoding);
    return that;
  }

  function fromObject(that, object) {
    if (Buffer.isBuffer(object)) return fromBuffer(that, object);

    if (isArray(object)) return fromArray(that, object);

    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }

    if (typeof ArrayBuffer !== 'undefined') {
      if (object.buffer instanceof ArrayBuffer) {
        return fromTypedArray(that, object);
      }
      if (object instanceof ArrayBuffer) {
        return fromArrayBuffer(that, object);
      }
    }

    if (object.length) return fromArrayLike(that, object);

    return fromJsonObject(that, object);
  }

  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }

  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  // Duplicate of fromArray() to keep fromArray() monomorphic.
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    // Truncating the elements is probably not what people expect from typed
    // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
    // of the old Buffer constructor.
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  function fromArrayBuffer(that, array) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      array.byteLength;
      that = Buffer._augment(new Uint8Array(array));
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromTypedArray(that, new Uint8Array(array));
    }
    return that;
  }

  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  // Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
  // Returns a zero-length buffer for inputs that don't conform to the spec.
  function fromJsonObject(that, object) {
    var array;
    var length = 0;

    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);

    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  } else {
    // pre-set for values that may exist in the future
    Buffer.prototype.length = undefined;
    Buffer.prototype.parent = undefined;
  }

  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = Buffer._augment(new Uint8Array(length));
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that.length = length;
      that._isBuffer = true;
    }

    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool) that.parent = rootParent;

    return that;
  }

  function checked(length) {
    // Note: cannot use `length < kMaxLength` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }

  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding);

    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }

  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };

  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }

    if (a === b) return 0;

    var x = a.length;
    var y = b.length;

    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i]) break;

      ++i;
    }

    if (i !== len) {
      x = a[i];
      y = b[i];
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.');

    if (list.length === 0) {
      return new Buffer(0);
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }

    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };

  function byteLength(string, encoding) {
    if (typeof string !== 'string') string = '' + string;

    var len = string.length;
    if (len === 0) return 0;

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'binary':
        // Deprecated
        case 'raw':
        case 'raws':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase) return utf8ToBytes(string).length; // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false;

    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;

    if (!encoding) encoding = 'utf8';
    if (start < 0) start = 0;
    if (end > this.length) end = this.length;
    if (end <= start) return '';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'binary':
          return binarySlice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };

  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return 0;
    return Buffer.compare(this, b);
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;else if (byteOffset < -0x80000000) byteOffset = -0x80000000;
    byteOffset >>= 0;

    if (this.length === 0) return -1;
    if (byteOffset >= this.length) return -1;

    // Negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);

    if (typeof val === 'string') {
      if (val.length === 0) return -1; // special case: looking for empty string always fails
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }

    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }

    throw new TypeError('val must be string, number or Buffer');
  };

  // `get` is deprecated
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };

  // `set` is deprecated
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new Error('Invalid hex string');

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
      // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
      // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'binary':
          return binaryWrite(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }

  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }

    if (newBuf.length) newBuf.parent = this.parent || this;

    return newBuf;
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('index out of range');
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };

  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };

  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min) throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('index out of range');
    if (offset < 0) throw new RangeError('index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }

    return len;
  };

  // fill(value, start=0, end=buffer.length)
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value) value = 0;
    if (!start) start = 0;
    if (!end) end = this.length;

    if (end < start) throw new RangeError('end < start');

    // Fill 0 bytes; we're done
    if (end === start) return;
    if (this.length === 0) return;

    if (start < 0 || start >= this.length) throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length) throw new RangeError('end out of bounds');

    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }

    return this;
  };

  /**
   * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
   * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
   */
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return new Buffer(this).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0, len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };

  // HELPER FUNCTIONS
  // ================

  var BP = Buffer.prototype;

  /**
   * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
   */
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;

    // save reference to original Uint8Array set method before overwriting
    arr._set = arr.set;

    // deprecated
    arr.get = BP.get;
    arr.set = BP.set;

    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;

    return arr;
  };

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean(str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }

  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }

  function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; i++) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }

          // valid lead
          leadSurrogate = codePoint;

          continue;
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0) break;

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
});
System.registerDynamic("npm:buffer@3.6.0.js", ["npm:buffer@3.6.0/index.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:buffer@3.6.0/index.js");
});
System.registerDynamic('github:jspm/nodelibs-buffer@0.1.0/index.js', ['npm:buffer@3.6.0.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = System._nodeRequire ? System._nodeRequire('buffer') : $__require('npm:buffer@3.6.0.js');
});
System.registerDynamic("github:jspm/nodelibs-buffer@0.1.0.js", ["github:jspm/nodelibs-buffer@0.1.0/index.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("github:jspm/nodelibs-buffer@0.1.0/index.js");
});
System.registerDynamic('npm:assert@1.4.1/assert.js', ['npm:util@0.10.3.js', 'github:jspm/nodelibs-buffer@0.1.0.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    function compare(a, b) {
      if (a === b) {
        return 0;
      }
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    }
    function isBuffer(b) {
      if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
        return global.Buffer.isBuffer(b);
      }
      return !!(b != null && b._isBuffer);
    }
    var util = $__require('npm:util@0.10.3.js');
    var hasOwn = Object.prototype.hasOwnProperty;
    var pSlice = Array.prototype.slice;
    var functionsHaveNames = function () {
      return function foo() {}.name === 'foo';
    }();
    function pToString(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isView(arrbuf) {
      if (isBuffer(arrbuf)) {
        return false;
      }
      if (typeof global.ArrayBuffer !== 'function') {
        return false;
      }
      if (typeof ArrayBuffer.isView === 'function') {
        return ArrayBuffer.isView(arrbuf);
      }
      if (!arrbuf) {
        return false;
      }
      if (arrbuf instanceof DataView) {
        return true;
      }
      if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
        return true;
      }
      return false;
    }
    var assert = module.exports = ok;
    var regex = /\s*function\s+([^\(\s]*)\s*/;
    function getName(func) {
      if (!util.isFunction(func)) {
        return;
      }
      if (functionsHaveNames) {
        return func.name;
      }
      var str = func.toString();
      var match = str.match(regex);
      return match && match[1];
    }
    assert.AssertionError = function AssertionError(options) {
      this.name = 'AssertionError';
      this.actual = options.actual;
      this.expected = options.expected;
      this.operator = options.operator;
      if (options.message) {
        this.message = options.message;
        this.generatedMessage = false;
      } else {
        this.message = getMessage(this);
        this.generatedMessage = true;
      }
      var stackStartFunction = options.stackStartFunction || fail;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, stackStartFunction);
      } else {
        var err = new Error();
        if (err.stack) {
          var out = err.stack;
          var fn_name = getName(stackStartFunction);
          var idx = out.indexOf('\n' + fn_name);
          if (idx >= 0) {
            var next_line = out.indexOf('\n', idx + 1);
            out = out.substring(next_line + 1);
          }
          this.stack = out;
        }
      }
    };
    util.inherits(assert.AssertionError, Error);
    function truncate(s, n) {
      if (typeof s === 'string') {
        return s.length < n ? s : s.slice(0, n);
      } else {
        return s;
      }
    }
    function inspect(something) {
      if (functionsHaveNames || !util.isFunction(something)) {
        return util.inspect(something);
      }
      var rawname = getName(something);
      var name = rawname ? ': ' + rawname : '';
      return '[Function' + name + ']';
    }
    function getMessage(self) {
      return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
    }
    function fail(actual, expected, message, operator, stackStartFunction) {
      throw new assert.AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: operator,
        stackStartFunction: stackStartFunction
      });
    }
    assert.fail = fail;
    function ok(value, message) {
      if (!value) fail(value, true, message, '==', assert.ok);
    }
    assert.ok = ok;
    assert.equal = function equal(actual, expected, message) {
      if (actual != expected) fail(actual, expected, message, '==', assert.equal);
    };
    assert.notEqual = function notEqual(actual, expected, message) {
      if (actual == expected) {
        fail(actual, expected, message, '!=', assert.notEqual);
      }
    };
    assert.deepEqual = function deepEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'deepEqual', assert.deepEqual);
      }
    };
    assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
      }
    };
    function _deepEqual(actual, expected, strict, memos) {
      if (actual === expected) {
        return true;
      } else if (isBuffer(actual) && isBuffer(expected)) {
        return compare(actual, expected) === 0;
      } else if (util.isDate(actual) && util.isDate(expected)) {
        return actual.getTime() === expected.getTime();
      } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
        return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
      } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
        return strict ? actual === expected : actual == expected;
      } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
        return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
      } else if (isBuffer(actual) !== isBuffer(expected)) {
        return false;
      } else {
        memos = memos || {
          actual: [],
          expected: []
        };
        var actualIndex = memos.actual.indexOf(actual);
        if (actualIndex !== -1) {
          if (actualIndex === memos.expected.indexOf(expected)) {
            return true;
          }
        }
        memos.actual.push(actual);
        memos.expected.push(expected);
        return objEquiv(actual, expected, strict, memos);
      }
    }
    function isArguments(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    function objEquiv(a, b, strict, actualVisitedObjects) {
      if (a === null || a === undefined || b === null || b === undefined) return false;
      if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
      if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
      var aIsArgs = isArguments(a);
      var bIsArgs = isArguments(b);
      if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
      if (aIsArgs) {
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b, strict);
      }
      var ka = objectKeys(a);
      var kb = objectKeys(b);
      var key, i;
      if (ka.length !== kb.length) return false;
      ka.sort();
      kb.sort();
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] !== kb[i]) return false;
      }
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
      }
      return true;
    }
    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
      }
    };
    assert.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
      }
    }
    assert.strictEqual = function strictEqual(actual, expected, message) {
      if (actual !== expected) {
        fail(actual, expected, message, '===', assert.strictEqual);
      }
    };
    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (actual === expected) {
        fail(actual, expected, message, '!==', assert.notStrictEqual);
      }
    };
    function expectedException(actual, expected) {
      if (!actual || !expected) {
        return false;
      }
      if (Object.prototype.toString.call(expected) == '[object RegExp]') {
        return expected.test(actual);
      }
      try {
        if (actual instanceof expected) {
          return true;
        }
      } catch (e) {}
      if (Error.isPrototypeOf(expected)) {
        return false;
      }
      return expected.call({}, actual) === true;
    }
    function _tryBlock(block) {
      var error;
      try {
        block();
      } catch (e) {
        error = e;
      }
      return error;
    }
    function _throws(shouldThrow, block, expected, message) {
      var actual;
      if (typeof block !== 'function') {
        throw new TypeError('"block" argument must be a function');
      }
      if (typeof expected === 'string') {
        message = expected;
        expected = null;
      }
      actual = _tryBlock(block);
      message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');
      if (shouldThrow && !actual) {
        fail(actual, expected, 'Missing expected exception' + message);
      }
      var userProvidedMessage = typeof message === 'string';
      var isUnwantedException = !shouldThrow && util.isError(actual);
      var isUnexpectedException = !shouldThrow && actual && !expected;
      if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
        fail(actual, expected, 'Got unwanted exception' + message);
      }
      if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
        throw actual;
      }
    }
    assert.throws = function (block, error, message) {
      _throws(true, block, error, message);
    };
    assert.doesNotThrow = function (block, error, message) {
      _throws(false, block, error, message);
    };
    assert.ifError = function (err) {
      if (err) throw err;
    };
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) {
        if (hasOwn.call(obj, key)) keys.push(key);
      }
      return keys;
    };
  })($__require('github:jspm/nodelibs-buffer@0.1.0.js').Buffer);
});
System.registerDynamic("npm:assert@1.4.1.js", ["npm:assert@1.4.1/assert.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:assert@1.4.1/assert.js");
});
System.registerDynamic('github:jspm/nodelibs-assert@0.1.0/index.js', ['npm:assert@1.4.1.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = System._nodeRequire ? System._nodeRequire('assert') : $__require('npm:assert@1.4.1.js');
});
System.registerDynamic("github:jspm/nodelibs-assert@0.1.0.js", ["github:jspm/nodelibs-assert@0.1.0/index.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("github:jspm/nodelibs-assert@0.1.0/index.js");
});
System.registerDynamic("npm:ast-types@0.9.2/lib/equiv.js", ["npm:ast-types@0.9.2/lib/types.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    var types = fork.use($__require("npm:ast-types@0.9.2/lib/types.js"));
    var getFieldNames = types.getFieldNames;
    var getFieldValue = types.getFieldValue;
    var isArray = types.builtInTypes.array;
    var isObject = types.builtInTypes.object;
    var isDate = types.builtInTypes.Date;
    var isRegExp = types.builtInTypes.RegExp;
    var hasOwn = Object.prototype.hasOwnProperty;
    function astNodesAreEquivalent(a, b, problemPath) {
      if (isArray.check(problemPath)) {
        problemPath.length = 0;
      } else {
        problemPath = null;
      }
      return areEquivalent(a, b, problemPath);
    }
    astNodesAreEquivalent.assert = function (a, b) {
      var problemPath = [];
      if (!astNodesAreEquivalent(a, b, problemPath)) {
        if (problemPath.length === 0) {
          if (a !== b) {
            throw new Error("Nodes must be equal");
          }
        } else {
          throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
        }
      }
    };
    function subscriptForProperty(property) {
      if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
        return "." + property;
      }
      return "[" + JSON.stringify(property) + "]";
    }
    function areEquivalent(a, b, problemPath) {
      if (a === b) {
        return true;
      }
      if (isArray.check(a)) {
        return arraysAreEquivalent(a, b, problemPath);
      }
      if (isObject.check(a)) {
        return objectsAreEquivalent(a, b, problemPath);
      }
      if (isDate.check(a)) {
        return isDate.check(b) && +a === +b;
      }
      if (isRegExp.check(a)) {
        return isRegExp.check(b) && a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase;
      }
      return a == b;
    }
    function arraysAreEquivalent(a, b, problemPath) {
      isArray.assert(a);
      var aLength = a.length;
      if (!isArray.check(b) || b.length !== aLength) {
        if (problemPath) {
          problemPath.push("length");
        }
        return false;
      }
      for (var i = 0; i < aLength; ++i) {
        if (problemPath) {
          problemPath.push(i);
        }
        if (i in a !== i in b) {
          return false;
        }
        if (!areEquivalent(a[i], b[i], problemPath)) {
          return false;
        }
        if (problemPath) {
          var problemPathTail = problemPath.pop();
          if (problemPathTail !== i) {
            throw new Error("" + problemPathTail);
          }
        }
      }
      return true;
    }
    function objectsAreEquivalent(a, b, problemPath) {
      isObject.assert(a);
      if (!isObject.check(b)) {
        return false;
      }
      if (a.type !== b.type) {
        if (problemPath) {
          problemPath.push("type");
        }
        return false;
      }
      var aNames = getFieldNames(a);
      var aNameCount = aNames.length;
      var bNames = getFieldNames(b);
      var bNameCount = bNames.length;
      if (aNameCount === bNameCount) {
        for (var i = 0; i < aNameCount; ++i) {
          var name = aNames[i];
          var aChild = getFieldValue(a, name);
          var bChild = getFieldValue(b, name);
          if (problemPath) {
            problemPath.push(name);
          }
          if (!areEquivalent(aChild, bChild, problemPath)) {
            return false;
          }
          if (problemPath) {
            var problemPathTail = problemPath.pop();
            if (problemPathTail !== name) {
              throw new Error("" + problemPathTail);
            }
          }
        }
        return true;
      }
      if (!problemPath) {
        return false;
      }
      var seenNames = Object.create(null);
      for (i = 0; i < aNameCount; ++i) {
        seenNames[aNames[i]] = true;
      }
      for (i = 0; i < bNameCount; ++i) {
        name = bNames[i];
        if (!hasOwn.call(seenNames, name)) {
          problemPath.push(name);
          return false;
        }
        delete seenNames[name];
      }
      for (name in seenNames) {
        problemPath.push(name);
        break;
      }
      return false;
    }
    return astNodesAreEquivalent;
  };
});
System.registerDynamic("npm:ast-types@0.9.2/lib/path.js", ["npm:ast-types@0.9.2/lib/types.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var Ap = Array.prototype;
  var slice = Ap.slice;
  var map = Ap.map;
  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  module.exports = function (fork) {
    var types = fork.use($__require("npm:ast-types@0.9.2/lib/types.js"));
    var isArray = types.builtInTypes.array;
    var isNumber = types.builtInTypes.number;
    function Path(value, parentPath, name) {
      if (!(this instanceof Path)) {
        throw new Error("Path constructor cannot be invoked without 'new'");
      }
      if (parentPath) {
        if (!(parentPath instanceof Path)) {
          throw new Error("");
        }
      } else {
        parentPath = null;
        name = null;
      }
      this.value = value;
      this.parentPath = parentPath;
      this.name = name;
      this.__childCache = null;
    }
    var Pp = Path.prototype;
    function getChildCache(path) {
      return path.__childCache || (path.__childCache = Object.create(null));
    }
    function getChildPath(path, name) {
      var cache = getChildCache(path);
      var actualChildValue = path.getValueProperty(name);
      var childPath = cache[name];
      if (!hasOwn.call(cache, name) || childPath.value !== actualChildValue) {
        childPath = cache[name] = new path.constructor(actualChildValue, path, name);
      }
      return childPath;
    }
    Pp.getValueProperty = function getValueProperty(name) {
      return this.value[name];
    };
    Pp.get = function get(name) {
      var path = this;
      var names = arguments;
      var count = names.length;
      for (var i = 0; i < count; ++i) {
        path = getChildPath(path, names[i]);
      }
      return path;
    };
    Pp.each = function each(callback, context) {
      var childPaths = [];
      var len = this.value.length;
      var i = 0;
      for (var i = 0; i < len; ++i) {
        if (hasOwn.call(this.value, i)) {
          childPaths[i] = this.get(i);
        }
      }
      context = context || this;
      for (i = 0; i < len; ++i) {
        if (hasOwn.call(childPaths, i)) {
          callback.call(context, childPaths[i]);
        }
      }
    };
    Pp.map = function map(callback, context) {
      var result = [];
      this.each(function (childPath) {
        result.push(callback.call(this, childPath));
      }, context);
      return result;
    };
    Pp.filter = function filter(callback, context) {
      var result = [];
      this.each(function (childPath) {
        if (callback.call(this, childPath)) {
          result.push(childPath);
        }
      }, context);
      return result;
    };
    function emptyMoves() {}
    function getMoves(path, offset, start, end) {
      isArray.assert(path.value);
      if (offset === 0) {
        return emptyMoves;
      }
      var length = path.value.length;
      if (length < 1) {
        return emptyMoves;
      }
      var argc = arguments.length;
      if (argc === 2) {
        start = 0;
        end = length;
      } else if (argc === 3) {
        start = Math.max(start, 0);
        end = length;
      } else {
        start = Math.max(start, 0);
        end = Math.min(end, length);
      }
      isNumber.assert(start);
      isNumber.assert(end);
      var moves = Object.create(null);
      var cache = getChildCache(path);
      for (var i = start; i < end; ++i) {
        if (hasOwn.call(path.value, i)) {
          var childPath = path.get(i);
          if (childPath.name !== i) {
            throw new Error("");
          }
          var newIndex = i + offset;
          childPath.name = newIndex;
          moves[newIndex] = childPath;
          delete cache[i];
        }
      }
      delete cache.length;
      return function () {
        for (var newIndex in moves) {
          var childPath = moves[newIndex];
          if (childPath.name !== +newIndex) {
            throw new Error("");
          }
          cache[newIndex] = childPath;
          path.value[newIndex] = childPath.value;
        }
      };
    }
    Pp.shift = function shift() {
      var move = getMoves(this, -1);
      var result = this.value.shift();
      move();
      return result;
    };
    Pp.unshift = function unshift(node) {
      var move = getMoves(this, arguments.length);
      var result = this.value.unshift.apply(this.value, arguments);
      move();
      return result;
    };
    Pp.push = function push(node) {
      isArray.assert(this.value);
      delete getChildCache(this).length;
      return this.value.push.apply(this.value, arguments);
    };
    Pp.pop = function pop() {
      isArray.assert(this.value);
      var cache = getChildCache(this);
      delete cache[this.value.length - 1];
      delete cache.length;
      return this.value.pop();
    };
    Pp.insertAt = function insertAt(index, node) {
      var argc = arguments.length;
      var move = getMoves(this, argc - 1, index);
      if (move === emptyMoves) {
        return this;
      }
      index = Math.max(index, 0);
      for (var i = 1; i < argc; ++i) {
        this.value[index + i - 1] = arguments[i];
      }
      move();
      return this;
    };
    Pp.insertBefore = function insertBefore(node) {
      var pp = this.parentPath;
      var argc = arguments.length;
      var insertAtArgs = [this.name];
      for (var i = 0; i < argc; ++i) {
        insertAtArgs.push(arguments[i]);
      }
      return pp.insertAt.apply(pp, insertAtArgs);
    };
    Pp.insertAfter = function insertAfter(node) {
      var pp = this.parentPath;
      var argc = arguments.length;
      var insertAtArgs = [this.name + 1];
      for (var i = 0; i < argc; ++i) {
        insertAtArgs.push(arguments[i]);
      }
      return pp.insertAt.apply(pp, insertAtArgs);
    };
    function repairRelationshipWithParent(path) {
      if (!(path instanceof Path)) {
        throw new Error("");
      }
      var pp = path.parentPath;
      if (!pp) {
        return path;
      }
      var parentValue = pp.value;
      var parentCache = getChildCache(pp);
      if (parentValue[path.name] === path.value) {
        parentCache[path.name] = path;
      } else if (isArray.check(parentValue)) {
        var i = parentValue.indexOf(path.value);
        if (i >= 0) {
          parentCache[path.name = i] = path;
        }
      } else {
        parentValue[path.name] = path.value;
        parentCache[path.name] = path;
      }
      if (parentValue[path.name] !== path.value) {
        throw new Error("");
      }
      if (path.parentPath.get(path.name) !== path) {
        throw new Error("");
      }
      return path;
    }
    Pp.replace = function replace(replacement) {
      var results = [];
      var parentValue = this.parentPath.value;
      var parentCache = getChildCache(this.parentPath);
      var count = arguments.length;
      repairRelationshipWithParent(this);
      if (isArray.check(parentValue)) {
        var originalLength = parentValue.length;
        var move = getMoves(this.parentPath, count - 1, this.name + 1);
        var spliceArgs = [this.name, 1];
        for (var i = 0; i < count; ++i) {
          spliceArgs.push(arguments[i]);
        }
        var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
        if (splicedOut[0] !== this.value) {
          throw new Error("");
        }
        if (parentValue.length !== originalLength - 1 + count) {
          throw new Error("");
        }
        move();
        if (count === 0) {
          delete this.value;
          delete parentCache[this.name];
          this.__childCache = null;
        } else {
          if (parentValue[this.name] !== replacement) {
            throw new Error("");
          }
          if (this.value !== replacement) {
            this.value = replacement;
            this.__childCache = null;
          }
          for (i = 0; i < count; ++i) {
            results.push(this.parentPath.get(this.name + i));
          }
          if (results[0] !== this) {
            throw new Error("");
          }
        }
      } else if (count === 1) {
        if (this.value !== replacement) {
          this.__childCache = null;
        }
        this.value = parentValue[this.name] = replacement;
        results.push(this);
      } else if (count === 0) {
        delete parentValue[this.name];
        delete this.value;
        this.__childCache = null;
      } else {
        throw new Error("Could not replace path");
      }
      return results;
    };
    return Path;
  };
});
System.registerDynamic('npm:ast-types@0.9.2/lib/scope.js', ['npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/node-path.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var hasOwn = Object.prototype.hasOwnProperty;
  module.exports = function (fork) {
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var Type = types.Type;
    var namedTypes = types.namedTypes;
    var Node = namedTypes.Node;
    var Expression = namedTypes.Expression;
    var isArray = types.builtInTypes.array;
    var b = types.builders;
    function Scope(path, parentScope) {
      if (!(this instanceof Scope)) {
        throw new Error("Scope constructor cannot be invoked without 'new'");
      }
      if (!(path instanceof fork.use($__require('npm:ast-types@0.9.2/lib/node-path.js')))) {
        throw new Error("");
      }
      ScopeType.assert(path.value);
      var depth;
      if (parentScope) {
        if (!(parentScope instanceof Scope)) {
          throw new Error("");
        }
        depth = parentScope.depth + 1;
      } else {
        parentScope = null;
        depth = 0;
      }
      Object.defineProperties(this, {
        path: { value: path },
        node: { value: path.value },
        isGlobal: {
          value: !parentScope,
          enumerable: true
        },
        depth: { value: depth },
        parent: { value: parentScope },
        bindings: { value: {} },
        types: { value: {} }
      });
    }
    var scopeTypes = [namedTypes.Program, namedTypes.Function, namedTypes.CatchClause];
    var ScopeType = Type.or.apply(Type, scopeTypes);
    Scope.isEstablishedBy = function (node) {
      return ScopeType.check(node);
    };
    var Sp = Scope.prototype;
    Sp.didScan = false;
    Sp.declares = function (name) {
      this.scan();
      return hasOwn.call(this.bindings, name);
    };
    Sp.declaresType = function (name) {
      this.scan();
      return hasOwn.call(this.types, name);
    };
    Sp.declareTemporary = function (prefix) {
      if (prefix) {
        if (!/^[a-z$_]/i.test(prefix)) {
          throw new Error("");
        }
      } else {
        prefix = "t$";
      }
      prefix += this.depth.toString(36) + "$";
      this.scan();
      var index = 0;
      while (this.declares(prefix + index)) {
        ++index;
      }
      var name = prefix + index;
      return this.bindings[name] = types.builders.identifier(name);
    };
    Sp.injectTemporary = function (identifier, init) {
      identifier || (identifier = this.declareTemporary());
      var bodyPath = this.path.get("body");
      if (namedTypes.BlockStatement.check(bodyPath.value)) {
        bodyPath = bodyPath.get("body");
      }
      bodyPath.unshift(b.variableDeclaration("var", [b.variableDeclarator(identifier, init || null)]));
      return identifier;
    };
    Sp.scan = function (force) {
      if (force || !this.didScan) {
        for (var name in this.bindings) {
          delete this.bindings[name];
        }
        scanScope(this.path, this.bindings, this.types);
        this.didScan = true;
      }
    };
    Sp.getBindings = function () {
      this.scan();
      return this.bindings;
    };
    Sp.getTypes = function () {
      this.scan();
      return this.types;
    };
    function scanScope(path, bindings, scopeTypes) {
      var node = path.value;
      ScopeType.assert(node);
      if (namedTypes.CatchClause.check(node)) {
        addPattern(path.get("param"), bindings);
      } else {
        recursiveScanScope(path, bindings, scopeTypes);
      }
    }
    function recursiveScanScope(path, bindings, scopeTypes) {
      var node = path.value;
      if (path.parent && namedTypes.FunctionExpression.check(path.parent.node) && path.parent.node.id) {
        addPattern(path.parent.get("id"), bindings);
      }
      if (!node) {} else if (isArray.check(node)) {
        path.each(function (childPath) {
          recursiveScanChild(childPath, bindings, scopeTypes);
        });
      } else if (namedTypes.Function.check(node)) {
        path.get("params").each(function (paramPath) {
          addPattern(paramPath, bindings);
        });
        recursiveScanChild(path.get("body"), bindings, scopeTypes);
      } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) {
        addTypePattern(path.get("id"), scopeTypes);
      } else if (namedTypes.VariableDeclarator.check(node)) {
        addPattern(path.get("id"), bindings);
        recursiveScanChild(path.get("init"), bindings, scopeTypes);
      } else if (node.type === "ImportSpecifier" || node.type === "ImportNamespaceSpecifier" || node.type === "ImportDefaultSpecifier") {
        addPattern(path.get(node.local ? "local" : node.name ? "name" : "id"), bindings);
      } else if (Node.check(node) && !Expression.check(node)) {
        types.eachField(node, function (name, child) {
          var childPath = path.get(name);
          if (!pathHasValue(childPath, child)) {
            throw new Error("");
          }
          recursiveScanChild(childPath, bindings, scopeTypes);
        });
      }
    }
    function pathHasValue(path, value) {
      if (path.value === value) {
        return true;
      }
      if (Array.isArray(path.value) && path.value.length === 0 && Array.isArray(value) && value.length === 0) {
        return true;
      }
      return false;
    }
    function recursiveScanChild(path, bindings, scopeTypes) {
      var node = path.value;
      if (!node || Expression.check(node)) {} else if (namedTypes.FunctionDeclaration.check(node) && node.id !== null) {
        addPattern(path.get("id"), bindings);
      } else if (namedTypes.ClassDeclaration && namedTypes.ClassDeclaration.check(node)) {
        addPattern(path.get("id"), bindings);
      } else if (ScopeType.check(node)) {
        if (namedTypes.CatchClause.check(node)) {
          var catchParamName = node.param.name;
          var hadBinding = hasOwn.call(bindings, catchParamName);
          recursiveScanScope(path.get("body"), bindings, scopeTypes);
          if (!hadBinding) {
            delete bindings[catchParamName];
          }
        }
      } else {
        recursiveScanScope(path, bindings, scopeTypes);
      }
    }
    function addPattern(patternPath, bindings) {
      var pattern = patternPath.value;
      namedTypes.Pattern.assert(pattern);
      if (namedTypes.Identifier.check(pattern)) {
        if (hasOwn.call(bindings, pattern.name)) {
          bindings[pattern.name].push(patternPath);
        } else {
          bindings[pattern.name] = [patternPath];
        }
      } else if (namedTypes.ObjectPattern && namedTypes.ObjectPattern.check(pattern)) {
        patternPath.get('properties').each(function (propertyPath) {
          var property = propertyPath.value;
          if (namedTypes.Pattern.check(property)) {
            addPattern(propertyPath, bindings);
          } else if (namedTypes.Property.check(property)) {
            addPattern(propertyPath.get('value'), bindings);
          } else if (namedTypes.SpreadProperty && namedTypes.SpreadProperty.check(property)) {
            addPattern(propertyPath.get('argument'), bindings);
          }
        });
      } else if (namedTypes.ArrayPattern && namedTypes.ArrayPattern.check(pattern)) {
        patternPath.get('elements').each(function (elementPath) {
          var element = elementPath.value;
          if (namedTypes.Pattern.check(element)) {
            addPattern(elementPath, bindings);
          } else if (namedTypes.SpreadElement && namedTypes.SpreadElement.check(element)) {
            addPattern(elementPath.get("argument"), bindings);
          }
        });
      } else if (namedTypes.PropertyPattern && namedTypes.PropertyPattern.check(pattern)) {
        addPattern(patternPath.get('pattern'), bindings);
      } else if (namedTypes.SpreadElementPattern && namedTypes.SpreadElementPattern.check(pattern) || namedTypes.SpreadPropertyPattern && namedTypes.SpreadPropertyPattern.check(pattern)) {
        addPattern(patternPath.get('argument'), bindings);
      }
    }
    function addTypePattern(patternPath, types) {
      var pattern = patternPath.value;
      namedTypes.Pattern.assert(pattern);
      if (namedTypes.Identifier.check(pattern)) {
        if (hasOwn.call(types, pattern.name)) {
          types[pattern.name].push(patternPath);
        } else {
          types[pattern.name] = [patternPath];
        }
      }
    }
    Sp.lookup = function (name) {
      for (var scope = this; scope; scope = scope.parent) if (scope.declares(name)) break;
      return scope;
    };
    Sp.lookupType = function (name) {
      for (var scope = this; scope; scope = scope.parent) if (scope.declaresType(name)) break;
      return scope;
    };
    Sp.getGlobalScope = function () {
      var scope = this;
      while (!scope.isGlobal) scope = scope.parent;
      return scope;
    };
    return Scope;
  };
});
System.registerDynamic('npm:ast-types@0.9.2/lib/node-path.js', ['npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/path.js', 'npm:ast-types@0.9.2/lib/scope.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var n = types.namedTypes;
    var b = types.builders;
    var isNumber = types.builtInTypes.number;
    var isArray = types.builtInTypes.array;
    var Path = fork.use($__require('npm:ast-types@0.9.2/lib/path.js'));
    var Scope = fork.use($__require('npm:ast-types@0.9.2/lib/scope.js'));
    function NodePath(value, parentPath, name) {
      if (!(this instanceof NodePath)) {
        throw new Error("NodePath constructor cannot be invoked without 'new'");
      }
      Path.call(this, value, parentPath, name);
    }
    var NPp = NodePath.prototype = Object.create(Path.prototype, { constructor: {
        value: NodePath,
        enumerable: false,
        writable: true,
        configurable: true
      } });
    Object.defineProperties(NPp, {
      node: { get: function () {
          Object.defineProperty(this, "node", {
            configurable: true,
            value: this._computeNode()
          });
          return this.node;
        } },
      parent: { get: function () {
          Object.defineProperty(this, "parent", {
            configurable: true,
            value: this._computeParent()
          });
          return this.parent;
        } },
      scope: { get: function () {
          Object.defineProperty(this, "scope", {
            configurable: true,
            value: this._computeScope()
          });
          return this.scope;
        } }
    });
    NPp.replace = function () {
      delete this.node;
      delete this.parent;
      delete this.scope;
      return Path.prototype.replace.apply(this, arguments);
    };
    NPp.prune = function () {
      var remainingNodePath = this.parent;
      this.replace();
      return cleanUpNodesAfterPrune(remainingNodePath);
    };
    NPp._computeNode = function () {
      var value = this.value;
      if (n.Node.check(value)) {
        return value;
      }
      var pp = this.parentPath;
      return pp && pp.node || null;
    };
    NPp._computeParent = function () {
      var value = this.value;
      var pp = this.parentPath;
      if (!n.Node.check(value)) {
        while (pp && !n.Node.check(pp.value)) {
          pp = pp.parentPath;
        }
        if (pp) {
          pp = pp.parentPath;
        }
      }
      while (pp && !n.Node.check(pp.value)) {
        pp = pp.parentPath;
      }
      return pp || null;
    };
    NPp._computeScope = function () {
      var value = this.value;
      var pp = this.parentPath;
      var scope = pp && pp.scope;
      if (n.Node.check(value) && Scope.isEstablishedBy(value)) {
        scope = new Scope(this, scope);
      }
      return scope || null;
    };
    NPp.getValueProperty = function (name) {
      return types.getFieldValue(this.value, name);
    };
    NPp.needsParens = function (assumeExpressionContext) {
      var pp = this.parentPath;
      if (!pp) {
        return false;
      }
      var node = this.value;
      if (!n.Expression.check(node)) {
        return false;
      }
      if (node.type === "Identifier") {
        return false;
      }
      while (!n.Node.check(pp.value)) {
        pp = pp.parentPath;
        if (!pp) {
          return false;
        }
      }
      var parent = pp.value;
      switch (node.type) {
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
          return parent.type === "MemberExpression" && this.name === "object" && parent.object === node;
        case "BinaryExpression":
        case "LogicalExpression":
          switch (parent.type) {
            case "CallExpression":
              return this.name === "callee" && parent.callee === node;
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
              return true;
            case "MemberExpression":
              return this.name === "object" && parent.object === node;
            case "BinaryExpression":
            case "LogicalExpression":
              var po = parent.operator;
              var pp = PRECEDENCE[po];
              var no = node.operator;
              var np = PRECEDENCE[no];
              if (pp > np) {
                return true;
              }
              if (pp === np && this.name === "right") {
                if (parent.right !== node) {
                  throw new Error("Nodes must be equal");
                }
                return true;
              }
            default:
              return false;
          }
        case "SequenceExpression":
          switch (parent.type) {
            case "ForStatement":
              return false;
            case "ExpressionStatement":
              return this.name !== "expression";
            default:
              return true;
          }
        case "YieldExpression":
          switch (parent.type) {
            case "BinaryExpression":
            case "LogicalExpression":
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
            case "CallExpression":
            case "MemberExpression":
            case "NewExpression":
            case "ConditionalExpression":
            case "YieldExpression":
              return true;
            default:
              return false;
          }
        case "Literal":
          return parent.type === "MemberExpression" && isNumber.check(node.value) && this.name === "object" && parent.object === node;
        case "AssignmentExpression":
        case "ConditionalExpression":
          switch (parent.type) {
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
            case "BinaryExpression":
            case "LogicalExpression":
              return true;
            case "CallExpression":
              return this.name === "callee" && parent.callee === node;
            case "ConditionalExpression":
              return this.name === "test" && parent.test === node;
            case "MemberExpression":
              return this.name === "object" && parent.object === node;
            default:
              return false;
          }
        default:
          if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node) {
            return containsCallExpression(node);
          }
      }
      if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) return true;
      return false;
    };
    function isBinary(node) {
      return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);
    }
    function isUnaryLike(node) {
      return n.UnaryExpression.check(node) || n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);
    }
    var PRECEDENCE = {};
    [["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"]].forEach(function (tier, i) {
      tier.forEach(function (op) {
        PRECEDENCE[op] = i;
      });
    });
    function containsCallExpression(node) {
      if (n.CallExpression.check(node)) {
        return true;
      }
      if (isArray.check(node)) {
        return node.some(containsCallExpression);
      }
      if (n.Node.check(node)) {
        return types.someField(node, function (name, child) {
          return containsCallExpression(child);
        });
      }
      return false;
    }
    NPp.canBeFirstInStatement = function () {
      var node = this.node;
      return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);
    };
    NPp.firstInStatement = function () {
      return firstInStatement(this);
    };
    function firstInStatement(path) {
      for (var node, parent; path.parent; path = path.parent) {
        node = path.node;
        parent = path.parent.node;
        if (n.BlockStatement.check(parent) && path.parent.name === "body" && path.name === 0) {
          if (parent.body[0] !== node) {
            throw new Error("Nodes must be equal");
          }
          return true;
        }
        if (n.ExpressionStatement.check(parent) && path.name === "expression") {
          if (parent.expression !== node) {
            throw new Error("Nodes must be equal");
          }
          return true;
        }
        if (n.SequenceExpression.check(parent) && path.parent.name === "expressions" && path.name === 0) {
          if (parent.expressions[0] !== node) {
            throw new Error("Nodes must be equal");
          }
          continue;
        }
        if (n.CallExpression.check(parent) && path.name === "callee") {
          if (parent.callee !== node) {
            throw new Error("Nodes must be equal");
          }
          continue;
        }
        if (n.MemberExpression.check(parent) && path.name === "object") {
          if (parent.object !== node) {
            throw new Error("Nodes must be equal");
          }
          continue;
        }
        if (n.ConditionalExpression.check(parent) && path.name === "test") {
          if (parent.test !== node) {
            throw new Error("Nodes must be equal");
          }
          continue;
        }
        if (isBinary(parent) && path.name === "left") {
          if (parent.left !== node) {
            throw new Error("Nodes must be equal");
          }
          continue;
        }
        if (n.UnaryExpression.check(parent) && !parent.prefix && path.name === "argument") {
          if (parent.argument !== node) {
            throw new Error("Nodes must be equal");
          }
          continue;
        }
        return false;
      }
      return true;
    }
    function cleanUpNodesAfterPrune(remainingNodePath) {
      if (n.VariableDeclaration.check(remainingNodePath.node)) {
        var declarations = remainingNodePath.get('declarations').value;
        if (!declarations || declarations.length === 0) {
          return remainingNodePath.prune();
        }
      } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
        if (!remainingNodePath.get('expression').value) {
          return remainingNodePath.prune();
        }
      } else if (n.IfStatement.check(remainingNodePath.node)) {
        cleanUpIfStatementAfterPrune(remainingNodePath);
      }
      return remainingNodePath;
    }
    function cleanUpIfStatementAfterPrune(ifStatement) {
      var testExpression = ifStatement.get('test').value;
      var alternate = ifStatement.get('alternate').value;
      var consequent = ifStatement.get('consequent').value;
      if (!consequent && !alternate) {
        var testExpressionStatement = b.expressionStatement(testExpression);
        ifStatement.replace(testExpressionStatement);
      } else if (!consequent && alternate) {
        var negatedTestExpression = b.unaryExpression('!', testExpression, true);
        if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {
          negatedTestExpression = testExpression.argument;
        }
        ifStatement.get("test").replace(negatedTestExpression);
        ifStatement.get("consequent").replace(alternate);
        ifStatement.get("alternate").replace();
      }
    }
    return NodePath;
  };
});
System.registerDynamic('npm:ast-types@0.9.2/lib/path-visitor.js', ['npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/node-path.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var hasOwn = Object.prototype.hasOwnProperty;
  module.exports = function (fork) {
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var NodePath = fork.use($__require('npm:ast-types@0.9.2/lib/node-path.js'));
    var Printable = types.namedTypes.Printable;
    var isArray = types.builtInTypes.array;
    var isObject = types.builtInTypes.object;
    var isFunction = types.builtInTypes.function;
    var undefined;
    function PathVisitor() {
      if (!(this instanceof PathVisitor)) {
        throw new Error("PathVisitor constructor cannot be invoked without 'new'");
      }
      this._reusableContextStack = [];
      this._methodNameTable = computeMethodNameTable(this);
      this._shouldVisitComments = hasOwn.call(this._methodNameTable, "Block") || hasOwn.call(this._methodNameTable, "Line");
      this.Context = makeContextConstructor(this);
      this._visiting = false;
      this._changeReported = false;
    }
    function computeMethodNameTable(visitor) {
      var typeNames = Object.create(null);
      for (var methodName in visitor) {
        if (/^visit[A-Z]/.test(methodName)) {
          typeNames[methodName.slice("visit".length)] = true;
        }
      }
      var supertypeTable = types.computeSupertypeLookupTable(typeNames);
      var methodNameTable = Object.create(null);
      var typeNames = Object.keys(supertypeTable);
      var typeNameCount = typeNames.length;
      for (var i = 0; i < typeNameCount; ++i) {
        var typeName = typeNames[i];
        methodName = "visit" + supertypeTable[typeName];
        if (isFunction.check(visitor[methodName])) {
          methodNameTable[typeName] = methodName;
        }
      }
      return methodNameTable;
    }
    PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
      if (methods instanceof PathVisitor) {
        return methods;
      }
      if (!isObject.check(methods)) {
        return new PathVisitor();
      }
      function Visitor() {
        if (!(this instanceof Visitor)) {
          throw new Error("Visitor constructor cannot be invoked without 'new'");
        }
        PathVisitor.call(this);
      }
      var Vp = Visitor.prototype = Object.create(PVp);
      Vp.constructor = Visitor;
      extend(Vp, methods);
      extend(Visitor, PathVisitor);
      isFunction.assert(Visitor.fromMethodsObject);
      isFunction.assert(Visitor.visit);
      return new Visitor();
    };
    function extend(target, source) {
      for (var property in source) {
        if (hasOwn.call(source, property)) {
          target[property] = source[property];
        }
      }
      return target;
    }
    PathVisitor.visit = function visit(node, methods) {
      return PathVisitor.fromMethodsObject(methods).visit(node);
    };
    var PVp = PathVisitor.prototype;
    PVp.visit = function () {
      if (this._visiting) {
        throw new Error("Recursively calling visitor.visit(path) resets visitor state. " + "Try this.visit(path) or this.traverse(path) instead.");
      }
      this._visiting = true;
      this._changeReported = false;
      this._abortRequested = false;
      var argc = arguments.length;
      var args = new Array(argc);
      for (var i = 0; i < argc; ++i) {
        args[i] = arguments[i];
      }
      if (!(args[0] instanceof NodePath)) {
        args[0] = new NodePath({ root: args[0] }).get("root");
      }
      this.reset.apply(this, args);
      try {
        var root = this.visitWithoutReset(args[0]);
        var didNotThrow = true;
      } finally {
        this._visiting = false;
        if (!didNotThrow && this._abortRequested) {
          return args[0].value;
        }
      }
      return root;
    };
    PVp.AbortRequest = function AbortRequest() {};
    PVp.abort = function () {
      var visitor = this;
      visitor._abortRequested = true;
      var request = new visitor.AbortRequest();
      request.cancel = function () {
        visitor._abortRequested = false;
      };
      throw request;
    };
    PVp.reset = function (path) {};
    PVp.visitWithoutReset = function (path) {
      if (this instanceof this.Context) {
        return this.visitor.visitWithoutReset(path);
      }
      if (!(path instanceof NodePath)) {
        throw new Error("");
      }
      var value = path.value;
      var methodName = value && typeof value === "object" && typeof value.type === "string" && this._methodNameTable[value.type];
      if (methodName) {
        var context = this.acquireContext(path);
        try {
          return context.invokeVisitorMethod(methodName);
        } finally {
          this.releaseContext(context);
        }
      } else {
        return visitChildren(path, this);
      }
    };
    function visitChildren(path, visitor) {
      if (!(path instanceof NodePath)) {
        throw new Error("");
      }
      if (!(visitor instanceof PathVisitor)) {
        throw new Error("");
      }
      var value = path.value;
      if (isArray.check(value)) {
        path.each(visitor.visitWithoutReset, visitor);
      } else if (!isObject.check(value)) {} else {
        var childNames = types.getFieldNames(value);
        if (visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0) {
          childNames.push("comments");
        }
        var childCount = childNames.length;
        var childPaths = [];
        for (var i = 0; i < childCount; ++i) {
          var childName = childNames[i];
          if (!hasOwn.call(value, childName)) {
            value[childName] = types.getFieldValue(value, childName);
          }
          childPaths.push(path.get(childName));
        }
        for (var i = 0; i < childCount; ++i) {
          visitor.visitWithoutReset(childPaths[i]);
        }
      }
      return path.value;
    }
    PVp.acquireContext = function (path) {
      if (this._reusableContextStack.length === 0) {
        return new this.Context(path);
      }
      return this._reusableContextStack.pop().reset(path);
    };
    PVp.releaseContext = function (context) {
      if (!(context instanceof this.Context)) {
        throw new Error("");
      }
      this._reusableContextStack.push(context);
      context.currentPath = null;
    };
    PVp.reportChanged = function () {
      this._changeReported = true;
    };
    PVp.wasChangeReported = function () {
      return this._changeReported;
    };
    function makeContextConstructor(visitor) {
      function Context(path) {
        if (!(this instanceof Context)) {
          throw new Error("");
        }
        if (!(this instanceof PathVisitor)) {
          throw new Error("");
        }
        if (!(path instanceof NodePath)) {
          throw new Error("");
        }
        Object.defineProperty(this, "visitor", {
          value: visitor,
          writable: false,
          enumerable: true,
          configurable: false
        });
        this.currentPath = path;
        this.needToCallTraverse = true;
        Object.seal(this);
      }
      if (!(visitor instanceof PathVisitor)) {
        throw new Error("");
      }
      var Cp = Context.prototype = Object.create(visitor);
      Cp.constructor = Context;
      extend(Cp, sharedContextProtoMethods);
      return Context;
    }
    var sharedContextProtoMethods = Object.create(null);
    sharedContextProtoMethods.reset = function reset(path) {
      if (!(this instanceof this.Context)) {
        throw new Error("");
      }
      if (!(path instanceof NodePath)) {
        throw new Error("");
      }
      this.currentPath = path;
      this.needToCallTraverse = true;
      return this;
    };
    sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {
      if (!(this instanceof this.Context)) {
        throw new Error("");
      }
      if (!(this.currentPath instanceof NodePath)) {
        throw new Error("");
      }
      var result = this.visitor[methodName].call(this, this.currentPath);
      if (result === false) {
        this.needToCallTraverse = false;
      } else if (result !== undefined) {
        this.currentPath = this.currentPath.replace(result)[0];
        if (this.needToCallTraverse) {
          this.traverse(this.currentPath);
        }
      }
      if (this.needToCallTraverse !== false) {
        throw new Error("Must either call this.traverse or return false in " + methodName);
      }
      var path = this.currentPath;
      return path && path.value;
    };
    sharedContextProtoMethods.traverse = function traverse(path, newVisitor) {
      if (!(this instanceof this.Context)) {
        throw new Error("");
      }
      if (!(path instanceof NodePath)) {
        throw new Error("");
      }
      if (!(this.currentPath instanceof NodePath)) {
        throw new Error("");
      }
      this.needToCallTraverse = false;
      return visitChildren(path, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
    };
    sharedContextProtoMethods.visit = function visit(path, newVisitor) {
      if (!(this instanceof this.Context)) {
        throw new Error("");
      }
      if (!(path instanceof NodePath)) {
        throw new Error("");
      }
      if (!(this.currentPath instanceof NodePath)) {
        throw new Error("");
      }
      this.needToCallTraverse = false;
      return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);
    };
    sharedContextProtoMethods.reportChanged = function reportChanged() {
      this.visitor.reportChanged();
    };
    sharedContextProtoMethods.abort = function abort() {
      this.needToCallTraverse = false;
      this.visitor.abort();
    };
    return PathVisitor;
  };
});
System.registerDynamic('npm:ast-types@0.9.2/fork.js', ['npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/equiv.js', 'npm:ast-types@0.9.2/lib/path.js', 'npm:ast-types@0.9.2/lib/node-path.js', 'npm:ast-types@0.9.2/lib/path-visitor.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (defs) {
    var used = [];
    var usedResult = [];
    var fork = {};
    function use(plugin) {
      var idx = used.indexOf(plugin);
      if (idx === -1) {
        idx = used.length;
        used.push(plugin);
        usedResult[idx] = plugin(fork);
      }
      return usedResult[idx];
    }
    fork.use = use;
    var types = use($__require('npm:ast-types@0.9.2/lib/types.js'));
    defs.forEach(use);
    types.finalize();
    var exports = {
      Type: types.Type,
      builtInTypes: types.builtInTypes,
      namedTypes: types.namedTypes,
      builders: types.builders,
      defineMethod: types.defineMethod,
      getFieldNames: types.getFieldNames,
      getFieldValue: types.getFieldValue,
      eachField: types.eachField,
      someField: types.someField,
      getSupertypeNames: types.getSupertypeNames,
      astNodesAreEquivalent: use($__require('npm:ast-types@0.9.2/lib/equiv.js')),
      finalize: types.finalize,
      Path: use($__require('npm:ast-types@0.9.2/lib/path.js')),
      NodePath: use($__require('npm:ast-types@0.9.2/lib/node-path.js')),
      PathVisitor: use($__require('npm:ast-types@0.9.2/lib/path-visitor.js')),
      use: use
    };
    exports.visit = exports.PathVisitor.visit;
    return exports;
  };
});
System.registerDynamic('npm:ast-types@0.9.2/def/mozilla.js', ['npm:ast-types@0.9.2/def/core.js', 'npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/shared.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    fork.use($__require('npm:ast-types@0.9.2/def/core.js'));
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var def = types.Type.def;
    var or = types.Type.or;
    var shared = fork.use($__require('npm:ast-types@0.9.2/lib/shared.js'));
    var geq = shared.geq;
    var defaults = shared.defaults;
    def("Function").field("body", or(def("BlockStatement"), def("Expression")));
    def("ForInStatement").build("left", "right", "body", "each").field("each", Boolean, defaults["false"]);
    def("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
    def("LetStatement").bases("Statement").build("head", "body").field("head", [def("VariableDeclarator")]).field("body", def("Statement"));
    def("LetExpression").bases("Expression").build("head", "body").field("head", [def("VariableDeclarator")]).field("body", def("Expression"));
    def("GraphExpression").bases("Expression").build("index", "expression").field("index", geq(0)).field("expression", def("Literal"));
    def("GraphIndexExpression").bases("Expression").build("index").field("index", geq(0));
  };
});
System.registerDynamic('npm:ast-types@0.9.2/def/e4x.js', ['npm:ast-types@0.9.2/def/core.js', 'npm:ast-types@0.9.2/lib/types.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    fork.use($__require('npm:ast-types@0.9.2/def/core.js'));
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var def = types.Type.def;
    var or = types.Type.or;
    def("XMLDefaultDeclaration").bases("Declaration").field("namespace", def("Expression"));
    def("XMLAnyName").bases("Expression");
    def("XMLQualifiedIdentifier").bases("Expression").field("left", or(def("Identifier"), def("XMLAnyName"))).field("right", or(def("Identifier"), def("Expression"))).field("computed", Boolean);
    def("XMLFunctionQualifiedIdentifier").bases("Expression").field("right", or(def("Identifier"), def("Expression"))).field("computed", Boolean);
    def("XMLAttributeSelector").bases("Expression").field("attribute", def("Expression"));
    def("XMLFilterExpression").bases("Expression").field("left", def("Expression")).field("right", def("Expression"));
    def("XMLElement").bases("XML", "Expression").field("contents", [def("XML")]);
    def("XMLList").bases("XML", "Expression").field("contents", [def("XML")]);
    def("XML").bases("Node");
    def("XMLEscape").bases("XML").field("expression", def("Expression"));
    def("XMLText").bases("XML").field("text", String);
    def("XMLStartTag").bases("XML").field("contents", [def("XML")]);
    def("XMLEndTag").bases("XML").field("contents", [def("XML")]);
    def("XMLPointTag").bases("XML").field("contents", [def("XML")]);
    def("XMLName").bases("XML").field("contents", or(String, [def("XML")]));
    def("XMLAttribute").bases("XML").field("value", String);
    def("XMLCdata").bases("XML").field("contents", String);
    def("XMLComment").bases("XML").field("contents", String);
    def("XMLProcessingInstruction").bases("XML").field("target", String).field("contents", or(String, null));
  };
});
System.registerDynamic('npm:ast-types@0.9.2/def/jsx.js', ['npm:ast-types@0.9.2/def/es7.js', 'npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/shared.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    fork.use($__require('npm:ast-types@0.9.2/def/es7.js'));
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var def = types.Type.def;
    var or = types.Type.or;
    var defaults = fork.use($__require('npm:ast-types@0.9.2/lib/shared.js')).defaults;
    def("JSXAttribute").bases("Node").build("name", "value").field("name", or(def("JSXIdentifier"), def("JSXNamespacedName"))).field("value", or(def("Literal"), def("JSXExpressionContainer"), null), defaults["null"]);
    def("JSXIdentifier").bases("Identifier").build("name").field("name", String);
    def("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def("JSXIdentifier")).field("name", def("JSXIdentifier"));
    def("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or(def("JSXIdentifier"), def("JSXMemberExpression"))).field("property", def("JSXIdentifier")).field("computed", Boolean, defaults.false);
    var JSXElementName = or(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
    def("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def("Expression"));
    var JSXAttributes = [or(def("JSXAttribute"), def("JSXSpreadAttribute"))];
    def("JSXExpressionContainer").bases("Expression").build("expression").field("expression", def("Expression"));
    def("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningElement")).field("closingElement", or(def("JSXClosingElement"), null), defaults["null"]).field("children", [or(def("JSXElement"), def("JSXExpressionContainer"), def("JSXText"), def("Literal"))], defaults.emptyArray).field("name", JSXElementName, function () {
      return this.openingElement.name;
    }, true).field("selfClosing", Boolean, function () {
      return this.openingElement.selfClosing;
    }, true).field("attributes", JSXAttributes, function () {
      return this.openingElement.attributes;
    }, true);
    def("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults.emptyArray).field("selfClosing", Boolean, defaults["false"]);
    def("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName);
    def("JSXText").bases("Literal").build("value").field("value", String);
    def("JSXEmptyExpression").bases("Expression").build();
  };
});
System.registerDynamic('npm:ast-types@0.9.2/def/esprima.js', ['npm:ast-types@0.9.2/def/es7.js', 'npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/shared.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    fork.use($__require('npm:ast-types@0.9.2/def/es7.js'));
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var defaults = fork.use($__require('npm:ast-types@0.9.2/lib/shared.js')).defaults;
    var def = types.Type.def;
    var or = types.Type.or;
    def("VariableDeclaration").field("declarations", [or(def("VariableDeclarator"), def("Identifier"))]);
    def("Property").field("value", or(def("Expression"), def("Pattern")));
    def("ArrayPattern").field("elements", [or(def("Pattern"), def("SpreadElement"), null)]);
    def("ObjectPattern").field("properties", [or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"))]);
    def("ExportSpecifier").bases("ModuleSpecifier").build("id", "name");
    def("ExportBatchSpecifier").bases("Specifier").build();
    def("ImportSpecifier").bases("ModuleSpecifier").build("id", "name");
    def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("id");
    def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("id");
    def("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(def("Declaration"), def("Expression"), null)).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray).field("source", or(def("Literal"), null), defaults["null"]);
    def("ImportDeclaration").bases("Declaration").build("specifiers", "source").field("specifiers", [or(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults.emptyArray).field("source", def("Literal"));
    def("Block").bases("Comment").build("value", "leading", "trailing");
    def("Line").bases("Comment").build("value", "leading", "trailing");
  };
});
System.registerDynamic('npm:ast-types@0.9.2/def/babel.js', ['npm:ast-types@0.9.2/def/es7.js', 'npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/shared.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    fork.use($__require('npm:ast-types@0.9.2/def/es7.js'));
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var defaults = fork.use($__require('npm:ast-types@0.9.2/lib/shared.js')).defaults;
    var def = types.Type.def;
    var or = types.Type.or;
    def("Noop").bases("Node").build();
    def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]);
    def("Super").bases("Expression").build();
    def("BindExpression").bases("Expression").build("object", "callee").field("object", or(def("Expression"), null)).field("callee", def("Expression"));
    def("Decorator").bases("Node").build("expression").field("expression", def("Expression"));
    def("Property").field("decorators", or([def("Decorator")], null), defaults["null"]);
    def("MethodDefinition").field("decorators", or([def("Decorator")], null), defaults["null"]);
    def("MetaProperty").bases("Expression").build("meta", "property").field("meta", def("Identifier")).field("property", def("Identifier"));
    def("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def("Expression"));
    def("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def("Identifier"));
    def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local");
    def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local");
    def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or(def("Declaration"), def("Expression")));
    def("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or(def("Declaration"), null)).field("specifiers", [def("ExportSpecifier")], defaults.emptyArray).field("source", or(def("Literal"), null), defaults["null"]);
    def("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def("Identifier"));
    def("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
    def("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
    def("ExportAllDeclaration").bases("Declaration").build("exported", "source").field("exported", or(def("Identifier"), null)).field("source", def("Literal"));
    def("CommentBlock").bases("Comment").build("value", "leading", "trailing");
    def("CommentLine").bases("Comment").build("value", "leading", "trailing");
  };
});
System.registerDynamic('npm:ast-types@0.9.2/def/core.js', ['npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/shared.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var Type = types.Type;
    var def = Type.def;
    var or = Type.or;
    var shared = fork.use($__require('npm:ast-types@0.9.2/lib/shared.js'));
    var defaults = shared.defaults;
    var geq = shared.geq;
    def("Printable").field("loc", or(def("SourceLocation"), null), defaults["null"], true);
    def("Node").bases("Printable").field("type", String).field("comments", or([def("Comment")], null), defaults["null"], true);
    def("SourceLocation").build("start", "end", "source").field("start", def("Position")).field("end", def("Position")).field("source", or(String, null), defaults["null"]);
    def("Position").build("line", "column").field("line", geq(1)).field("column", geq(0));
    def("File").bases("Node").build("program").field("program", def("Program"));
    def("Program").bases("Node").build("body").field("body", [def("Statement")]);
    def("Function").bases("Node").field("id", or(def("Identifier"), null), defaults["null"]).field("params", [def("Pattern")]).field("body", def("BlockStatement"));
    def("Statement").bases("Node");
    def("EmptyStatement").bases("Statement").build();
    def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]);
    def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression"));
    def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or(def("Statement"), null), defaults["null"]);
    def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement"));
    def("BreakStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults["null"]);
    def("ContinueStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults["null"]);
    def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement"));
    def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults["false"]);
    def("ReturnStatement").bases("Statement").build("argument").field("argument", or(def("Expression"), null));
    def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression"));
    def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or(def("CatchClause"), null), function () {
      return this.handlers && this.handlers[0] || null;
    }).field("handlers", [def("CatchClause")], function () {
      return this.handler ? [this.handler] : [];
    }, true).field("guardedHandlers", [def("CatchClause")], defaults.emptyArray).field("finalizer", or(def("BlockStatement"), null), defaults["null"]);
    def("CatchClause").bases("Node").build("param", "guard", "body").field("param", def("Pattern")).field("guard", or(def("Expression"), null), defaults["null"]).field("body", def("BlockStatement"));
    def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement"));
    def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression"));
    def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or(def("VariableDeclaration"), def("Expression"), null)).field("test", or(def("Expression"), null)).field("update", or(def("Expression"), null)).field("body", def("Statement"));
    def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
    def("DebuggerStatement").bases("Statement").build();
    def("Declaration").bases("Statement");
    def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier"));
    def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body");
    def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or("var", "let", "const")).field("declarations", [def("VariableDeclarator")]);
    def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or(def("Expression"), null));
    def("Expression").bases("Node", "Pattern");
    def("ThisExpression").bases("Expression").build();
    def("ArrayExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), null)]);
    def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]);
    def("Property").bases("Node").build("kind", "key", "value").field("kind", or("init", "get", "set")).field("key", or(def("Literal"), def("Identifier"))).field("value", def("Expression"));
    def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
    var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
    def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults["true"]);
    var BinaryOperator = or("==", "!=", "===", "!==", "<", "<=", ">", ">=", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "&", "|", "^", "in", "instanceof", "..");
    def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
    var AssignmentOperator = or("=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&=");
    def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", def("Pattern")).field("right", def("Expression"));
    var UpdateOperator = or("++", "--");
    def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
    var LogicalOperator = or("||", "&&");
    def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression"));
    def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression"));
    def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
    def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
    def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression"))).field("computed", Boolean, function () {
      var type = this.property.type;
      if (type === 'Literal' || type === 'MemberExpression' || type === 'BinaryExpression') {
        return true;
      }
      return false;
    });
    def("Pattern").bases("Node");
    def("SwitchCase").bases("Node").build("test", "consequent").field("test", or(def("Expression"), null)).field("consequent", [def("Statement")]);
    def("Identifier").bases("Node", "Expression", "Pattern").build("name").field("name", String);
    def("Literal").bases("Node", "Expression").build("value").field("value", or(String, Boolean, null, Number, RegExp)).field("regex", or({
      pattern: String,
      flags: String
    }, null), function () {
      if (this.value instanceof RegExp) {
        var flags = "";
        if (this.value.ignoreCase) flags += "i";
        if (this.value.multiline) flags += "m";
        if (this.value.global) flags += "g";
        return {
          pattern: this.value.source,
          flags: flags
        };
      }
      return null;
    });
    def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults["true"]).field("trailing", Boolean, defaults["false"]);
  };
});
System.registerDynamic('npm:ast-types@0.9.2/def/es6.js', ['npm:ast-types@0.9.2/def/core.js', 'npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/shared.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    fork.use($__require('npm:ast-types@0.9.2/def/core.js'));
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var def = types.Type.def;
    var or = types.Type.or;
    var defaults = fork.use($__require('npm:ast-types@0.9.2/lib/shared.js')).defaults;
    def("Function").field("generator", Boolean, defaults["false"]).field("expression", Boolean, defaults["false"]).field("defaults", [or(def("Expression"), null)], defaults.emptyArray).field("rest", or(def("Identifier"), null), defaults["null"]);
    def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern"));
    def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
    def("FunctionDeclaration").build("id", "params", "body", "generator", "expression");
    def("FunctionExpression").build("id", "params", "body", "generator", "expression");
    def("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults["null"]).field("body", or(def("BlockStatement"), def("Expression"))).field("generator", false, defaults["false"]);
    def("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or(def("Expression"), null)).field("delegate", Boolean, defaults["false"]);
    def("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
    def("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
    def("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def("Pattern")).field("right", def("Expression")).field("each", Boolean);
    def("Property").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("method", Boolean, defaults["false"]).field("shorthand", Boolean, defaults["false"]).field("computed", Boolean, defaults["false"]);
    def("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("pattern", def("Pattern")).field("computed", Boolean, defaults["false"]);
    def("ObjectPattern").bases("Pattern").build("properties").field("properties", [or(def("PropertyPattern"), def("Property"))]);
    def("ArrayPattern").bases("Pattern").build("elements").field("elements", [or(def("Pattern"), null)]);
    def("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or("constructor", "method", "get", "set")).field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", def("Function")).field("computed", Boolean, defaults["false"]).field("static", Boolean, defaults["false"]);
    def("SpreadElement").bases("Node").build("argument").field("argument", def("Expression"));
    def("ArrayExpression").field("elements", [or(def("Expression"), def("SpreadElement"), def("RestElement"), null)]);
    def("NewExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
    def("CallExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
    def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression"));
    var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"));
    def("ClassProperty").bases("Declaration").build("key").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("computed", Boolean, defaults["false"]);
    def("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement);
    def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
    def("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or(def("Identifier"), null)).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults["null"]);
    def("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or(def("Identifier"), null), defaults["null"]).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults["null"]).field("implements", [def("ClassImplements")], defaults.emptyArray);
    def("ClassImplements").bases("Node").build("id").field("id", def("Identifier")).field("superClass", or(def("Expression"), null), defaults["null"]);
    def("Specifier").bases("Node");
    def("ModuleSpecifier").bases("Specifier").field("local", or(def("Identifier"), null), defaults["null"]).field("id", or(def("Identifier"), null), defaults["null"]).field("name", or(def("Identifier"), null), defaults["null"]);
    def("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def("Expression")).field("quasi", def("TemplateLiteral"));
    def("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def("TemplateElement")]).field("expressions", [def("Expression")]);
    def("TemplateElement").bases("Node").build("value", "tail").field("value", {
      "cooked": String,
      "raw": String
    }).field("tail", Boolean);
  };
});
System.registerDynamic('npm:ast-types@0.9.2/def/es7.js', ['npm:ast-types@0.9.2/def/es6.js', 'npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/shared.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    fork.use($__require('npm:ast-types@0.9.2/def/es6.js'));
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var def = types.Type.def;
    var or = types.Type.or;
    var builtin = types.builtInTypes;
    var defaults = fork.use($__require('npm:ast-types@0.9.2/lib/shared.js')).defaults;
    def("Function").field("async", Boolean, defaults["false"]);
    def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
    def("ObjectExpression").field("properties", [or(def("Property"), def("SpreadProperty"))]);
    def("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
    def("ObjectPattern").field("properties", [or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"))]);
    def("AwaitExpression").bases("Expression").build("argument", "all").field("argument", or(def("Expression"), null)).field("all", Boolean, defaults["false"]);
  };
});
System.registerDynamic('npm:ast-types@0.9.2/def/flow.js', ['npm:ast-types@0.9.2/def/es7.js', 'npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/shared.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    fork.use($__require('npm:ast-types@0.9.2/def/es7.js'));
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var def = types.Type.def;
    var or = types.Type.or;
    var defaults = fork.use($__require('npm:ast-types@0.9.2/lib/shared.js')).defaults;
    def("Type").bases("Node");
    def("AnyTypeAnnotation").bases("Type").build();
    def("EmptyTypeAnnotation").bases("Type").build();
    def("MixedTypeAnnotation").bases("Type").build();
    def("VoidTypeAnnotation").bases("Type").build();
    def("NumberTypeAnnotation").bases("Type").build();
    def("NumberLiteralTypeAnnotation").bases("Type").build("value", "raw").field("value", Number).field("raw", String);
    def("StringTypeAnnotation").bases("Type").build();
    def("StringLiteralTypeAnnotation").bases("Type").build("value", "raw").field("value", String).field("raw", String);
    def("BooleanTypeAnnotation").bases("Type").build();
    def("BooleanLiteralTypeAnnotation").bases("Type").build("value", "raw").field("value", Boolean).field("raw", String);
    def("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def("Type"));
    def("NullableTypeAnnotation").bases("Type").build("typeAnnotation").field("typeAnnotation", def("Type"));
    def("NullLiteralTypeAnnotation").bases("Type").build();
    def("NullTypeAnnotation").bases("Type").build();
    def("ThisTypeAnnotation").bases("Type").build();
    def("ExistsTypeAnnotation").bases("Type").build();
    def("ExistentialTypeParam").bases("Type").build();
    def("FunctionTypeAnnotation").bases("Type").build("params", "returnType", "rest", "typeParameters").field("params", [def("FunctionTypeParam")]).field("returnType", def("Type")).field("rest", or(def("FunctionTypeParam"), null)).field("typeParameters", or(def("TypeParameterDeclaration"), null));
    def("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", def("Identifier")).field("typeAnnotation", def("Type")).field("optional", Boolean);
    def("ArrayTypeAnnotation").bases("Type").build("elementType").field("elementType", def("Type"));
    def("ObjectTypeAnnotation").bases("Type").build("properties", "indexers", "callProperties").field("properties", [def("ObjectTypeProperty")]).field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray).field("callProperties", [def("ObjectTypeCallProperty")], defaults.emptyArray).field("exact", Boolean, defaults["false"]);
    def("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or(def("Literal"), def("Identifier"))).field("value", def("Type")).field("optional", Boolean).field("variance", or("plus", "minus", null), defaults["null"]);
    def("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def("Identifier")).field("key", def("Type")).field("value", def("Type")).field("variance", or("plus", "minus", null), defaults["null"]);
    def("ObjectTypeCallProperty").bases("Node").build("value").field("value", def("FunctionTypeAnnotation")).field("static", Boolean, defaults["false"]);
    def("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("id", def("Identifier"));
    def("GenericTypeAnnotation").bases("Type").build("id", "typeParameters").field("id", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("typeParameters", or(def("TypeParameterInstantiation"), null));
    def("MemberTypeAnnotation").bases("Type").build("object", "property").field("object", def("Identifier")).field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));
    def("UnionTypeAnnotation").bases("Type").build("types").field("types", [def("Type")]);
    def("IntersectionTypeAnnotation").bases("Type").build("types").field("types", [def("Type")]);
    def("TypeofTypeAnnotation").bases("Type").build("argument").field("argument", def("Type"));
    def("Identifier").field("typeAnnotation", or(def("TypeAnnotation"), null), defaults["null"]);
    def("TypeParameterDeclaration").bases("Node").build("params").field("params", [def("TypeParameter")]);
    def("TypeParameterInstantiation").bases("Node").build("params").field("params", [def("Type")]);
    def("TypeParameter").bases("Type").build("name", "variance", "bound").field("name", String).field("variance", or("plus", "minus", null), defaults["null"]).field("bound", or(def("TypeAnnotation"), null), defaults["null"]);
    def("Function").field("returnType", or(def("TypeAnnotation"), null), defaults["null"]).field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults["null"]);
    def("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or(def("Expression"), null)).field("typeAnnotation", or(def("TypeAnnotation"), null)).field("static", Boolean, defaults["false"]).field("variance", or("plus", "minus", null), defaults["null"]);
    def("ClassImplements").field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults["null"]);
    def("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults["null"]).field("body", def("ObjectTypeAnnotation")).field("extends", [def("InterfaceExtends")]);
    def("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends");
    def("InterfaceExtends").bases("Node").build("id").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterInstantiation"), null));
    def("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("right", def("Type"));
    def("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right");
    def("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TypeAnnotation"));
    def("TupleTypeAnnotation").bases("Type").build("types").field("types", [def("Type")]);
    def("DeclareVariable").bases("Statement").build("id").field("id", def("Identifier"));
    def("DeclareFunction").bases("Statement").build("id").field("id", def("Identifier"));
    def("DeclareClass").bases("InterfaceDeclaration").build("id");
    def("DeclareModule").bases("Statement").build("id", "body").field("id", or(def("Identifier"), def("Literal"))).field("body", def("BlockStatement"));
    def("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", def("Type"));
    def("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(def("DeclareVariable"), def("DeclareFunction"), def("DeclareClass"), def("Type"), null)).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray).field("source", or(def("Literal"), null), defaults["null"]);
  };
});
System.registerDynamic("npm:ast-types@0.9.2/lib/types.js", [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var Ap = Array.prototype;
    var slice = Ap.slice;
    var map = Ap.map;
    var each = Ap.forEach;
    var Op = Object.prototype;
    var objToStr = Op.toString;
    var funObjStr = objToStr.call(function () {});
    var strObjStr = objToStr.call("");
    var hasOwn = Op.hasOwnProperty;

    module.exports = function () {

        var exports = {};

        // A type is an object with a .check method that takes a value and returns
        // true or false according to whether the value matches the type.

        function Type(check, name) {
            var self = this;
            if (!(self instanceof Type)) {
                throw new Error("Type constructor cannot be invoked without 'new'");
            }

            // Unfortunately we can't elegantly reuse isFunction and isString,
            // here, because this code is executed while defining those types.
            if (objToStr.call(check) !== funObjStr) {
                throw new Error(check + " is not a function");
            }

            // The `name` parameter can be either a function or a string.
            var nameObjStr = objToStr.call(name);
            if (!(nameObjStr === funObjStr || nameObjStr === strObjStr)) {
                throw new Error(name + " is neither a function nor a string");
            }

            Object.defineProperties(self, {
                name: { value: name },
                check: {
                    value: function (value, deep) {
                        var result = check.call(self, value, deep);
                        if (!result && deep && objToStr.call(deep) === funObjStr) deep(self, value);
                        return result;
                    }
                }
            });
        }

        var Tp = Type.prototype;

        // Throughout this file we use Object.defineProperty to prevent
        // redefinition of exported properties.
        exports.Type = Type;

        // Like .check, except that failure triggers an AssertionError.
        Tp.assert = function (value, deep) {
            if (!this.check(value, deep)) {
                var str = shallowStringify(value);
                throw new Error(str + " does not match type " + this);
            }
            return true;
        };

        function shallowStringify(value) {
            if (isObject.check(value)) return "{" + Object.keys(value).map(function (key) {
                return key + ": " + value[key];
            }).join(", ") + "}";

            if (isArray.check(value)) return "[" + value.map(shallowStringify).join(", ") + "]";

            return JSON.stringify(value);
        }

        Tp.toString = function () {
            var name = this.name;

            if (isString.check(name)) return name;

            if (isFunction.check(name)) return name.call(this) + "";

            return name + " type";
        };

        var builtInCtorFns = [];
        var builtInCtorTypes = [];
        var builtInTypes = {};
        exports.builtInTypes = builtInTypes;

        function defBuiltInType(example, name) {
            var objStr = objToStr.call(example);

            var type = new Type(function (value) {
                return objToStr.call(value) === objStr;
            }, name);

            builtInTypes[name] = type;

            if (example && typeof example.constructor === "function") {
                builtInCtorFns.push(example.constructor);
                builtInCtorTypes.push(type);
            }

            return type;
        }

        // These types check the underlying [[Class]] attribute of the given
        // value, rather than using the problematic typeof operator. Note however
        // that no subtyping is considered; so, for instance, isObject.check
        // returns false for [], /./, new Date, and null.
        var isString = defBuiltInType("truthy", "string");
        var isFunction = defBuiltInType(function () {}, "function");
        var isArray = defBuiltInType([], "array");
        var isObject = defBuiltInType({}, "object");
        var isRegExp = defBuiltInType(/./, "RegExp");
        var isDate = defBuiltInType(new Date(), "Date");
        var isNumber = defBuiltInType(3, "number");
        var isBoolean = defBuiltInType(true, "boolean");
        var isNull = defBuiltInType(null, "null");
        var isUndefined = defBuiltInType(void 0, "undefined");

        // There are a number of idiomatic ways of expressing types, so this
        // function serves to coerce them all to actual Type objects. Note that
        // providing the name argument is not necessary in most cases.
        function toType(from, name) {
            // The toType function should of course be idempotent.
            if (from instanceof Type) return from;

            // The Def type is used as a helper for constructing compound
            // interface types for AST nodes.
            if (from instanceof Def) return from.type;

            // Support [ElemType] syntax.
            if (isArray.check(from)) return Type.fromArray(from);

            // Support { someField: FieldType, ... } syntax.
            if (isObject.check(from)) return Type.fromObject(from);

            if (isFunction.check(from)) {
                var bicfIndex = builtInCtorFns.indexOf(from);
                if (bicfIndex >= 0) {
                    return builtInCtorTypes[bicfIndex];
                }

                // If isFunction.check(from), and from is not a built-in
                // constructor, assume from is a binary predicate function we can
                // use to define the type.
                return new Type(from, name);
            }

            // As a last resort, toType returns a type that matches any value that
            // is === from. This is primarily useful for literal values like
            // toType(null), but it has the additional advantage of allowing
            // toType to be a total function.
            return new Type(function (value) {
                return value === from;
            }, isUndefined.check(name) ? function () {
                return from + "";
            } : name);
        }

        // Returns a type that matches the given value iff any of type1, type2,
        // etc. match the value.
        Type.or = function () /* type1, type2, ... */{
            var types = [];
            var len = arguments.length;
            for (var i = 0; i < len; ++i) types.push(toType(arguments[i]));

            return new Type(function (value, deep) {
                for (var i = 0; i < len; ++i) if (types[i].check(value, deep)) return true;
                return false;
            }, function () {
                return types.join(" | ");
            });
        };

        Type.fromArray = function (arr) {
            if (!isArray.check(arr)) {
                throw new Error("");
            }
            if (arr.length !== 1) {
                throw new Error("only one element type is permitted for typed arrays");
            }
            return toType(arr[0]).arrayOf();
        };

        Tp.arrayOf = function () {
            var elemType = this;
            return new Type(function (value, deep) {
                return isArray.check(value) && value.every(function (elem) {
                    return elemType.check(elem, deep);
                });
            }, function () {
                return "[" + elemType + "]";
            });
        };

        Type.fromObject = function (obj) {
            var fields = Object.keys(obj).map(function (name) {
                return new Field(name, obj[name]);
            });

            return new Type(function (value, deep) {
                return isObject.check(value) && fields.every(function (field) {
                    return field.type.check(value[field.name], deep);
                });
            }, function () {
                return "{ " + fields.join(", ") + " }";
            });
        };

        function Field(name, type, defaultFn, hidden) {
            var self = this;

            if (!(self instanceof Field)) {
                throw new Error("Field constructor cannot be invoked without 'new'");
            }
            isString.assert(name);

            type = toType(type);

            var properties = {
                name: { value: name },
                type: { value: type },
                hidden: { value: !!hidden }
            };

            if (isFunction.check(defaultFn)) {
                properties.defaultFn = { value: defaultFn };
            }

            Object.defineProperties(self, properties);
        }

        var Fp = Field.prototype;

        Fp.toString = function () {
            return JSON.stringify(this.name) + ": " + this.type;
        };

        Fp.getValue = function (obj) {
            var value = obj[this.name];

            if (!isUndefined.check(value)) return value;

            if (this.defaultFn) value = this.defaultFn.call(obj);

            return value;
        };

        // Define a type whose name is registered in a namespace (the defCache) so
        // that future definitions will return the same type given the same name.
        // In particular, this system allows for circular and forward definitions.
        // The Def object d returned from Type.def may be used to configure the
        // type d.type by calling methods such as d.bases, d.build, and d.field.
        Type.def = function (typeName) {
            isString.assert(typeName);
            return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new Def(typeName);
        };

        // In order to return the same Def instance every time Type.def is called
        // with a particular name, those instances need to be stored in a cache.
        var defCache = Object.create(null);

        function Def(typeName) {
            var self = this;
            if (!(self instanceof Def)) {
                throw new Error("Def constructor cannot be invoked without 'new'");
            }

            Object.defineProperties(self, {
                typeName: { value: typeName },
                baseNames: { value: [] },
                ownFields: { value: Object.create(null) },

                // These two are populated during finalization.
                allSupertypes: { value: Object.create(null) }, // Includes own typeName.
                supertypeList: { value: [] }, // Linear inheritance hierarchy.
                allFields: { value: Object.create(null) }, // Includes inherited fields.
                fieldNames: { value: [] }, // Non-hidden keys of allFields.

                type: {
                    value: new Type(function (value, deep) {
                        return self.check(value, deep);
                    }, typeName)
                }
            });
        }

        Def.fromValue = function (value) {
            if (value && typeof value === "object") {
                var type = value.type;
                if (typeof type === "string" && hasOwn.call(defCache, type)) {
                    var d = defCache[type];
                    if (d.finalized) {
                        return d;
                    }
                }
            }

            return null;
        };

        var Dp = Def.prototype;

        Dp.isSupertypeOf = function (that) {
            if (that instanceof Def) {
                if (this.finalized !== true || that.finalized !== true) {
                    throw new Error("");
                }
                return hasOwn.call(that.allSupertypes, this.typeName);
            } else {
                throw new Error(that + " is not a Def");
            }
        };

        // Note that the list returned by this function is a copy of the internal
        // supertypeList, *without* the typeName itself as the first element.
        exports.getSupertypeNames = function (typeName) {
            if (!hasOwn.call(defCache, typeName)) {
                throw new Error("");
            }
            var d = defCache[typeName];
            if (d.finalized !== true) {
                throw new Error("");
            }
            return d.supertypeList.slice(1);
        };

        // Returns an object mapping from every known type in the defCache to the
        // most specific supertype whose name is an own property of the candidates
        // object.
        exports.computeSupertypeLookupTable = function (candidates) {
            var table = {};
            var typeNames = Object.keys(defCache);
            var typeNameCount = typeNames.length;

            for (var i = 0; i < typeNameCount; ++i) {
                var typeName = typeNames[i];
                var d = defCache[typeName];
                if (d.finalized !== true) {
                    throw new Error("" + typeName);
                }
                for (var j = 0; j < d.supertypeList.length; ++j) {
                    var superTypeName = d.supertypeList[j];
                    if (hasOwn.call(candidates, superTypeName)) {
                        table[typeName] = superTypeName;
                        break;
                    }
                }
            }

            return table;
        };

        Dp.checkAllFields = function (value, deep) {
            var allFields = this.allFields;
            if (this.finalized !== true) {
                throw new Error("" + this.typeName);
            }

            function checkFieldByName(name) {
                var field = allFields[name];
                var type = field.type;
                var child = field.getValue(value);
                return type.check(child, deep);
            }

            return isObject.check(value) && Object.keys(allFields).every(checkFieldByName);
        };

        Dp.check = function (value, deep) {
            if (this.finalized !== true) {
                throw new Error("prematurely checking unfinalized type " + this.typeName);
            }

            // A Def type can only match an object value.
            if (!isObject.check(value)) return false;

            var vDef = Def.fromValue(value);
            if (!vDef) {
                // If we couldn't infer the Def associated with the given value,
                // and we expected it to be a SourceLocation or a Position, it was
                // probably just missing a "type" field (because Esprima does not
                // assign a type property to such nodes). Be optimistic and let
                // this.checkAllFields make the final decision.
                if (this.typeName === "SourceLocation" || this.typeName === "Position") {
                    return this.checkAllFields(value, deep);
                }

                // Calling this.checkAllFields for any other type of node is both
                // bad for performance and way too forgiving.
                return false;
            }

            // If checking deeply and vDef === this, then we only need to call
            // checkAllFields once. Calling checkAllFields is too strict when deep
            // is false, because then we only care about this.isSupertypeOf(vDef).
            if (deep && vDef === this) return this.checkAllFields(value, deep);

            // In most cases we rely exclusively on isSupertypeOf to make O(1)
            // subtyping determinations. This suffices in most situations outside
            // of unit tests, since interface conformance is checked whenever new
            // instances are created using builder functions.
            if (!this.isSupertypeOf(vDef)) return false;

            // The exception is when deep is true; then, we recursively check all
            // fields.
            if (!deep) return true;

            // Use the more specific Def (vDef) to perform the deep check, but
            // shallow-check fields defined by the less specific Def (this).
            return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);
        };

        Dp.bases = function () {
            var args = slice.call(arguments);
            var bases = this.baseNames;

            if (this.finalized) {
                if (args.length !== bases.length) {
                    throw new Error("");
                }
                for (var i = 0; i < args.length; i++) {
                    if (args[i] !== bases[i]) {
                        throw new Error("");
                    }
                }
                return this;
            }

            args.forEach(function (baseName) {
                isString.assert(baseName);

                // This indexOf lookup may be O(n), but the typical number of base
                // names is very small, and indexOf is a native Array method.
                if (bases.indexOf(baseName) < 0) bases.push(baseName);
            });

            return this; // For chaining.
        };

        // False by default until .build(...) is called on an instance.
        Object.defineProperty(Dp, "buildable", { value: false });

        var builders = {};
        exports.builders = builders;

        // This object is used as prototype for any node created by a builder.
        var nodePrototype = {};

        // Call this function to define a new method to be shared by all AST
        // nodes. The replaced method (if any) is returned for easy wrapping.
        exports.defineMethod = function (name, func) {
            var old = nodePrototype[name];

            // Pass undefined as func to delete nodePrototype[name].
            if (isUndefined.check(func)) {
                delete nodePrototype[name];
            } else {
                isFunction.assert(func);

                Object.defineProperty(nodePrototype, name, {
                    enumerable: true, // For discoverability.
                    configurable: true, // For delete proto[name].
                    value: func
                });
            }

            return old;
        };

        var isArrayOfString = isString.arrayOf();

        // Calling the .build method of a Def simultaneously marks the type as
        // buildable (by defining builders[getBuilderName(typeName)]) and
        // specifies the order of arguments that should be passed to the builder
        // function to create an instance of the type.
        Dp.build = function () /* param1, param2, ... */{
            var self = this;

            var newBuildParams = slice.call(arguments);
            isArrayOfString.assert(newBuildParams);

            // Calling Def.prototype.build multiple times has the effect of merely
            // redefining this property.
            Object.defineProperty(self, "buildParams", {
                value: newBuildParams,
                writable: false,
                enumerable: false,
                configurable: true
            });

            if (self.buildable) {
                // If this Def is already buildable, update self.buildParams and
                // continue using the old builder function.
                return self;
            }

            // Every buildable type will have its "type" field filled in
            // automatically. This includes types that are not subtypes of Node,
            // like SourceLocation, but that seems harmless (TODO?).
            self.field("type", String, function () {
                return self.typeName;
            });

            // Override Dp.buildable for this Def instance.
            Object.defineProperty(self, "buildable", { value: true });

            Object.defineProperty(builders, getBuilderName(self.typeName), {
                enumerable: true,

                value: function () {
                    var args = arguments;
                    var argc = args.length;
                    var built = Object.create(nodePrototype);

                    if (!self.finalized) {
                        throw new Error("attempting to instantiate unfinalized type " + self.typeName);
                    }

                    function add(param, i) {
                        if (hasOwn.call(built, param)) return;

                        var all = self.allFields;
                        if (!hasOwn.call(all, param)) {
                            throw new Error("" + param);
                        }

                        var field = all[param];
                        var type = field.type;
                        var value;

                        if (isNumber.check(i) && i < argc) {
                            value = args[i];
                        } else if (field.defaultFn) {
                            // Expose the partially-built object to the default
                            // function as its `this` object.
                            value = field.defaultFn.call(built);
                        } else {
                            var message = "no value or default function given for field " + JSON.stringify(param) + " of " + self.typeName + "(" + self.buildParams.map(function (name) {
                                return all[name];
                            }).join(", ") + ")";
                            throw new Error(message);
                        }

                        if (!type.check(value)) {
                            throw new Error(shallowStringify(value) + " does not match field " + field + " of type " + self.typeName);
                        }

                        // TODO Could attach getters and setters here to enforce
                        // dynamic type safety.
                        built[param] = value;
                    }

                    self.buildParams.forEach(function (param, i) {
                        add(param, i);
                    });

                    Object.keys(self.allFields).forEach(function (param) {
                        add(param); // Use the default value.
                    });

                    // Make sure that the "type" field was filled automatically.
                    if (built.type !== self.typeName) {
                        throw new Error("");
                    }

                    return built;
                }
            });

            return self; // For chaining.
        };

        function getBuilderName(typeName) {
            return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {
                var len = upperCasePrefix.length;
                switch (len) {
                    case 0:
                        return "";
                    // If there's only one initial capital letter, just lower-case it.
                    case 1:
                        return upperCasePrefix.toLowerCase();
                    default:
                        // If there's more than one initial capital letter, lower-case
                        // all but the last one, so that XMLDefaultDeclaration (for
                        // example) becomes xmlDefaultDeclaration.
                        return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);
                }
            });
        }
        exports.getBuilderName = getBuilderName;

        function getStatementBuilderName(typeName) {
            typeName = getBuilderName(typeName);
            return typeName.replace(/(Expression)?$/, "Statement");
        }
        exports.getStatementBuilderName = getStatementBuilderName;

        // The reason fields are specified using .field(...) instead of an object
        // literal syntax is somewhat subtle: the object literal syntax would
        // support only one key and one value, but with .field(...) we can pass
        // any number of arguments to specify the field.
        Dp.field = function (name, type, defaultFn, hidden) {
            if (this.finalized) {
                console.error("Ignoring attempt to redefine field " + JSON.stringify(name) + " of finalized type " + JSON.stringify(this.typeName));
                return this;
            }
            this.ownFields[name] = new Field(name, type, defaultFn, hidden);
            return this; // For chaining.
        };

        var namedTypes = {};
        exports.namedTypes = namedTypes;

        // Like Object.keys, but aware of what fields each AST type should have.
        function getFieldNames(object) {
            var d = Def.fromValue(object);
            if (d) {
                return d.fieldNames.slice(0);
            }

            if ("type" in object) {
                throw new Error("did not recognize object of type " + JSON.stringify(object.type));
            }

            return Object.keys(object);
        }
        exports.getFieldNames = getFieldNames;

        // Get the value of an object property, taking object.type and default
        // functions into account.
        function getFieldValue(object, fieldName) {
            var d = Def.fromValue(object);
            if (d) {
                var field = d.allFields[fieldName];
                if (field) {
                    return field.getValue(object);
                }
            }

            return object && object[fieldName];
        }
        exports.getFieldValue = getFieldValue;

        // Iterate over all defined fields of an object, including those missing
        // or undefined, passing each field name and effective value (as returned
        // by getFieldValue) to the callback. If the object has no corresponding
        // Def, the callback will never be called.
        exports.eachField = function (object, callback, context) {
            getFieldNames(object).forEach(function (name) {
                callback.call(this, name, getFieldValue(object, name));
            }, context);
        };

        // Similar to eachField, except that iteration stops as soon as the
        // callback returns a truthy value. Like Array.prototype.some, the final
        // result is either true or false to indicates whether the callback
        // returned true for any element or not.
        exports.someField = function (object, callback, context) {
            return getFieldNames(object).some(function (name) {
                return callback.call(this, name, getFieldValue(object, name));
            }, context);
        };

        // This property will be overridden as true by individual Def instances
        // when they are finalized.
        Object.defineProperty(Dp, "finalized", { value: false });

        Dp.finalize = function () {
            var self = this;

            // It's not an error to finalize a type more than once, but only the
            // first call to .finalize does anything.
            if (!self.finalized) {
                var allFields = self.allFields;
                var allSupertypes = self.allSupertypes;

                self.baseNames.forEach(function (name) {
                    var def = defCache[name];
                    if (def instanceof Def) {
                        def.finalize();
                        extend(allFields, def.allFields);
                        extend(allSupertypes, def.allSupertypes);
                    } else {
                        var message = "unknown supertype name " + JSON.stringify(name) + " for subtype " + JSON.stringify(self.typeName);
                        throw new Error(message);
                    }
                });

                // TODO Warn if fields are overridden with incompatible types.
                extend(allFields, self.ownFields);
                allSupertypes[self.typeName] = self;

                self.fieldNames.length = 0;
                for (var fieldName in allFields) {
                    if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {
                        self.fieldNames.push(fieldName);
                    }
                }

                // Types are exported only once they have been finalized.
                Object.defineProperty(namedTypes, self.typeName, {
                    enumerable: true,
                    value: self.type
                });

                Object.defineProperty(self, "finalized", { value: true });

                // A linearization of the inheritance hierarchy.
                populateSupertypeList(self.typeName, self.supertypeList);

                if (self.buildable && self.supertypeList.lastIndexOf("Expression") >= 0) {
                    wrapExpressionBuilderWithStatement(self.typeName);
                }
            }
        };

        // Adds an additional builder for Expression subtypes
        // that wraps the built Expression in an ExpressionStatements.
        function wrapExpressionBuilderWithStatement(typeName) {
            var wrapperName = getStatementBuilderName(typeName);

            // skip if the builder already exists
            if (builders[wrapperName]) return;

            // the builder function to wrap with builders.ExpressionStatement
            var wrapped = builders[getBuilderName(typeName)];

            // skip if there is nothing to wrap
            if (!wrapped) return;

            builders[wrapperName] = function () {
                return builders.expressionStatement(wrapped.apply(builders, arguments));
            };
        }

        function populateSupertypeList(typeName, list) {
            list.length = 0;
            list.push(typeName);

            var lastSeen = Object.create(null);

            for (var pos = 0; pos < list.length; ++pos) {
                typeName = list[pos];
                var d = defCache[typeName];
                if (d.finalized !== true) {
                    throw new Error("");
                }

                // If we saw typeName earlier in the breadth-first traversal,
                // delete the last-seen occurrence.
                if (hasOwn.call(lastSeen, typeName)) {
                    delete list[lastSeen[typeName]];
                }

                // Record the new index of the last-seen occurrence of typeName.
                lastSeen[typeName] = pos;

                // Enqueue the base names of this type.
                list.push.apply(list, d.baseNames);
            }

            // Compaction loop to remove array holes.
            for (var to = 0, from = to, len = list.length; from < len; ++from) {
                if (hasOwn.call(list, from)) {
                    list[to++] = list[from];
                }
            }

            list.length = to;
        }

        function extend(into, from) {
            Object.keys(from).forEach(function (name) {
                into[name] = from[name];
            });

            return into;
        };

        exports.finalize = function () {
            Object.keys(defCache).forEach(function (name) {
                defCache[name].finalize();
            });
        };

        return exports;
    };
});
System.registerDynamic("npm:ast-types@0.9.2/lib/shared.js", ["npm:ast-types@0.9.2/lib/types.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    var exports = {};
    var types = fork.use($__require("npm:ast-types@0.9.2/lib/types.js"));
    var Type = types.Type;
    var builtin = types.builtInTypes;
    var isNumber = builtin.number;
    exports.geq = function (than) {
      return new Type(function (value) {
        return isNumber.check(value) && value >= than;
      }, isNumber + " >= " + than);
    };
    exports.defaults = {
      "null": function () {
        return null;
      },
      "emptyArray": function () {
        return [];
      },
      "false": function () {
        return false;
      },
      "true": function () {
        return true;
      },
      "undefined": function () {}
    };
    var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);
    exports.isPrimitive = new Type(function (value) {
      if (value === null) return true;
      var type = typeof value;
      return !(type === "object" || type === "function");
    }, naiveIsPrimitive.toString());
    return exports;
  };
});
System.registerDynamic('npm:ast-types@0.9.2/def/babel6.js', ['npm:ast-types@0.9.2/def/babel.js', 'npm:ast-types@0.9.2/def/flow.js', 'npm:ast-types@0.9.2/lib/types.js', 'npm:ast-types@0.9.2/lib/shared.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (fork) {
    fork.use($__require('npm:ast-types@0.9.2/def/babel.js'));
    fork.use($__require('npm:ast-types@0.9.2/def/flow.js'));
    var types = fork.use($__require('npm:ast-types@0.9.2/lib/types.js'));
    var defaults = fork.use($__require('npm:ast-types@0.9.2/lib/shared.js')).defaults;
    var def = types.Type.def;
    var or = types.Type.or;
    def("Directive").bases("Node").build("value").field("value", def("DirectiveLiteral"));
    def("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, defaults["use strict"]);
    def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults.emptyArray);
    def("Program").bases("Node").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults.emptyArray);
    def("StringLiteral").bases("Literal").build("value").field("value", String);
    def("NumericLiteral").bases("Literal").build("value").field("value", Number);
    def("NullLiteral").bases("Literal").build();
    def("BooleanLiteral").bases("Literal").build("value").field("value", Boolean);
    def("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String);
    var ObjectExpressionProperty = or(def("Property"), def("ObjectMethod"), def("ObjectProperty"), def("SpreadProperty"));
    def("ObjectExpression").bases("Expression").build("properties").field("properties", [ObjectExpressionProperty]);
    def("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", or("method", "get", "set")).field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("computed", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]).field("decorators", or([def("Decorator")], null), defaults["null"]);
    def("ObjectProperty").bases("Node").build("key", "value").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("computed", Boolean, defaults["false"]);
    var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassMethod"));
    def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
    def("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("kind", or("get", "set", "method", "constructor")).field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("computed", Boolean, defaults["false"]).field("static", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]).field("decorators", or([def("Decorator")], null), defaults["null"]);
    var ObjectPatternProperty = or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"), def("ObjectProperty"), def("RestProperty"));
    def("ObjectPattern").bases("Pattern").build("properties").field("properties", [ObjectPatternProperty]).field("decorators", or([def("Decorator")], null), defaults["null"]);
    def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
    def("RestProperty").bases("Node").build("argument").field("argument", def("Expression"));
    def("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
  };
});
System.registerDynamic('npm:ast-types@0.9.2/main.js', ['npm:ast-types@0.9.2/fork.js', 'npm:ast-types@0.9.2/def/core.js', 'npm:ast-types@0.9.2/def/es6.js', 'npm:ast-types@0.9.2/def/es7.js', 'npm:ast-types@0.9.2/def/mozilla.js', 'npm:ast-types@0.9.2/def/e4x.js', 'npm:ast-types@0.9.2/def/jsx.js', 'npm:ast-types@0.9.2/def/flow.js', 'npm:ast-types@0.9.2/def/esprima.js', 'npm:ast-types@0.9.2/def/babel.js', 'npm:ast-types@0.9.2/def/babel6.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('npm:ast-types@0.9.2/fork.js')([$__require('npm:ast-types@0.9.2/def/core.js'), $__require('npm:ast-types@0.9.2/def/es6.js'), $__require('npm:ast-types@0.9.2/def/es7.js'), $__require('npm:ast-types@0.9.2/def/mozilla.js'), $__require('npm:ast-types@0.9.2/def/e4x.js'), $__require('npm:ast-types@0.9.2/def/jsx.js'), $__require('npm:ast-types@0.9.2/def/flow.js'), $__require('npm:ast-types@0.9.2/def/esprima.js'), $__require('npm:ast-types@0.9.2/def/babel.js'), $__require('npm:ast-types@0.9.2/def/babel6.js')]);
});
System.registerDynamic("npm:ast-types@0.9.2.js", ["npm:ast-types@0.9.2/main.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:ast-types@0.9.2/main.js");
});
System.registerDynamic("npm:recast@0.11.18/lib/types.js", ["npm:ast-types@0.9.2.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // This module was originally created so that Recast could add its own
  // custom types to the AST type system (in particular, the File type), but
  // those types are now incorporated into ast-types, so this module doesn't
  // have much to do anymore. Still, it might prove useful in the future.
  module.exports = $__require("npm:ast-types@0.9.2.js");
});
System.registerDynamic("npm:source-map@0.5.6/lib/binary-search.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    } else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }

    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }

    return index;
  };
});
System.registerDynamic("npm:source-map@0.5.6/lib/quick-sort.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;

      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  exports.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
});
System.registerDynamic('npm:source-map@0.5.6/lib/source-map-consumer.js', ['npm:source-map@0.5.6/lib/util.js', 'npm:source-map@0.5.6/lib/binary-search.js', 'npm:source-map@0.5.6/lib/array-set.js', 'npm:source-map@0.5.6/lib/base64-vlq.js', 'npm:source-map@0.5.6/lib/quick-sort.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var util = $__require('npm:source-map@0.5.6/lib/util.js');
  var binarySearch = $__require('npm:source-map@0.5.6/lib/binary-search.js');
  var ArraySet = $__require('npm:source-map@0.5.6/lib/array-set.js').ArraySet;
  var base64VLQ = $__require('npm:source-map@0.5.6/lib/base64-vlq.js');
  var quickSort = $__require('npm:source-map@0.5.6/lib/quick-sort.js').quickSort;
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
  }
  SourceMapConsumer.fromSourceMap = function (aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', { get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    } });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', { get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    } });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };
    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  exports.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }
    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }
    sources = sources.map(String).map(util.normalize).map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', { get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    } });
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ',') {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }
          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }
          cachedSegments[str] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }
    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);
    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }
    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', { get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    } });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});
System.registerDynamic('npm:source-map@0.5.6/lib/base64.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };

  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  exports.decode = function (charCode) {
    var bigA = 65; // 'A'
    var bigZ = 90; // 'Z'

    var littleA = 97; // 'a'
    var littleZ = 122; // 'z'

    var zero = 48; // '0'
    var nine = 57; // '9'

    var plus = 43; // '+'
    var slash = 47; // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }

    // 62: +
    if (charCode == plus) {
      return 62;
    }

    // 63: /
    if (charCode == slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  };
});
System.registerDynamic("npm:source-map@0.5.6/lib/base64-vlq.js", ["npm:source-map@0.5.6/lib/base64.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var base64 = $__require("npm:source-map@0.5.6/lib/base64.js");
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});
System.registerDynamic('npm:source-map@0.5.6/lib/array-set.js', ['npm:source-map@0.5.6/lib/util.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var util = $__require('npm:source-map@0.5.6/lib/util.js');
  var has = Object.prototype.hasOwnProperty;
  function ArraySet() {
    this._array = [];
    this._set = Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = util.toSetString(aStr);
    var isDuplicate = has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[sStr] = idx;
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports.ArraySet = ArraySet;
});
System.registerDynamic('npm:source-map@0.5.6/lib/mapping-list.js', ['npm:source-map@0.5.6/lib/util.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var util = $__require('npm:source-map@0.5.6/lib/util.js');
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports.MappingList = MappingList;
});
System.registerDynamic('npm:source-map@0.5.6/lib/source-map-generator.js', ['npm:source-map@0.5.6/lib/base64-vlq.js', 'npm:source-map@0.5.6/lib/util.js', 'npm:source-map@0.5.6/lib/array-set.js', 'npm:source-map@0.5.6/lib/mapping-list.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var base64VLQ = $__require('npm:source-map@0.5.6/lib/base64-vlq.js');
  var util = $__require('npm:source-map@0.5.6/lib/util.js');
  var ArraySet = $__require('npm:source-map@0.5.6/lib/array-set.js').ArraySet;
  var MappingList = $__require('npm:source-map@0.5.6/lib/mapping-list.js').MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = { generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        } };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports.SourceMapGenerator = SourceMapGenerator;
});
System.registerDynamic('npm:source-map@0.5.6/lib/util.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
  };

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;

  var supportsNullProto = function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }();

  function identity(s) {
    return s;
  }

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9 /* "__proto__".length */) {
        return false;
      }

    if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
        return false;
      }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36 /* '$' */) {
          return false;
        }
    }

    return true;
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
});
System.registerDynamic('npm:source-map@0.5.6/lib/source-node.js', ['npm:source-map@0.5.6/lib/source-map-generator.js', 'npm:source-map@0.5.6/lib/util.js', 'github:jspm/nodelibs-process@0.1.2.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var SourceMapGenerator = $__require('npm:source-map@0.5.6/lib/source-map-generator.js').SourceMapGenerator;
    var util = $__require('npm:source-map@0.5.6/lib/util.js');
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var shiftNextLine = function () {
        var lineContents = remainingLines.shift();
        var newLine = remainingLines.shift() || "";
        return lineContents + newLine;
      };
      var lastGeneratedLine = 1,
          lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLines.length > 0) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.join(""));
      }
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function (chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== '') {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === 'string') {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push(''.replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function (chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function (chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({ generated: {
              line: generated.line,
              column: generated.column
            } });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function (sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return {
        code: generated.code,
        map: map
      };
    };
    exports.SourceNode = SourceNode;
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
});
System.registerDynamic('npm:source-map@0.5.6/source-map.js', ['npm:source-map@0.5.6/lib/source-map-generator.js', 'npm:source-map@0.5.6/lib/source-map-consumer.js', 'npm:source-map@0.5.6/lib/source-node.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  exports.SourceMapGenerator = $__require('npm:source-map@0.5.6/lib/source-map-generator.js').SourceMapGenerator;
  exports.SourceMapConsumer = $__require('npm:source-map@0.5.6/lib/source-map-consumer.js').SourceMapConsumer;
  exports.SourceNode = $__require('npm:source-map@0.5.6/lib/source-node.js').SourceNode;
});
System.registerDynamic("npm:source-map@0.5.6.js", ["npm:source-map@0.5.6/source-map.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:source-map@0.5.6/source-map.js");
});
System.registerDynamic('npm:recast@0.11.18/lib/util.js', ['github:jspm/nodelibs-assert@0.1.0.js', 'npm:recast@0.11.18/lib/types.js', 'npm:source-map@0.5.6.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var assert = $__require('github:jspm/nodelibs-assert@0.1.0.js');
  var types = $__require('npm:recast@0.11.18/lib/types.js');
  var getFieldValue = types.getFieldValue;
  var n = types.namedTypes;
  var sourceMap = $__require('npm:source-map@0.5.6.js');
  var SourceMapConsumer = sourceMap.SourceMapConsumer;
  var SourceMapGenerator = sourceMap.SourceMapGenerator;
  var hasOwn = Object.prototype.hasOwnProperty;
  var util = exports;
  function getUnionOfKeys() {
    var result = {};
    var argc = arguments.length;
    for (var i = 0; i < argc; ++i) {
      var keys = Object.keys(arguments[i]);
      var keyCount = keys.length;
      for (var j = 0; j < keyCount; ++j) {
        result[keys[j]] = true;
      }
    }
    return result;
  }
  util.getUnionOfKeys = getUnionOfKeys;
  function comparePos(pos1, pos2) {
    return pos1.line - pos2.line || pos1.column - pos2.column;
  }
  util.comparePos = comparePos;
  function copyPos(pos) {
    return {
      line: pos.line,
      column: pos.column
    };
  }
  util.copyPos = copyPos;
  util.composeSourceMaps = function (formerMap, latterMap) {
    if (formerMap) {
      if (!latterMap) {
        return formerMap;
      }
    } else {
      return latterMap || null;
    }
    var smcFormer = new SourceMapConsumer(formerMap);
    var smcLatter = new SourceMapConsumer(latterMap);
    var smg = new SourceMapGenerator({
      file: latterMap.file,
      sourceRoot: latterMap.sourceRoot
    });
    var sourcesToContents = {};
    smcLatter.eachMapping(function (mapping) {
      var origPos = smcFormer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });
      var sourceName = origPos.source;
      if (sourceName === null) {
        return;
      }
      smg.addMapping({
        source: sourceName,
        original: copyPos(origPos),
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        },
        name: mapping.name
      });
      var sourceContent = smcFormer.sourceContentFor(sourceName);
      if (sourceContent && !hasOwn.call(sourcesToContents, sourceName)) {
        sourcesToContents[sourceName] = sourceContent;
        smg.setSourceContent(sourceName, sourceContent);
      }
    });
    return smg.toJSON();
  };
  util.getTrueLoc = function (node, lines) {
    if (!node.loc) {
      return null;
    }
    var result = {
      start: node.loc.start,
      end: node.loc.end
    };
    function include(node) {
      expandLoc(result, node.loc);
    }
    if (node.comments) {
      node.comments.forEach(include);
    }
    if (node.declaration && util.isExportDeclaration(node) && node.declaration.decorators) {
      node.declaration.decorators.forEach(include);
    }
    if (comparePos(result.start, result.end) < 0) {
      result.start = copyPos(result.start);
      lines.skipSpaces(result.start, false, true);
      if (comparePos(result.start, result.end) < 0) {
        result.end = copyPos(result.end);
        lines.skipSpaces(result.end, true, true);
      }
    }
    return result;
  };
  function expandLoc(parentLoc, childLoc) {
    if (parentLoc && childLoc) {
      if (comparePos(childLoc.start, parentLoc.start) < 0) {
        parentLoc.start = childLoc.start;
      }
      if (comparePos(parentLoc.end, childLoc.end) < 0) {
        parentLoc.end = childLoc.end;
      }
    }
  }
  util.fixFaultyLocations = function (node, lines) {
    var loc = node.loc;
    if (loc) {
      if (loc.start.line < 1) {
        loc.start.line = 1;
      }
      if (loc.end.line < 1) {
        loc.end.line = 1;
      }
    }
    if (node.type === "TemplateLiteral") {
      fixTemplateLiteral(node, lines);
    } else if (loc && node.decorators) {
      node.decorators.forEach(function (decorator) {
        expandLoc(loc, decorator.loc);
      });
    } else if (node.declaration && util.isExportDeclaration(node)) {
      node.declaration.loc = null;
      var decorators = node.declaration.decorators;
      if (decorators) {
        decorators.forEach(function (decorator) {
          expandLoc(loc, decorator.loc);
        });
      }
    } else if (n.MethodDefinition && n.MethodDefinition.check(node) || n.Property.check(node) && (node.method || node.shorthand)) {
      node.value.loc = null;
      if (n.FunctionExpression.check(node.value)) {
        node.value.id = null;
      }
    } else if (node.type === "ObjectTypeProperty") {
      var loc = node.loc;
      var end = loc && loc.end;
      if (end) {
        end = copyPos(end);
        if (lines.prevPos(end) && lines.charAt(end) === ",") {
          if (end = lines.skipSpaces(end, true, true)) {
            loc.end = end;
          }
        }
      }
    }
  };
  function fixTemplateLiteral(node, lines) {
    assert.strictEqual(node.type, "TemplateLiteral");
    if (node.quasis.length === 0) {
      return;
    }
    var afterLeftBackTickPos = copyPos(node.loc.start);
    assert.strictEqual(lines.charAt(afterLeftBackTickPos), "`");
    assert.ok(lines.nextPos(afterLeftBackTickPos));
    var firstQuasi = node.quasis[0];
    if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {
      firstQuasi.loc.start = afterLeftBackTickPos;
    }
    var rightBackTickPos = copyPos(node.loc.end);
    assert.ok(lines.prevPos(rightBackTickPos));
    assert.strictEqual(lines.charAt(rightBackTickPos), "`");
    var lastQuasi = node.quasis[node.quasis.length - 1];
    if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {
      lastQuasi.loc.end = rightBackTickPos;
    }
    node.expressions.forEach(function (expr, i) {
      var dollarCurlyPos = lines.skipSpaces(expr.loc.start, true, false);
      if (lines.prevPos(dollarCurlyPos) && lines.charAt(dollarCurlyPos) === "{" && lines.prevPos(dollarCurlyPos) && lines.charAt(dollarCurlyPos) === "$") {
        var quasiBefore = node.quasis[i];
        if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {
          quasiBefore.loc.end = dollarCurlyPos;
        }
      }
      var rightCurlyPos = lines.skipSpaces(expr.loc.end, false, false);
      if (lines.charAt(rightCurlyPos) === "}") {
        assert.ok(lines.nextPos(rightCurlyPos));
        var quasiAfter = node.quasis[i + 1];
        if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {
          quasiAfter.loc.start = rightCurlyPos;
        }
      }
    });
  }
  util.isExportDeclaration = function (node) {
    if (node) switch (node.type) {
      case "ExportDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportDefaultSpecifier":
      case "DeclareExportDeclaration":
      case "ExportNamedDeclaration":
      case "ExportAllDeclaration":
        return true;
    }
    return false;
  };
  util.getParentExportDeclaration = function (path) {
    var parentNode = path.getParentNode();
    if (path.getName() === "declaration" && util.isExportDeclaration(parentNode)) {
      return parentNode;
    }
    return null;
  };
  util.isTrailingCommaEnabled = function (options, context) {
    var trailingComma = options.trailingComma;
    if (typeof trailingComma === "object") {
      return !!trailingComma[context];
    }
    return !!trailingComma;
  };
});
System.registerDynamic('npm:recast@0.11.18/lib/printer.js', ['github:jspm/nodelibs-assert@0.1.0.js', 'npm:source-map@0.5.6.js', 'npm:recast@0.11.18/lib/comments.js', 'npm:recast@0.11.18/lib/lines.js', 'npm:recast@0.11.18/lib/options.js', 'npm:recast@0.11.18/lib/patcher.js', 'npm:recast@0.11.18/lib/types.js', 'npm:recast@0.11.18/lib/fast-path.js', 'npm:recast@0.11.18/lib/util.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var assert = $__require('github:jspm/nodelibs-assert@0.1.0.js');
  var sourceMap = $__require('npm:source-map@0.5.6.js');
  var printComments = $__require('npm:recast@0.11.18/lib/comments.js').printComments;
  var linesModule = $__require('npm:recast@0.11.18/lib/lines.js');
  var fromString = linesModule.fromString;
  var concat = linesModule.concat;
  var normalizeOptions = $__require('npm:recast@0.11.18/lib/options.js').normalize;
  var getReprinter = $__require('npm:recast@0.11.18/lib/patcher.js').getReprinter;
  var types = $__require('npm:recast@0.11.18/lib/types.js');
  var namedTypes = types.namedTypes;
  var isString = types.builtInTypes.string;
  var isObject = types.builtInTypes.object;
  var FastPath = $__require('npm:recast@0.11.18/lib/fast-path.js');
  var util = $__require('npm:recast@0.11.18/lib/util.js');
  function PrintResult(code, sourceMap) {
    assert.ok(this instanceof PrintResult);
    isString.assert(code);
    this.code = code;
    if (sourceMap) {
      isObject.assert(sourceMap);
      this.map = sourceMap;
    }
  }
  var PRp = PrintResult.prototype;
  var warnedAboutToString = false;
  PRp.toString = function () {
    if (!warnedAboutToString) {
      console.warn("Deprecation warning: recast.print now returns an object with " + "a .code property. You appear to be treating the object as a " + "string, which might still work but is strongly discouraged.");
      warnedAboutToString = true;
    }
    return this.code;
  };
  var emptyPrintResult = new PrintResult("");
  function Printer(originalOptions) {
    assert.ok(this instanceof Printer);
    var explicitTabWidth = originalOptions && originalOptions.tabWidth;
    var options = normalizeOptions(originalOptions);
    assert.notStrictEqual(options, originalOptions);
    options.sourceFileName = null;
    function printWithComments(path) {
      assert.ok(path instanceof FastPath);
      return printComments(path, print);
    }
    function print(path, includeComments) {
      if (includeComments) return printWithComments(path);
      assert.ok(path instanceof FastPath);
      if (!explicitTabWidth) {
        var oldTabWidth = options.tabWidth;
        var loc = path.getNode().loc;
        if (loc && loc.lines && loc.lines.guessTabWidth) {
          options.tabWidth = loc.lines.guessTabWidth();
          var lines = maybeReprint(path);
          options.tabWidth = oldTabWidth;
          return lines;
        }
      }
      return maybeReprint(path);
    }
    function maybeReprint(path) {
      var reprinter = getReprinter(path);
      if (reprinter) {
        return maybeAddParens(path, reprinter(print));
      }
      return printRootGenerically(path);
    }
    function printRootGenerically(path, includeComments) {
      return includeComments ? printComments(path, printRootGenerically) : genericPrint(path, options, printWithComments);
    }
    function printGenerically(path) {
      return genericPrint(path, options, printGenerically);
    }
    this.print = function (ast) {
      if (!ast) {
        return emptyPrintResult;
      }
      var lines = print(FastPath.from(ast), true);
      return new PrintResult(lines.toString(options), util.composeSourceMaps(options.inputSourceMap, lines.getSourceMap(options.sourceMapName, options.sourceRoot)));
    };
    this.printGenerically = function (ast) {
      if (!ast) {
        return emptyPrintResult;
      }
      var path = FastPath.from(ast);
      var oldReuseWhitespace = options.reuseWhitespace;
      options.reuseWhitespace = false;
      var pr = new PrintResult(printGenerically(path).toString(options));
      options.reuseWhitespace = oldReuseWhitespace;
      return pr;
    };
  }
  exports.Printer = Printer;
  function maybeAddParens(path, lines) {
    return path.needsParens() ? concat(["(", lines, ")"]) : lines;
  }
  function genericPrint(path, options, printPath) {
    assert.ok(path instanceof FastPath);
    var node = path.getValue();
    var parts = [];
    var needsParens = false;
    var linesWithoutParens = genericPrintNoParens(path, options, printPath);
    if (!node || linesWithoutParens.isEmpty()) {
      return linesWithoutParens;
    }
    if (node.decorators && node.decorators.length > 0 && !util.getParentExportDeclaration(path)) {
      path.each(function (decoratorPath) {
        parts.push(printPath(decoratorPath), "\n");
      }, "decorators");
    } else if (util.isExportDeclaration(node) && node.declaration && node.declaration.decorators) {
      path.each(function (decoratorPath) {
        parts.push(printPath(decoratorPath), "\n");
      }, "declaration", "decorators");
    } else {
      needsParens = path.needsParens();
    }
    if (needsParens) {
      parts.unshift("(");
    }
    parts.push(linesWithoutParens);
    if (needsParens) {
      parts.push(")");
    }
    return concat(parts);
  }
  function genericPrintNoParens(path, options, print) {
    var n = path.getValue();
    if (!n) {
      return fromString("");
    }
    if (typeof n === "string") {
      return fromString(n, options);
    }
    namedTypes.Printable.assert(n);
    var parts = [];
    switch (n.type) {
      case "File":
        return path.call(print, "program");
      case "Program":
        if (n.directives) {
          path.each(function (childPath) {
            parts.push(print(childPath), ";\n");
          }, "directives");
        }
        parts.push(path.call(function (bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        }, "body"));
        return concat(parts);
      case "Noop":
      case "EmptyStatement":
        return fromString("");
      case "ExpressionStatement":
        return concat([path.call(print, "expression"), ";"]);
      case "ParenthesizedExpression":
        return concat(["(", path.call(print, "expression"), ")"]);
      case "BinaryExpression":
      case "LogicalExpression":
      case "AssignmentExpression":
        return fromString(" ").join([path.call(print, "left"), n.operator, path.call(print, "right")]);
      case "AssignmentPattern":
        return concat([path.call(print, "left"), " = ", path.call(print, "right")]);
      case "MemberExpression":
        parts.push(path.call(print, "object"));
        var property = path.call(print, "property");
        if (n.computed) {
          parts.push("[", property, "]");
        } else {
          parts.push(".", property);
        }
        return concat(parts);
      case "MetaProperty":
        return concat([path.call(print, "meta"), ".", path.call(print, "property")]);
      case "BindExpression":
        if (n.object) {
          parts.push(path.call(print, "object"));
        }
        parts.push("::", path.call(print, "callee"));
        return concat(parts);
      case "Path":
        return fromString(".").join(n.body);
      case "Identifier":
        return concat([fromString(n.name, options), path.call(print, "typeAnnotation")]);
      case "SpreadElement":
      case "SpreadElementPattern":
      case "RestProperty":
      case "SpreadProperty":
      case "SpreadPropertyPattern":
      case "RestElement":
        return concat(["...", path.call(print, "argument")]);
      case "FunctionDeclaration":
      case "FunctionExpression":
        if (n.async) parts.push("async ");
        parts.push("function");
        if (n.generator) parts.push("*");
        if (n.id) {
          parts.push(" ", path.call(print, "id"), path.call(print, "typeParameters"));
        }
        parts.push("(", printFunctionParams(path, options, print), ")", path.call(print, "returnType"), " ", path.call(print, "body"));
        return concat(parts);
      case "ArrowFunctionExpression":
        if (n.async) parts.push("async ");
        if (n.typeParameters) {
          parts.push(path.call(print, "typeParameters"));
        }
        if (!options.arrowParensAlways && n.params.length === 1 && !n.rest && n.params[0].type === 'Identifier' && !n.params[0].typeAnnotation && !n.returnType) {
          parts.push(path.call(print, "params", 0));
        } else {
          parts.push("(", printFunctionParams(path, options, print), ")", path.call(print, "returnType"));
        }
        parts.push(" => ", path.call(print, "body"));
        return concat(parts);
      case "MethodDefinition":
        if (n.static) {
          parts.push("static ");
        }
        parts.push(printMethod(path, options, print));
        return concat(parts);
      case "YieldExpression":
        parts.push("yield");
        if (n.delegate) parts.push("*");
        if (n.argument) parts.push(" ", path.call(print, "argument"));
        return concat(parts);
      case "AwaitExpression":
        parts.push("await");
        if (n.all) parts.push("*");
        if (n.argument) parts.push(" ", path.call(print, "argument"));
        return concat(parts);
      case "ModuleDeclaration":
        parts.push("module", path.call(print, "id"));
        if (n.source) {
          assert.ok(!n.body);
          parts.push("from", path.call(print, "source"));
        } else {
          parts.push(path.call(print, "body"));
        }
        return fromString(" ").join(parts);
      case "ImportSpecifier":
        if (n.imported) {
          parts.push(path.call(print, "imported"));
          if (n.local && n.local.name !== n.imported.name) {
            parts.push(" as ", path.call(print, "local"));
          }
        } else if (n.id) {
          parts.push(path.call(print, "id"));
          if (n.name) {
            parts.push(" as ", path.call(print, "name"));
          }
        }
        return concat(parts);
      case "ExportSpecifier":
        if (n.local) {
          parts.push(path.call(print, "local"));
          if (n.exported && n.exported.name !== n.local.name) {
            parts.push(" as ", path.call(print, "exported"));
          }
        } else if (n.id) {
          parts.push(path.call(print, "id"));
          if (n.name) {
            parts.push(" as ", path.call(print, "name"));
          }
        }
        return concat(parts);
      case "ExportBatchSpecifier":
        return fromString("*");
      case "ImportNamespaceSpecifier":
        parts.push("* as ");
        if (n.local) {
          parts.push(path.call(print, "local"));
        } else if (n.id) {
          parts.push(path.call(print, "id"));
        }
        return concat(parts);
      case "ImportDefaultSpecifier":
        if (n.local) {
          return path.call(print, "local");
        }
        return path.call(print, "id");
      case "ExportDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        return printExportDeclaration(path, options, print);
      case "ExportAllDeclaration":
        parts.push("export *");
        if (n.exported) {
          parts.push(" as ", path.call(print, "exported"));
        }
        parts.push(" from ", path.call(print, "source"));
        return concat(parts);
      case "ExportNamespaceSpecifier":
        return concat(["* as ", path.call(print, "exported")]);
      case "ExportDefaultSpecifier":
        return path.call(print, "exported");
      case "ImportDeclaration":
        parts.push("import ");
        if (n.importKind && n.importKind !== "value") {
          parts.push(n.importKind + " ");
        }
        if (n.specifiers && n.specifiers.length > 0) {
          var foundImportSpecifier = false;
          path.each(function (specifierPath) {
            var i = specifierPath.getName();
            if (i > 0) {
              parts.push(", ");
            }
            var value = specifierPath.getValue();
            if (namedTypes.ImportDefaultSpecifier.check(value) || namedTypes.ImportNamespaceSpecifier.check(value)) {
              assert.strictEqual(foundImportSpecifier, false);
            } else {
              namedTypes.ImportSpecifier.assert(value);
              if (!foundImportSpecifier) {
                foundImportSpecifier = true;
                parts.push(options.objectCurlySpacing ? "{ " : "{");
              }
            }
            parts.push(print(specifierPath));
          }, "specifiers");
          if (foundImportSpecifier) {
            parts.push(options.objectCurlySpacing ? " }" : "}");
          }
          parts.push(" from ");
        }
        parts.push(path.call(print, "source"), ";");
        return concat(parts);
      case "BlockStatement":
        var naked = path.call(function (bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        }, "body");
        if (naked.isEmpty()) {
          if (!n.directives || n.directives.length === 0) {
            return fromString("{}");
          }
        }
        parts.push("{\n");
        if (n.directives) {
          path.each(function (childPath) {
            parts.push(print(childPath).indent(options.tabWidth), ";", n.directives.length > 1 || !naked.isEmpty() ? "\n" : "");
          }, "directives");
        }
        parts.push(naked.indent(options.tabWidth));
        parts.push("\n}");
        return concat(parts);
      case "ReturnStatement":
        parts.push("return");
        if (n.argument) {
          var argLines = path.call(print, "argument");
          if (argLines.length > 1 && namedTypes.JSXElement && namedTypes.JSXElement.check(n.argument)) {
            parts.push(" (\n", argLines.indent(options.tabWidth), "\n)");
          } else {
            parts.push(" ", argLines);
          }
        }
        parts.push(";");
        return concat(parts);
      case "CallExpression":
        return concat([path.call(print, "callee"), printArgumentsList(path, options, print)]);
      case "ObjectExpression":
      case "ObjectPattern":
      case "ObjectTypeAnnotation":
        var allowBreak = false;
        var isTypeAnnotation = n.type === "ObjectTypeAnnotation";
        var separator = options.flowObjectCommas ? "," : isTypeAnnotation ? ";" : ",";
        var fields = [];
        if (isTypeAnnotation) {
          fields.push("indexers", "callProperties");
        }
        fields.push("properties");
        var len = 0;
        fields.forEach(function (field) {
          len += n[field].length;
        });
        var oneLine = isTypeAnnotation && len === 1 || len === 0;
        var leftBrace = n.exact ? "{|" : "{";
        var rightBrace = n.exact ? "|}" : "}";
        parts.push(oneLine ? leftBrace : leftBrace + "\n");
        var leftBraceIndex = parts.length - 1;
        var i = 0;
        fields.forEach(function (field) {
          path.each(function (childPath) {
            var lines = print(childPath);
            if (!oneLine) {
              lines = lines.indent(options.tabWidth);
            }
            var multiLine = !isTypeAnnotation && lines.length > 1;
            if (multiLine && allowBreak) {
              parts.push("\n");
            }
            parts.push(lines);
            if (i < len - 1) {
              parts.push(separator + (multiLine ? "\n\n" : "\n"));
              allowBreak = !multiLine;
            } else if (len !== 1 && isTypeAnnotation) {
              parts.push(separator);
            } else if (!oneLine && util.isTrailingCommaEnabled(options, "objects")) {
              parts.push(separator);
            }
            i++;
          }, field);
        });
        parts.push(oneLine ? rightBrace : "\n" + rightBrace);
        if (i !== 0 && oneLine && options.objectCurlySpacing) {
          parts[leftBraceIndex] = leftBrace + " ";
          parts[parts.length - 1] = " " + rightBrace;
        }
        return concat(parts);
      case "PropertyPattern":
        return concat([path.call(print, "key"), ": ", path.call(print, "pattern")]);
      case "ObjectProperty":
      case "Property":
        if (n.method || n.kind === "get" || n.kind === "set") {
          return printMethod(path, options, print);
        }
        var key = path.call(print, "key");
        if (n.computed) {
          parts.push("[", key, "]");
        } else {
          parts.push(key);
        }
        if (!n.shorthand) {
          parts.push(": ", path.call(print, "value"));
        }
        return concat(parts);
      case "ClassMethod":
        if (n.static) {
          parts.push("static ");
        }
        return concat([parts, printObjectMethod(path, options, print)]);
      case "ObjectMethod":
        return printObjectMethod(path, options, print);
      case "Decorator":
        return concat(["@", path.call(print, "expression")]);
      case "ArrayExpression":
      case "ArrayPattern":
        var elems = n.elements,
            len = elems.length;
        var printed = path.map(print, "elements");
        var joined = fromString(", ").join(printed);
        var oneLine = joined.getLineLength(1) <= options.wrapColumn;
        if (oneLine) {
          if (options.arrayBracketSpacing) {
            parts.push("[ ");
          } else {
            parts.push("[");
          }
        } else {
          parts.push("[\n");
        }
        path.each(function (elemPath) {
          var i = elemPath.getName();
          var elem = elemPath.getValue();
          if (!elem) {
            parts.push(",");
          } else {
            var lines = printed[i];
            if (oneLine) {
              if (i > 0) parts.push(" ");
            } else {
              lines = lines.indent(options.tabWidth);
            }
            parts.push(lines);
            if (i < len - 1 || !oneLine && util.isTrailingCommaEnabled(options, "arrays")) parts.push(",");
            if (!oneLine) parts.push("\n");
          }
        }, "elements");
        if (oneLine && options.arrayBracketSpacing) {
          parts.push(" ]");
        } else {
          parts.push("]");
        }
        return concat(parts);
      case "SequenceExpression":
        return fromString(", ").join(path.map(print, "expressions"));
      case "ThisExpression":
        return fromString("this");
      case "Super":
        return fromString("super");
      case "NullLiteral":
        return fromString("null");
      case "RegExpLiteral":
        return fromString(n.extra.raw);
      case "BooleanLiteral":
      case "NumericLiteral":
      case "StringLiteral":
      case "Literal":
        if (typeof n.value !== "string") return fromString(n.value, options);
        return fromString(nodeStr(n.value, options), options);
      case "Directive":
        return path.call(print, "value");
      case "DirectiveLiteral":
        return fromString(nodeStr(n.value, options));
      case "ModuleSpecifier":
        if (n.local) {
          throw new Error("The ESTree ModuleSpecifier type should be abstract");
        }
        return fromString(nodeStr(n.value, options), options);
      case "UnaryExpression":
        parts.push(n.operator);
        if (/[a-z]$/.test(n.operator)) parts.push(" ");
        parts.push(path.call(print, "argument"));
        return concat(parts);
      case "UpdateExpression":
        parts.push(path.call(print, "argument"), n.operator);
        if (n.prefix) parts.reverse();
        return concat(parts);
      case "ConditionalExpression":
        return concat(["(", path.call(print, "test"), " ? ", path.call(print, "consequent"), " : ", path.call(print, "alternate"), ")"]);
      case "NewExpression":
        parts.push("new ", path.call(print, "callee"));
        var args = n.arguments;
        if (args) {
          parts.push(printArgumentsList(path, options, print));
        }
        return concat(parts);
      case "VariableDeclaration":
        parts.push(n.kind, " ");
        var maxLen = 0;
        var printed = path.map(function (childPath) {
          var lines = print(childPath);
          maxLen = Math.max(lines.length, maxLen);
          return lines;
        }, "declarations");
        if (maxLen === 1) {
          parts.push(fromString(", ").join(printed));
        } else if (printed.length > 1) {
          parts.push(fromString(",\n").join(printed).indentTail(n.kind.length + 1));
        } else {
          parts.push(printed[0]);
        }
        var parentNode = path.getParentNode();
        if (!namedTypes.ForStatement.check(parentNode) && !namedTypes.ForInStatement.check(parentNode) && !(namedTypes.ForOfStatement && namedTypes.ForOfStatement.check(parentNode)) && !(namedTypes.ForAwaitStatement && namedTypes.ForAwaitStatement.check(parentNode))) {
          parts.push(";");
        }
        return concat(parts);
      case "VariableDeclarator":
        return n.init ? fromString(" = ").join([path.call(print, "id"), path.call(print, "init")]) : path.call(print, "id");
      case "WithStatement":
        return concat(["with (", path.call(print, "object"), ") ", path.call(print, "body")]);
      case "IfStatement":
        var con = adjustClause(path.call(print, "consequent"), options),
            parts = ["if (", path.call(print, "test"), ")", con];
        if (n.alternate) parts.push(endsWithBrace(con) ? " else" : "\nelse", adjustClause(path.call(print, "alternate"), options));
        return concat(parts);
      case "ForStatement":
        var init = path.call(print, "init"),
            sep = init.length > 1 ? ";\n" : "; ",
            forParen = "for (",
            indented = fromString(sep).join([init, path.call(print, "test"), path.call(print, "update")]).indentTail(forParen.length),
            head = concat([forParen, indented, ")"]),
            clause = adjustClause(path.call(print, "body"), options),
            parts = [head];
        if (head.length > 1) {
          parts.push("\n");
          clause = clause.trimLeft();
        }
        parts.push(clause);
        return concat(parts);
      case "WhileStatement":
        return concat(["while (", path.call(print, "test"), ")", adjustClause(path.call(print, "body"), options)]);
      case "ForInStatement":
        return concat([n.each ? "for each (" : "for (", path.call(print, "left"), " in ", path.call(print, "right"), ")", adjustClause(path.call(print, "body"), options)]);
      case "ForOfStatement":
        return concat(["for (", path.call(print, "left"), " of ", path.call(print, "right"), ")", adjustClause(path.call(print, "body"), options)]);
      case "ForAwaitStatement":
        return concat(["for await (", path.call(print, "left"), " of ", path.call(print, "right"), ")", adjustClause(path.call(print, "body"), options)]);
      case "DoWhileStatement":
        var doBody = concat(["do", adjustClause(path.call(print, "body"), options)]),
            parts = [doBody];
        if (endsWithBrace(doBody)) parts.push(" while");else parts.push("\nwhile");
        parts.push(" (", path.call(print, "test"), ");");
        return concat(parts);
      case "DoExpression":
        var statements = path.call(function (bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        }, "body");
        return concat(["do {\n", statements.indent(options.tabWidth), "\n}"]);
      case "BreakStatement":
        parts.push("break");
        if (n.label) parts.push(" ", path.call(print, "label"));
        parts.push(";");
        return concat(parts);
      case "ContinueStatement":
        parts.push("continue");
        if (n.label) parts.push(" ", path.call(print, "label"));
        parts.push(";");
        return concat(parts);
      case "LabeledStatement":
        return concat([path.call(print, "label"), ":\n", path.call(print, "body")]);
      case "TryStatement":
        parts.push("try ", path.call(print, "block"));
        if (n.handler) {
          parts.push(" ", path.call(print, "handler"));
        } else if (n.handlers) {
          path.each(function (handlerPath) {
            parts.push(" ", print(handlerPath));
          }, "handlers");
        }
        if (n.finalizer) {
          parts.push(" finally ", path.call(print, "finalizer"));
        }
        return concat(parts);
      case "CatchClause":
        parts.push("catch (", path.call(print, "param"));
        if (n.guard) parts.push(" if ", path.call(print, "guard"));
        parts.push(") ", path.call(print, "body"));
        return concat(parts);
      case "ThrowStatement":
        return concat(["throw ", path.call(print, "argument"), ";"]);
      case "SwitchStatement":
        return concat(["switch (", path.call(print, "discriminant"), ") {\n", fromString("\n").join(path.map(print, "cases")), "\n}"]);
      case "SwitchCase":
        if (n.test) parts.push("case ", path.call(print, "test"), ":");else parts.push("default:");
        if (n.consequent.length > 0) {
          parts.push("\n", path.call(function (consequentPath) {
            return printStatementSequence(consequentPath, options, print);
          }, "consequent").indent(options.tabWidth));
        }
        return concat(parts);
      case "DebuggerStatement":
        return fromString("debugger;");
      case "JSXAttribute":
        parts.push(path.call(print, "name"));
        if (n.value) parts.push("=", path.call(print, "value"));
        return concat(parts);
      case "JSXIdentifier":
        return fromString(n.name, options);
      case "JSXNamespacedName":
        return fromString(":").join([path.call(print, "namespace"), path.call(print, "name")]);
      case "JSXMemberExpression":
        return fromString(".").join([path.call(print, "object"), path.call(print, "property")]);
      case "JSXSpreadAttribute":
        return concat(["{...", path.call(print, "argument"), "}"]);
      case "JSXExpressionContainer":
        return concat(["{", path.call(print, "expression"), "}"]);
      case "JSXElement":
        var openingLines = path.call(print, "openingElement");
        if (n.openingElement.selfClosing) {
          assert.ok(!n.closingElement);
          return openingLines;
        }
        var childLines = concat(path.map(function (childPath) {
          var child = childPath.getValue();
          if (namedTypes.Literal.check(child) && typeof child.value === "string") {
            if (/\S/.test(child.value)) {
              return child.value.replace(/^\s+|\s+$/g, "");
            } else if (/\n/.test(child.value)) {
              return "\n";
            }
          }
          return print(childPath);
        }, "children")).indentTail(options.tabWidth);
        var closingLines = path.call(print, "closingElement");
        return concat([openingLines, childLines, closingLines]);
      case "JSXOpeningElement":
        parts.push("<", path.call(print, "name"));
        var attrParts = [];
        path.each(function (attrPath) {
          attrParts.push(" ", print(attrPath));
        }, "attributes");
        var attrLines = concat(attrParts);
        var needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn;
        if (needLineWrap) {
          attrParts.forEach(function (part, i) {
            if (part === " ") {
              assert.strictEqual(i % 2, 0);
              attrParts[i] = "\n";
            }
          });
          attrLines = concat(attrParts).indentTail(options.tabWidth);
        }
        parts.push(attrLines, n.selfClosing ? " />" : ">");
        return concat(parts);
      case "JSXClosingElement":
        return concat(["</", path.call(print, "name"), ">"]);
      case "JSXText":
        return fromString(n.value, options);
      case "JSXEmptyExpression":
        return fromString("");
      case "TypeAnnotatedIdentifier":
        return concat([path.call(print, "annotation"), " ", path.call(print, "identifier")]);
      case "ClassBody":
        if (n.body.length === 0) {
          return fromString("{}");
        }
        return concat(["{\n", path.call(function (bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        }, "body").indent(options.tabWidth), "\n}"]);
      case "ClassPropertyDefinition":
        parts.push("static ", path.call(print, "definition"));
        if (!namedTypes.MethodDefinition.check(n.definition)) parts.push(";");
        return concat(parts);
      case "ClassProperty":
        if (n.static) parts.push("static ");
        var key = path.call(print, "key");
        if (n.computed) {
          key = concat(["[", key, "]"]);
        } else if (n.variance === "plus") {
          key = concat(["+", key]);
        } else if (n.variance === "minus") {
          key = concat(["-", key]);
        }
        parts.push(key);
        if (n.typeAnnotation) parts.push(path.call(print, "typeAnnotation"));
        if (n.value) parts.push(" = ", path.call(print, "value"));
        parts.push(";");
        return concat(parts);
      case "ClassDeclaration":
      case "ClassExpression":
        parts.push("class");
        if (n.id) {
          parts.push(" ", path.call(print, "id"), path.call(print, "typeParameters"));
        }
        if (n.superClass) {
          parts.push(" extends ", path.call(print, "superClass"), path.call(print, "superTypeParameters"));
        }
        if (n["implements"] && n['implements'].length > 0) {
          parts.push(" implements ", fromString(", ").join(path.map(print, "implements")));
        }
        parts.push(" ", path.call(print, "body"));
        return concat(parts);
      case "TemplateElement":
        return fromString(n.value.raw, options).lockIndentTail();
      case "TemplateLiteral":
        var expressions = path.map(print, "expressions");
        parts.push("`");
        path.each(function (childPath) {
          var i = childPath.getName();
          parts.push(print(childPath));
          if (i < expressions.length) {
            parts.push("${", expressions[i], "}");
          }
        }, "quasis");
        parts.push("`");
        return concat(parts).lockIndentTail();
      case "TaggedTemplateExpression":
        return concat([path.call(print, "tag"), path.call(print, "quasi")]);
      case "Node":
      case "Printable":
      case "SourceLocation":
      case "Position":
      case "Statement":
      case "Function":
      case "Pattern":
      case "Expression":
      case "Declaration":
      case "Specifier":
      case "NamedSpecifier":
      case "Comment":
      case "MemberTypeAnnotation":
      case "TupleTypeAnnotation":
      case "Type":
        throw new Error("unprintable type: " + JSON.stringify(n.type));
      case "CommentBlock":
      case "Block":
        return concat(["/*", fromString(n.value, options), "*/"]);
      case "CommentLine":
      case "Line":
        return concat(["//", fromString(n.value, options)]);
      case "TypeAnnotation":
        if (n.typeAnnotation) {
          if (n.typeAnnotation.type !== "FunctionTypeAnnotation") {
            parts.push(": ");
          }
          parts.push(path.call(print, "typeAnnotation"));
          return concat(parts);
        }
        return fromString("");
      case "ExistentialTypeParam":
      case "ExistsTypeAnnotation":
        return fromString("*", options);
      case "EmptyTypeAnnotation":
        return fromString("empty", options);
      case "AnyTypeAnnotation":
        return fromString("any", options);
      case "MixedTypeAnnotation":
        return fromString("mixed", options);
      case "ArrayTypeAnnotation":
        return concat([path.call(print, "elementType"), "[]"]);
      case "BooleanTypeAnnotation":
        return fromString("boolean", options);
      case "BooleanLiteralTypeAnnotation":
        assert.strictEqual(typeof n.value, "boolean");
        return fromString("" + n.value, options);
      case "DeclareClass":
        return printFlowDeclaration(path, ["class ", path.call(print, "id"), " ", path.call(print, "body")]);
      case "DeclareFunction":
        return printFlowDeclaration(path, ["function ", path.call(print, "id"), ";"]);
      case "DeclareModule":
        return printFlowDeclaration(path, ["module ", path.call(print, "id"), " ", path.call(print, "body")]);
      case "DeclareModuleExports":
        return printFlowDeclaration(path, ["module.exports", path.call(print, "typeAnnotation")]);
      case "DeclareVariable":
        return printFlowDeclaration(path, ["var ", path.call(print, "id"), ";"]);
      case "DeclareExportDeclaration":
        return concat(["declare ", printExportDeclaration(path, options, print)]);
      case "FunctionTypeAnnotation":
        var parent = path.getParentNode(0);
        var isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent) || namedTypes.DeclareFunction.check(path.getParentNode(2)));
        var needsColon = isArrowFunctionTypeAnnotation && !namedTypes.FunctionTypeParam.check(parent);
        if (needsColon) {
          parts.push(": ");
        }
        parts.push("(", fromString(", ").join(path.map(print, "params")), ")");
        if (n.returnType) {
          parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path.call(print, "returnType"));
        }
        return concat(parts);
      case "FunctionTypeParam":
        return concat([path.call(print, "name"), n.optional ? '?' : '', ": ", path.call(print, "typeAnnotation")]);
      case "GenericTypeAnnotation":
        return concat([path.call(print, "id"), path.call(print, "typeParameters")]);
      case "DeclareInterface":
        parts.push("declare ");
      case "InterfaceDeclaration":
        parts.push(fromString("interface ", options), path.call(print, "id"), path.call(print, "typeParameters"), " ");
        if (n["extends"]) {
          parts.push("extends ", fromString(", ").join(path.map(print, "extends")));
        }
        parts.push(" ", path.call(print, "body"));
        return concat(parts);
      case "ClassImplements":
      case "InterfaceExtends":
        return concat([path.call(print, "id"), path.call(print, "typeParameters")]);
      case "IntersectionTypeAnnotation":
        return fromString(" & ").join(path.map(print, "types"));
      case "NullableTypeAnnotation":
        return concat(["?", path.call(print, "typeAnnotation")]);
      case "NullLiteralTypeAnnotation":
        return fromString("null", options);
      case "ThisTypeAnnotation":
        return fromString("this", options);
      case "NumberTypeAnnotation":
        return fromString("number", options);
      case "ObjectTypeCallProperty":
        return path.call(print, "value");
      case "ObjectTypeIndexer":
        var variance = n.variance === "plus" ? "+" : n.variance === "minus" ? "-" : "";
        return concat([variance, "[", path.call(print, "id"), ": ", path.call(print, "key"), "]: ", path.call(print, "value")]);
      case "ObjectTypeProperty":
        var variance = n.variance === "plus" ? "+" : n.variance === "minus" ? "-" : "";
        return concat([variance, path.call(print, "key"), n.optional ? "?" : "", ": ", path.call(print, "value")]);
      case "QualifiedTypeIdentifier":
        return concat([path.call(print, "qualification"), ".", path.call(print, "id")]);
      case "StringLiteralTypeAnnotation":
        return fromString(nodeStr(n.value, options), options);
      case "NumberLiteralTypeAnnotation":
        assert.strictEqual(typeof n.value, "number");
        return fromString("" + n.value, options);
      case "StringTypeAnnotation":
        return fromString("string", options);
      case "DeclareTypeAlias":
        parts.push("declare ");
      case "TypeAlias":
        return concat(["type ", path.call(print, "id"), path.call(print, "typeParameters"), " = ", path.call(print, "right"), ";"]);
      case "TypeCastExpression":
        return concat(["(", path.call(print, "expression"), path.call(print, "typeAnnotation"), ")"]);
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
        return concat(["<", fromString(", ").join(path.map(print, "params")), ">"]);
      case "TypeParameter":
        switch (n.variance) {
          case 'plus':
            parts.push('+');
            break;
          case 'minus':
            parts.push('-');
            break;
          default:
        }
        parts.push(path.call(print, 'name'));
        if (n.bound) {
          parts.push(path.call(print, 'bound'));
        }
        if (n['default']) {
          parts.push('=', path.call(print, 'default'));
        }
        return concat(parts);
      case "TypeofTypeAnnotation":
        return concat([fromString("typeof ", options), path.call(print, "argument")]);
      case "UnionTypeAnnotation":
        return fromString(" | ").join(path.map(print, "types"));
      case "VoidTypeAnnotation":
        return fromString("void", options);
      case "NullTypeAnnotation":
        return fromString("null", options);
      case "ClassHeritage":
      case "ComprehensionBlock":
      case "ComprehensionExpression":
      case "Glob":
      case "GeneratorExpression":
      case "LetStatement":
      case "LetExpression":
      case "GraphExpression":
      case "GraphIndexExpression":
      case "XMLDefaultDeclaration":
      case "XMLAnyName":
      case "XMLQualifiedIdentifier":
      case "XMLFunctionQualifiedIdentifier":
      case "XMLAttributeSelector":
      case "XMLFilterExpression":
      case "XML":
      case "XMLElement":
      case "XMLList":
      case "XMLEscape":
      case "XMLText":
      case "XMLStartTag":
      case "XMLEndTag":
      case "XMLPointTag":
      case "XMLName":
      case "XMLAttribute":
      case "XMLCdata":
      case "XMLComment":
      case "XMLProcessingInstruction":
      default:
        debugger;
        throw new Error("unknown type: " + JSON.stringify(n.type));
    }
    return p;
  }
  function printStatementSequence(path, options, print) {
    var inClassBody = namedTypes.ClassBody && namedTypes.ClassBody.check(path.getParentNode());
    var filtered = [];
    var sawComment = false;
    var sawStatement = false;
    path.each(function (stmtPath) {
      var i = stmtPath.getName();
      var stmt = stmtPath.getValue();
      if (!stmt) {
        return;
      }
      if (stmt.type === "EmptyStatement") {
        return;
      }
      if (namedTypes.Comment.check(stmt)) {
        sawComment = true;
      } else if (namedTypes.Statement.check(stmt)) {
        sawStatement = true;
      } else {
        isString.assert(stmt);
      }
      filtered.push({
        node: stmt,
        printed: print(stmtPath)
      });
    });
    if (sawComment) {
      assert.strictEqual(sawStatement, false, "Comments may appear as statements in otherwise empty statement " + "lists, but may not coexist with non-Comment nodes.");
    }
    var prevTrailingSpace = null;
    var len = filtered.length;
    var parts = [];
    filtered.forEach(function (info, i) {
      var printed = info.printed;
      var stmt = info.node;
      var multiLine = printed.length > 1;
      var notFirst = i > 0;
      var notLast = i < len - 1;
      var leadingSpace;
      var trailingSpace;
      var lines = stmt && stmt.loc && stmt.loc.lines;
      var trueLoc = lines && options.reuseWhitespace && util.getTrueLoc(stmt, lines);
      if (notFirst) {
        if (trueLoc) {
          var beforeStart = lines.skipSpaces(trueLoc.start, true);
          var beforeStartLine = beforeStart ? beforeStart.line : 1;
          var leadingGap = trueLoc.start.line - beforeStartLine;
          leadingSpace = Array(leadingGap + 1).join("\n");
        } else {
          leadingSpace = multiLine ? "\n\n" : "\n";
        }
      } else {
        leadingSpace = "";
      }
      if (notLast) {
        if (trueLoc) {
          var afterEnd = lines.skipSpaces(trueLoc.end);
          var afterEndLine = afterEnd ? afterEnd.line : lines.length;
          var trailingGap = afterEndLine - trueLoc.end.line;
          trailingSpace = Array(trailingGap + 1).join("\n");
        } else {
          trailingSpace = multiLine ? "\n\n" : "\n";
        }
      } else {
        trailingSpace = "";
      }
      parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);
      if (notLast) {
        prevTrailingSpace = trailingSpace;
      } else if (trailingSpace) {
        parts.push(trailingSpace);
      }
    });
    return concat(parts);
  }
  function maxSpace(s1, s2) {
    if (!s1 && !s2) {
      return fromString("");
    }
    if (!s1) {
      return fromString(s2);
    }
    if (!s2) {
      return fromString(s1);
    }
    var spaceLines1 = fromString(s1);
    var spaceLines2 = fromString(s2);
    if (spaceLines2.length > spaceLines1.length) {
      return spaceLines2;
    }
    return spaceLines1;
  }
  function printMethod(path, options, print) {
    var node = path.getNode();
    var kind = node.kind;
    var parts = [];
    if (node.type === "ObjectMethod" || node.type === "ClassMethod") {
      node.value = node;
    } else {
      namedTypes.FunctionExpression.assert(node.value);
    }
    if (node.value.async) {
      parts.push("async ");
    }
    if (!kind || kind === "init" || kind === "method" || kind === "constructor") {
      if (node.value.generator) {
        parts.push("*");
      }
    } else {
      assert.ok(kind === "get" || kind === "set");
      parts.push(kind, " ");
    }
    var key = path.call(print, "key");
    if (node.computed) {
      key = concat(["[", key, "]"]);
    }
    parts.push(key, path.call(print, "value", "typeParameters"), "(", path.call(function (valuePath) {
      return printFunctionParams(valuePath, options, print);
    }, "value"), ")", path.call(print, "value", "returnType"), " ", path.call(print, "value", "body"));
    return concat(parts);
  }
  function printArgumentsList(path, options, print) {
    var printed = path.map(print, "arguments");
    var trailingComma = util.isTrailingCommaEnabled(options, "parameters");
    var joined = fromString(", ").join(printed);
    if (joined.getLineLength(1) > options.wrapColumn) {
      joined = fromString(",\n").join(printed);
      return concat(["(\n", joined.indent(options.tabWidth), trailingComma ? ",\n)" : "\n)"]);
    }
    return concat(["(", joined, ")"]);
  }
  function printFunctionParams(path, options, print) {
    var fun = path.getValue();
    namedTypes.Function.assert(fun);
    var printed = path.map(print, "params");
    if (fun.defaults) {
      path.each(function (defExprPath) {
        var i = defExprPath.getName();
        var p = printed[i];
        if (p && defExprPath.getValue()) {
          printed[i] = concat([p, " = ", print(defExprPath)]);
        }
      }, "defaults");
    }
    if (fun.rest) {
      printed.push(concat(["...", path.call(print, "rest")]));
    }
    var joined = fromString(", ").join(printed);
    if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {
      joined = fromString(",\n").join(printed);
      if (util.isTrailingCommaEnabled(options, "parameters") && !fun.rest && fun.params[fun.params.length - 1].type !== 'RestElement') {
        joined = concat([joined, ",\n"]);
      } else {
        joined = concat([joined, "\n"]);
      }
      return concat(["\n", joined.indent(options.tabWidth)]);
    }
    return joined;
  }
  function printObjectMethod(path, options, print) {
    var objMethod = path.getValue();
    var parts = [];
    if (objMethod.async) parts.push("async ");
    if (objMethod.generator) parts.push("*");
    if (objMethod.method || objMethod.kind === "get" || objMethod.kind === "set") {
      return printMethod(path, options, print);
    }
    var key = path.call(print, "key");
    if (objMethod.computed) {
      parts.push("[", key, "]");
    } else {
      parts.push(key);
    }
    parts.push("(", printFunctionParams(path, options, print), ")", path.call(print, "returnType"), " ", path.call(print, "body"));
    return concat(parts);
  }
  function printExportDeclaration(path, options, print) {
    var decl = path.getValue();
    var parts = ["export "];
    var shouldPrintSpaces = options.objectCurlySpacing;
    namedTypes.Declaration.assert(decl);
    if (decl["default"] || decl.type === "ExportDefaultDeclaration") {
      parts.push("default ");
    }
    if (decl.declaration) {
      parts.push(path.call(print, "declaration"));
    } else if (decl.specifiers && decl.specifiers.length > 0) {
      if (decl.specifiers.length === 1 && decl.specifiers[0].type === "ExportBatchSpecifier") {
        parts.push("*");
      } else {
        parts.push(shouldPrintSpaces ? "{ " : "{", fromString(", ").join(path.map(print, "specifiers")), shouldPrintSpaces ? " }" : "}");
      }
      if (decl.source) {
        parts.push(" from ", path.call(print, "source"));
      }
    }
    var lines = concat(parts);
    if (lastNonSpaceCharacter(lines) !== ";" && !(decl.declaration && (decl.declaration.type === "FunctionDeclaration" || decl.declaration.type === "ClassDeclaration"))) {
      lines = concat([lines, ";"]);
    }
    return lines;
  }
  function printFlowDeclaration(path, parts) {
    var parentExportDecl = util.getParentExportDeclaration(path);
    if (parentExportDecl) {
      assert.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
    } else {
      parts.unshift("declare ");
    }
    return concat(parts);
  }
  function adjustClause(clause, options) {
    if (clause.length > 1) return concat([" ", clause]);
    return concat(["\n", maybeAddSemicolon(clause).indent(options.tabWidth)]);
  }
  function lastNonSpaceCharacter(lines) {
    var pos = lines.lastPos();
    do {
      var ch = lines.charAt(pos);
      if (/\S/.test(ch)) return ch;
    } while (lines.prevPos(pos));
  }
  function endsWithBrace(lines) {
    return lastNonSpaceCharacter(lines) === "}";
  }
  function swapQuotes(str) {
    return str.replace(/['"]/g, function (m) {
      return m === '"' ? '\'' : '"';
    });
  }
  function nodeStr(str, options) {
    isString.assert(str);
    switch (options.quote) {
      case "auto":
        var double = JSON.stringify(str);
        var single = swapQuotes(JSON.stringify(swapQuotes(str)));
        return double.length > single.length ? single : double;
      case "single":
        return swapQuotes(JSON.stringify(swapQuotes(str)));
      case "double":
      default:
        return JSON.stringify(str);
    }
  }
  function maybeAddSemicolon(lines) {
    var eoc = lastNonSpaceCharacter(lines);
    if (!eoc || "\n};".indexOf(eoc) < 0) return concat([lines, ";"]);
    return lines;
  }
});
System.registerDynamic('npm:process@0.11.9/browser.js', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    })();
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
});
System.registerDynamic("npm:process@0.11.9.js", ["npm:process@0.11.9/browser.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:process@0.11.9/browser.js");
});
System.registerDynamic('github:jspm/nodelibs-process@0.1.2/index.js', ['npm:process@0.11.9.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = System._nodeRequire ? process : $__require('npm:process@0.11.9.js');
});
System.registerDynamic("github:jspm/nodelibs-process@0.1.2.js", ["github:jspm/nodelibs-process@0.1.2/index.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("github:jspm/nodelibs-process@0.1.2/index.js");
});
System.registerDynamic('npm:recast@0.11.18/main.js', ['npm:recast@0.11.18/lib/types.js', 'npm:recast@0.11.18/lib/parser.js', 'npm:recast@0.11.18/lib/printer.js', '@empty', 'github:jspm/nodelibs-process@0.1.2.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var types = $__require('npm:recast@0.11.18/lib/types.js');
    var parse = $__require('npm:recast@0.11.18/lib/parser.js').parse;
    var Printer = $__require('npm:recast@0.11.18/lib/printer.js').Printer;
    function print(node, options) {
      return new Printer(options).print(node);
    }
    function prettyPrint(node, options) {
      return new Printer(options).printGenerically(node);
    }
    function run(transformer, options) {
      return runFile(process.argv[2], transformer, options);
    }
    function runFile(path, transformer, options) {
      $__require('@empty').readFile(path, "utf-8", function (err, code) {
        if (err) {
          console.error(err);
          return;
        }
        runString(code, transformer, options);
      });
    }
    function defaultWriteback(output) {
      process.stdout.write(output);
    }
    function runString(code, transformer, options) {
      var writeback = options && options.writeback || defaultWriteback;
      transformer(parse(code, options), function (node) {
        writeback(print(node, options).code);
      });
    }
    Object.defineProperties(exports, {
      parse: {
        enumerable: true,
        value: parse
      },
      visit: {
        enumerable: true,
        value: types.visit
      },
      print: {
        enumerable: true,
        value: print
      },
      prettyPrint: {
        enumerable: false,
        value: prettyPrint
      },
      types: {
        enumerable: false,
        value: types
      },
      run: {
        enumerable: false,
        value: run
      }
    });
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
});
System.registerDynamic("npm:recast@0.11.18.js", ["npm:recast@0.11.18/main.js"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("npm:recast@0.11.18/main.js");
});
System.register("src/index.js", ["npm:babel-runtime@5.8.38/helpers/to-consumable-array.js", "npm:babel-runtime@5.8.38/core-js/object/assign.js", "npm:codemirror@5.21.0.js", "npm:codemirror@5.21.0/mode/javascript/javascript.js", "src/instrument.js", "src/flame-graph.js", "src/query-lib.js", "src/coderunnerworker.js!github:casperlamboo/plugin-worker@master.js", "src/worker-utils.js", "src/utils.js", "src/instrument-lib.js", "npm:recast@0.11.18.js"], function (_export) {
    var _toConsumableArray, _Object$assign, CodeMirror, instrument, FlameGraph, swatches, queryLib, CodeRunner, WorkerEvent, $, clear, deepEquals, serializableReviver, _ExecutionTrace, ExecutionState, _FnCall, recast, editor, query, savedEditorContent, savedQueryContent, timeoute, timeoutq, lagTime, codeRunner, uidToCall, trace, state, lookupUid, reviver, visualization;

    function save() {
        localStorage.setItem('clarinet.editor', editor.getValue());
        localStorage.setItem('clarinet.query', query.getValue());
    }

    function error(item) {
        var tag = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

        if (tag !== '') {
            tag = tag + ': ';
        }

        var li = document.createElement('li');
        li.textContent = tag + (item.toString != null ? item.toString() : JSON.stringify(item));
        li.classList.add('error');
        $('#log').insertBefore(li, $('#log').firstChild);
    }

    function log() {
        var li = document.createElement('li');

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        li.textContent = args.join(' ');
        $('#log').insertBefore(li, $('#log').firstChild);
    }

    function runCode() {
        var code = editor.getValue();
        try {
            var instrumented = instrument(code);
            console.info(instrumented.code);
            if (codeRunner !== null) {
                codeRunner.terminate();
            }
            log(' ');
            codeRunner = new CodeRunner();
            codeRunner.postMessage(new WorkerEvent('INITIALIZE', { code: instrumented.code, map: null }));
            codeRunner.addEventListener('message', onMessage);
        } catch (e) {
            error(e);
        }
    }

    function onMessage(e) {
        switch (e.data.name) {
            case 'ERROR':
                console.error.apply(console, _toConsumableArray(e.data.data));
                break;
            case 'INFO':
                console.info.apply(console, _toConsumableArray(e.data.data));
                break;
            case 'WARNING':
                console.warn.apply(console, _toConsumableArray(e.data.data));
                break;
            case 'LOG':
                log.apply(undefined, _toConsumableArray(e.data.data));
                console.log.apply(console, _toConsumableArray(e.data.data));
                break;
            case 'DONE':
                trace = JSON.parse(e.data.trace, reviver);
                console.log(trace);
                if (e.data.error != null) {
                    error(e.data.error);
                }
                if (trace.rootCall !== null) {
                    clear($('#visualization'));
                    visualization = new FlameGraph($('#visualization'), editor, trace.rootCall);
                    visualization.render();
                    window.calls = visualization.data;
                    var queryCode = query.getValue();
                    try {
                        eval(queryCode);
                        calls.refresh();
                    } catch (e) {
                        error(e, 'QUERY');
                    }
                }
                codeRunner = null;
                break;
        }
    }

    function runQuery() {
        var queryCode = query.getValue();
        try {
            eval(queryCode);
            calls.refresh();
        } catch (e) {
            error(e, 'QUERY');
        }
    }

    return {
        setters: [function (_npmBabelRuntime5838HelpersToConsumableArrayJs) {
            _toConsumableArray = _npmBabelRuntime5838HelpersToConsumableArrayJs["default"];
        }, function (_npmBabelRuntime5838CoreJsObjectAssignJs) {
            _Object$assign = _npmBabelRuntime5838CoreJsObjectAssignJs["default"];
        }, function (_npmCodemirror5210Js) {
            CodeMirror = _npmCodemirror5210Js["default"];
        }, function (_npmCodemirror5210ModeJavascriptJavascriptJs) {}, function (_srcInstrumentJs) {
            instrument = _srcInstrumentJs["default"];
        }, function (_srcFlameGraphJs) {
            FlameGraph = _srcFlameGraphJs["default"];
            swatches = _srcFlameGraphJs.swatches;
        }, function (_srcQueryLibJs) {
            queryLib = _srcQueryLibJs;
        }, function (_srcCoderunnerworkerJsGithubCasperlambooPluginWorkerMasterJs) {
            CodeRunner = _srcCoderunnerworkerJsGithubCasperlambooPluginWorkerMasterJs["default"];
        }, function (_srcWorkerUtilsJs) {
            WorkerEvent = _srcWorkerUtilsJs.WorkerEvent;
        }, function (_srcUtilsJs) {
            $ = _srcUtilsJs.$;
            clear = _srcUtilsJs.clear;
            deepEquals = _srcUtilsJs.deepEquals;
        }, function (_srcInstrumentLibJs) {
            serializableReviver = _srcInstrumentLibJs.serializableReviver;
            _ExecutionTrace = _srcInstrumentLibJs.ExecutionTrace;
            ExecutionState = _srcInstrumentLibJs.ExecutionState;
            _FnCall = _srcInstrumentLibJs.FnCall;
        }, function (_npmRecast01118Js) {
            recast = _npmRecast01118Js["default"];
        }],
        execute: function () {
            "use strict";

            window.swatches = swatches;

            _Object$assign(window, queryLib);

            window.recast = recast;

            window.deepEquals = deepEquals;

            editor = CodeMirror.fromTextArea($('#editor'), {
                lineNumbers: true,
                mode: 'javascript',
                theme: 'grayscale',
                extraKeys: {
                    'Ctrl-Enter': runCode
                }
            });
            query = CodeMirror.fromTextArea($('#query'), {
                lineNumbers: true,
                mode: 'javascript',
                theme: 'grayscale',
                extraKeys: {
                    'Ctrl-Enter': runCode
                }
            });

            window.editor = editor;

            savedEditorContent = localStorage.getItem('clarinet.editor');
            savedQueryContent = localStorage.getItem('clarinet.query');

            if (savedEditorContent !== null && savedEditorContent.trim() !== '') {
                editor.setValue(savedEditorContent);
            }
            if (savedQueryContent !== null && savedQueryContent.trim() !== '') {
                query.setValue(savedQueryContent);
            }

            timeoute = null;

            editor.on('change', function () {
                if (timeoute !== null) {
                    clearTimeout(timeoute);
                }
                timeoute = setTimeout(save, lagTime);
            });

            timeoutq = null;
            lagTime = 100;

            query.on('change', function () {
                if (timeoutq !== null) {
                    clearTimeout(timeoutq);
                }
                timeoutq = setTimeout(save, lagTime);
            });codeRunner = null;
            uidToCall = {};
            trace = null;
            state = new ExecutionState();

            window.state = state;

            lookupUid = function lookupUid(uid) {
                return uid === null ? null : uidToCall[uid];
            };

            reviver = serializableReviver({
                ExecutionTrace: function ExecutionTrace() {
                    var ans = new _ExecutionTrace();
                    ans._lookupUid = lookupUid;
                    return ans;
                },
                FnCall: function FnCall(value) {
                    var ans = new _FnCall(value.fnName, null, value.args);
                    ans._lookupUid = lookupUid;
                    uidToCall[value.uid] = ans;
                    return ans;
                }
            });
            window.editor = editor;

            runCode();
        }
    };
});
//# sourceMappingURL=app.js.map